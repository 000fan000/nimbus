<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nimbus: /Users/featherless/workbench/ios/nimbus/src/JSONKit/src/JSONKit.m Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24278774-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>
<div id="page">
<div style="position:relative">
<div id="top"><!-- do not remove this div! -->

<div id="titlearea">
<a style="float: right;margin-right:20px;margin-top:20px" href='http://www.pledgie.com/campaigns/15519'><img alt='Click here to support Nimbus development and make a donation at www.pledgie.com !' src='http://www.pledgie.com/campaigns/15519.png?skin_name=chrome' border='0' /></a>
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Nimbus
   &#160;<span id="projectnumber">0.5.0 - <a href="http://github.com/jverkoey/nimbus">Nimbus is proudly hosted on Github</a></span>
   </div>
   <div id="projectbrief">An iOS framework whose growth is bounded by O(documentation).</div>
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.4-20110629 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_j_s_o_n_kit_8m.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">/Users/featherless/workbench/ios/nimbus/src/JSONKit/src/JSONKit.m</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//</span>
<a name="l00002"></a>00002 <span class="comment">//  JSONKit.m</span>
<a name="l00003"></a>00003 <span class="comment">//  http://github.com/johnezang/JSONKit</span>
<a name="l00004"></a>00004 <span class="comment">//  Dual licensed under either the terms of the BSD License, or alternatively</span>
<a name="l00005"></a>00005 <span class="comment">//  under the terms of the Apache License, Version 2.0, as specified below.</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="comment">/*</span>
<a name="l00009"></a>00009 <span class="comment"> Copyright (c) 2011, John Engelhart</span>
<a name="l00010"></a>00010 <span class="comment"> </span>
<a name="l00011"></a>00011 <span class="comment"> All rights reserved.</span>
<a name="l00012"></a>00012 <span class="comment"> </span>
<a name="l00013"></a>00013 <span class="comment"> Redistribution and use in source and binary forms, with or without</span>
<a name="l00014"></a>00014 <span class="comment"> modification, are permitted provided that the following conditions are met:</span>
<a name="l00015"></a>00015 <span class="comment"> </span>
<a name="l00016"></a>00016 <span class="comment"> * Redistributions of source code must retain the above copyright</span>
<a name="l00017"></a>00017 <span class="comment"> notice, this list of conditions and the following disclaimer.</span>
<a name="l00018"></a>00018 <span class="comment"> </span>
<a name="l00019"></a>00019 <span class="comment"> * Redistributions in binary form must reproduce the above copyright</span>
<a name="l00020"></a>00020 <span class="comment"> notice, this list of conditions and the following disclaimer in the</span>
<a name="l00021"></a>00021 <span class="comment"> documentation and/or other materials provided with the distribution.</span>
<a name="l00022"></a>00022 <span class="comment"> </span>
<a name="l00023"></a>00023 <span class="comment"> * Neither the name of the Zang Industries nor the names of its</span>
<a name="l00024"></a>00024 <span class="comment"> contributors may be used to endorse or promote products derived from</span>
<a name="l00025"></a>00025 <span class="comment"> this software without specific prior written permission.</span>
<a name="l00026"></a>00026 <span class="comment"> </span>
<a name="l00027"></a>00027 <span class="comment"> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a name="l00028"></a>00028 <span class="comment"> &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00029"></a>00029 <span class="comment"> LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<a name="l00030"></a>00030 <span class="comment"> A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<a name="l00031"></a>00031 <span class="comment"> OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<a name="l00032"></a>00032 <span class="comment"> SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED</span>
<a name="l00033"></a>00033 <span class="comment"> TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span>
<a name="l00034"></a>00034 <span class="comment"> PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<a name="l00035"></a>00035 <span class="comment"> LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<a name="l00036"></a>00036 <span class="comment"> NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<a name="l00037"></a>00037 <span class="comment"> SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00038"></a>00038 <span class="comment">*/</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="comment">/*</span>
<a name="l00041"></a>00041 <span class="comment"> Copyright 2011 John Engelhart</span>
<a name="l00042"></a>00042 <span class="comment"> </span>
<a name="l00043"></a>00043 <span class="comment"> Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<a name="l00044"></a>00044 <span class="comment"> you may not use this file except in compliance with the License.</span>
<a name="l00045"></a>00045 <span class="comment"> You may obtain a copy of the License at</span>
<a name="l00046"></a>00046 <span class="comment"> </span>
<a name="l00047"></a>00047 <span class="comment"> http://www.apache.org/licenses/LICENSE-2.0</span>
<a name="l00048"></a>00048 <span class="comment"> </span>
<a name="l00049"></a>00049 <span class="comment"> Unless required by applicable law or agreed to in writing, software</span>
<a name="l00050"></a>00050 <span class="comment"> distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<a name="l00051"></a>00051 <span class="comment"> WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<a name="l00052"></a>00052 <span class="comment"> See the License for the specific language governing permissions and</span>
<a name="l00053"></a>00053 <span class="comment"> limitations under the License.</span>
<a name="l00054"></a>00054 <span class="comment">*/</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="comment">/*</span>
<a name="l00058"></a>00058 <span class="comment">  Acknowledgments:</span>
<a name="l00059"></a>00059 <span class="comment"></span>
<a name="l00060"></a>00060 <span class="comment">  The bulk of the UTF8 / UTF32 conversion and verification comes</span>
<a name="l00061"></a>00061 <span class="comment">  from ConvertUTF.[hc].  It has been modified from the original sources.</span>
<a name="l00062"></a>00062 <span class="comment"></span>
<a name="l00063"></a>00063 <span class="comment">  The original sources were obtained from http://www.unicode.org/.</span>
<a name="l00064"></a>00064 <span class="comment">  However, the web site no longer seems to host the files.  Instead,</span>
<a name="l00065"></a>00065 <span class="comment">  the Unicode FAQ http://www.unicode.org/faq//utf_bom.html#gen4</span>
<a name="l00066"></a>00066 <span class="comment">  points to International Components for Unicode (ICU)</span>
<a name="l00067"></a>00067 <span class="comment">  http://site.icu-project.org/ as an example of how to write a UTF</span>
<a name="l00068"></a>00068 <span class="comment">  converter.</span>
<a name="l00069"></a>00069 <span class="comment"></span>
<a name="l00070"></a>00070 <span class="comment">  The decision to use the ConvertUTF.[ch] code was made to leverage</span>
<a name="l00071"></a>00071 <span class="comment">  &quot;proven&quot; code.  Hopefully the local modifications are bug free.</span>
<a name="l00072"></a>00072 <span class="comment"></span>
<a name="l00073"></a>00073 <span class="comment">  The code in isValidCodePoint() is derived from the ICU code in</span>
<a name="l00074"></a>00074 <span class="comment">  utf.h for the macros U_IS_UNICODE_NONCHAR and U_IS_UNICODE_CHAR.</span>
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">  From the original ConvertUTF.[ch]:</span>
<a name="l00077"></a>00077 <span class="comment"></span>
<a name="l00078"></a>00078 <span class="comment"> * Copyright 2001-2004 Unicode, Inc.</span>
<a name="l00079"></a>00079 <span class="comment"> * </span>
<a name="l00080"></a>00080 <span class="comment"> * Disclaimer</span>
<a name="l00081"></a>00081 <span class="comment"> * </span>
<a name="l00082"></a>00082 <span class="comment"> * This source code is provided as is by Unicode, Inc. No claims are</span>
<a name="l00083"></a>00083 <span class="comment"> * made as to fitness for any particular purpose. No warranties of any</span>
<a name="l00084"></a>00084 <span class="comment"> * kind are expressed or implied. The recipient agrees to determine</span>
<a name="l00085"></a>00085 <span class="comment"> * applicability of information provided. If this file has been</span>
<a name="l00086"></a>00086 <span class="comment"> * purchased on magnetic or optical media from Unicode, Inc., the</span>
<a name="l00087"></a>00087 <span class="comment"> * sole remedy for any claim will be exchange of defective media</span>
<a name="l00088"></a>00088 <span class="comment"> * within 90 days of receipt.</span>
<a name="l00089"></a>00089 <span class="comment"> * </span>
<a name="l00090"></a>00090 <span class="comment"> * Limitations on Rights to Redistribute This Code</span>
<a name="l00091"></a>00091 <span class="comment"> * </span>
<a name="l00092"></a>00092 <span class="comment"> * Unicode, Inc. hereby grants the right to freely use the information</span>
<a name="l00093"></a>00093 <span class="comment"> * supplied in this file in the creation of products supporting the</span>
<a name="l00094"></a>00094 <span class="comment"> * Unicode Standard, and to make copies of this file in any form</span>
<a name="l00095"></a>00095 <span class="comment"> * for internal or external distribution as long as this notice</span>
<a name="l00096"></a>00096 <span class="comment"> * remains attached.</span>
<a name="l00097"></a>00097 <span class="comment"></span>
<a name="l00098"></a>00098 <span class="comment">*/</span>
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00101"></a>00101 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00102"></a>00102 <span class="preprocessor">#include &lt;stdint.h&gt;</span>
<a name="l00103"></a>00103 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00104"></a>00104 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00105"></a>00105 <span class="preprocessor">#include &lt;sys/errno.h&gt;</span>
<a name="l00106"></a>00106 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00107"></a>00107 <span class="preprocessor">#include &lt;limits.h&gt;</span>
<a name="l00108"></a>00108 <span class="preprocessor">#include &lt;objc/runtime.h&gt;</span>
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="preprocessor">#import &quot;JSONKit.h&quot;</span>
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="comment">//#include &lt;CoreFoundation/CoreFoundation.h&gt;</span>
<a name="l00113"></a>00113 <span class="preprocessor">#include &lt;CoreFoundation/CFString.h&gt;</span>
<a name="l00114"></a>00114 <span class="preprocessor">#include &lt;CoreFoundation/CFArray.h&gt;</span>
<a name="l00115"></a>00115 <span class="preprocessor">#include &lt;CoreFoundation/CFDictionary.h&gt;</span>
<a name="l00116"></a>00116 <span class="preprocessor">#include &lt;CoreFoundation/CFNumber.h&gt;</span>
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 <span class="comment">//#import &lt;Foundation/Foundation.h&gt;</span>
<a name="l00119"></a>00119 <span class="preprocessor">#import &lt;Foundation/NSArray.h&gt;</span>
<a name="l00120"></a>00120 <span class="preprocessor">#import &lt;Foundation/NSAutoreleasePool.h&gt;</span>
<a name="l00121"></a>00121 <span class="preprocessor">#import &lt;Foundation/NSData.h&gt;</span>
<a name="l00122"></a>00122 <span class="preprocessor">#import &lt;Foundation/NSDictionary.h&gt;</span>
<a name="l00123"></a>00123 <span class="preprocessor">#import &lt;Foundation/NSException.h&gt;</span>
<a name="l00124"></a>00124 <span class="preprocessor">#import &lt;Foundation/NSNull.h&gt;</span>
<a name="l00125"></a>00125 <span class="preprocessor">#import &lt;Foundation/NSObjCRuntime.h&gt;</span>
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 <span class="preprocessor">#ifndef __has_feature</span>
<a name="l00128"></a>00128 <span class="preprocessor"></span><span class="preprocessor">#define __has_feature(x) 0</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span>
<a name="l00131"></a>00131 <span class="preprocessor">#ifdef JK_ENABLE_CF_TRANSFER_OWNERSHIP_CALLBACKS</span>
<a name="l00132"></a>00132 <span class="preprocessor"></span><span class="preprocessor">#warning As of JSONKit v1.4, JK_ENABLE_CF_TRANSFER_OWNERSHIP_CALLBACKS is no longer required.  It is no longer a valid option.</span>
<a name="l00133"></a>00133 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span>
<a name="l00135"></a>00135 <span class="preprocessor">#ifdef __OBJC_GC__</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span><span class="preprocessor">#error JSONKit does not support Objective-C Garbage Collection</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00138"></a>00138 <span class="preprocessor"></span>
<a name="l00139"></a>00139 <span class="preprocessor">#if __has_feature(objc_arc)</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span><span class="preprocessor">#error JSONKit does not support Objective-C Automatic Reference Counting (ARC)</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00142"></a>00142 <span class="preprocessor"></span>
<a name="l00143"></a>00143 <span class="comment">// The following checks are really nothing more than sanity checks.</span>
<a name="l00144"></a>00144 <span class="comment">// JSONKit technically has a few problems from a &quot;strictly C99 conforming&quot; standpoint, though they are of the pedantic nitpicking variety.</span>
<a name="l00145"></a>00145 <span class="comment">// In practice, though, for the compilers and architectures we can reasonably expect this code to be compiled for, these pedantic nitpicks aren&#39;t really a problem.</span>
<a name="l00146"></a>00146 <span class="comment">// Since we&#39;re limited as to what we can do with pre-processor #if checks, these checks are not nearly as through as they should be.</span>
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 <span class="preprocessor">#if (UINT_MAX != 0xffffffffU) || (INT_MIN != (-0x7fffffff-1)) || (ULLONG_MAX != 0xffffffffffffffffULL) || (LLONG_MIN != (-0x7fffffffffffffffLL-1LL))</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span><span class="preprocessor">#error JSONKit requires the C &#39;int&#39; and &#39;long long&#39; types to be 32 and 64 bits respectively.</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span>
<a name="l00152"></a>00152 <span class="preprocessor">#if !defined(__LP64__) &amp;&amp; ((UINT_MAX != ULONG_MAX) || (INT_MAX != LONG_MAX) || (INT_MIN != LONG_MIN) || (WORD_BIT != LONG_BIT))</span>
<a name="l00153"></a>00153 <span class="preprocessor"></span><span class="preprocessor">#error JSONKit requires the C &#39;int&#39; and &#39;long&#39; types to be the same on 32-bit architectures.</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span>
<a name="l00156"></a>00156 <span class="comment">// Cocoa / Foundation uses NS*Integer as the type for a lot of arguments.  We make sure that NS*Integer is something we are expecting and is reasonably compatible with size_t / ssize_t</span>
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="preprocessor">#if (NSUIntegerMax != ULONG_MAX) || (NSIntegerMax != LONG_MAX) || (NSIntegerMin != LONG_MIN)</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span><span class="preprocessor">#error JSONKit requires NSInteger and NSUInteger to be the same size as the C &#39;long&#39; type.</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span>
<a name="l00162"></a>00162 <span class="preprocessor">#if (NSUIntegerMax != SIZE_MAX) || (NSIntegerMax != SSIZE_MAX)</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span><span class="preprocessor">#error JSONKit requires NSInteger and NSUInteger to be the same size as the C &#39;size_t&#39; type.</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span>
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 <span class="comment">// For DJB hash.</span>
<a name="l00168"></a>00168 <span class="preprocessor">#define JK_HASH_INIT           (1402737925UL)</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span>
<a name="l00170"></a>00170 <span class="comment">// Use __builtin_clz() instead of trailingBytesForUTF8[] table lookup.</span>
<a name="l00171"></a>00171 <span class="preprocessor">#define JK_FAST_TRAILING_BYTES</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span>
<a name="l00173"></a>00173 <span class="comment">// JK_CACHE_SLOTS must be a power of 2.  Default size is 1024 slots.</span>
<a name="l00174"></a>00174 <span class="preprocessor">#define JK_CACHE_SLOTS_BITS    (10)</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span><span class="preprocessor">#define JK_CACHE_SLOTS         (1UL &lt;&lt; JK_CACHE_SLOTS_BITS)</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span><span class="comment">// JK_CACHE_PROBES is the number of probe attempts.</span>
<a name="l00177"></a>00177 <span class="preprocessor">#define JK_CACHE_PROBES        (4UL)</span>
<a name="l00178"></a>00178 <span class="preprocessor"></span><span class="comment">// JK_INIT_CACHE_AGE must be (1 &lt;&lt; AGE) - 1</span>
<a name="l00179"></a>00179 <span class="preprocessor">#define JK_INIT_CACHE_AGE      (0)</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span>
<a name="l00181"></a>00181 <span class="comment">// JK_TOKENBUFFER_SIZE is the default stack size for the temporary buffer used to hold &quot;non-simple&quot; strings (i.e., contains \ escapes)</span>
<a name="l00182"></a>00182 <span class="preprocessor">#define JK_TOKENBUFFER_SIZE    (1024UL * 2UL)</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span>
<a name="l00184"></a>00184 <span class="comment">// JK_STACK_OBJS is the default number of spaces reserved on the stack for temporarily storing pointers to Obj-C objects before they can be transferred to a NSArray / NSDictionary.</span>
<a name="l00185"></a>00185 <span class="preprocessor">#define JK_STACK_OBJS          (1024UL * 1UL)</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span>
<a name="l00187"></a>00187 <span class="preprocessor">#define JK_JSONBUFFER_SIZE     (1024UL * 4UL)</span>
<a name="l00188"></a>00188 <span class="preprocessor"></span><span class="preprocessor">#define JK_UTF8BUFFER_SIZE     (1024UL * 16UL)</span>
<a name="l00189"></a>00189 <span class="preprocessor"></span>
<a name="l00190"></a>00190 <span class="preprocessor">#define JK_ENCODE_CACHE_SLOTS  (1024UL)</span>
<a name="l00191"></a>00191 <span class="preprocessor"></span>
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="preprocessor">#if       defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4)</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span><span class="preprocessor">#define JK_ATTRIBUTES(attr, ...)        __attribute__((attr, ##__VA_ARGS__))</span>
<a name="l00195"></a>00195 <span class="preprocessor"></span><span class="preprocessor">#define JK_EXPECTED(cond, expect)       __builtin_expect((long)(cond), (expect))</span>
<a name="l00196"></a>00196 <span class="preprocessor"></span><span class="preprocessor">#define JK_EXPECT_T(cond)               JK_EXPECTED(cond, 1U)</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span><span class="preprocessor">#define JK_EXPECT_F(cond)               JK_EXPECTED(cond, 0U)</span>
<a name="l00198"></a>00198 <span class="preprocessor"></span><span class="preprocessor">#define JK_PREFETCH(ptr)                __builtin_prefetch(ptr)</span>
<a name="l00199"></a>00199 <span class="preprocessor"></span><span class="preprocessor">#else  // defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) </span>
<a name="l00200"></a>00200 <span class="preprocessor"></span><span class="preprocessor">#define JK_ATTRIBUTES(attr, ...)</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span><span class="preprocessor">#define JK_EXPECTED(cond, expect)       (cond)</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span><span class="preprocessor">#define JK_EXPECT_T(cond)               (cond)</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span><span class="preprocessor">#define JK_EXPECT_F(cond)               (cond)</span>
<a name="l00204"></a>00204 <span class="preprocessor"></span><span class="preprocessor">#define JK_PREFETCH(ptr)</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span><span class="preprocessor">#endif // defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) </span>
<a name="l00206"></a>00206 <span class="preprocessor"></span>
<a name="l00207"></a>00207 <span class="preprocessor">#define JK_STATIC_INLINE                         static __inline__ JK_ATTRIBUTES(always_inline)</span>
<a name="l00208"></a>00208 <span class="preprocessor"></span><span class="preprocessor">#define JK_ALIGNED(arg)                                            JK_ATTRIBUTES(aligned(arg))</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span><span class="preprocessor">#define JK_UNUSED_ARG                                              JK_ATTRIBUTES(unused)</span>
<a name="l00210"></a>00210 <span class="preprocessor"></span><span class="preprocessor">#define JK_WARN_UNUSED                                             JK_ATTRIBUTES(warn_unused_result)</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span><span class="preprocessor">#define JK_WARN_UNUSED_CONST                                       JK_ATTRIBUTES(warn_unused_result, const)</span>
<a name="l00212"></a>00212 <span class="preprocessor"></span><span class="preprocessor">#define JK_WARN_UNUSED_PURE                                        JK_ATTRIBUTES(warn_unused_result, pure)</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span><span class="preprocessor">#define JK_WARN_UNUSED_SENTINEL                                    JK_ATTRIBUTES(warn_unused_result, sentinel)</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span><span class="preprocessor">#define JK_NONNULL_ARGS(arg, ...)                                  JK_ATTRIBUTES(nonnull(arg, ##__VA_ARGS__))</span>
<a name="l00215"></a>00215 <span class="preprocessor"></span><span class="preprocessor">#define JK_WARN_UNUSED_NONNULL_ARGS(arg, ...)                      JK_ATTRIBUTES(warn_unused_result, nonnull(arg, ##__VA_ARGS__))</span>
<a name="l00216"></a>00216 <span class="preprocessor"></span><span class="preprocessor">#define JK_WARN_UNUSED_CONST_NONNULL_ARGS(arg, ...)                JK_ATTRIBUTES(warn_unused_result, const, nonnull(arg, ##__VA_ARGS__))</span>
<a name="l00217"></a>00217 <span class="preprocessor"></span><span class="preprocessor">#define JK_WARN_UNUSED_PURE_NONNULL_ARGS(arg, ...)                 JK_ATTRIBUTES(warn_unused_result, pure, nonnull(arg, ##__VA_ARGS__))</span>
<a name="l00218"></a>00218 <span class="preprocessor"></span>
<a name="l00219"></a>00219 <span class="preprocessor">#if       defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 3)</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span><span class="preprocessor">#define JK_ALLOC_SIZE_NON_NULL_ARGS_WARN_UNUSED(as, nn, ...) JK_ATTRIBUTES(warn_unused_result, nonnull(nn, ##__VA_ARGS__), alloc_size(as))</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span><span class="preprocessor">#else  // defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 3)</span>
<a name="l00222"></a>00222 <span class="preprocessor"></span><span class="preprocessor">#define JK_ALLOC_SIZE_NON_NULL_ARGS_WARN_UNUSED(as, nn, ...) JK_ATTRIBUTES(warn_unused_result, nonnull(nn, ##__VA_ARGS__))</span>
<a name="l00223"></a>00223 <span class="preprocessor"></span><span class="preprocessor">#endif // defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 3)</span>
<a name="l00224"></a>00224 <span class="preprocessor"></span>
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="keyword">@class</span> JKArray, JKDictionaryEnumerator, JKDictionary;
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="keyword">enum</span> {
<a name="l00229"></a>00229   JSONNumberStateStart                 = 0,
<a name="l00230"></a>00230   JSONNumberStateFinished              = 1,
<a name="l00231"></a>00231   JSONNumberStateError                 = 2,
<a name="l00232"></a>00232   JSONNumberStateWholeNumberStart      = 3,
<a name="l00233"></a>00233   JSONNumberStateWholeNumberMinus      = 4,
<a name="l00234"></a>00234   JSONNumberStateWholeNumberZero       = 5,
<a name="l00235"></a>00235   JSONNumberStateWholeNumber           = 6,
<a name="l00236"></a>00236   JSONNumberStatePeriod                = 7,
<a name="l00237"></a>00237   JSONNumberStateFractionalNumberStart = 8,
<a name="l00238"></a>00238   JSONNumberStateFractionalNumber      = 9,
<a name="l00239"></a>00239   JSONNumberStateExponentStart         = 10,
<a name="l00240"></a>00240   JSONNumberStateExponentPlusMinus     = 11,
<a name="l00241"></a>00241   JSONNumberStateExponent              = 12,
<a name="l00242"></a>00242 };
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 <span class="keyword">enum</span> {
<a name="l00245"></a>00245   JSONStringStateStart                           = 0,
<a name="l00246"></a>00246   JSONStringStateParsing                         = 1,
<a name="l00247"></a>00247   JSONStringStateFinished                        = 2,
<a name="l00248"></a>00248   JSONStringStateError                           = 3,
<a name="l00249"></a>00249   JSONStringStateEscape                          = 4,
<a name="l00250"></a>00250   JSONStringStateEscapedUnicode1                 = 5,
<a name="l00251"></a>00251   JSONStringStateEscapedUnicode2                 = 6,
<a name="l00252"></a>00252   JSONStringStateEscapedUnicode3                 = 7,
<a name="l00253"></a>00253   JSONStringStateEscapedUnicode4                 = 8,
<a name="l00254"></a>00254   JSONStringStateEscapedUnicodeSurrogate1        = 9,
<a name="l00255"></a>00255   JSONStringStateEscapedUnicodeSurrogate2        = 10,
<a name="l00256"></a>00256   JSONStringStateEscapedUnicodeSurrogate3        = 11,
<a name="l00257"></a>00257   JSONStringStateEscapedUnicodeSurrogate4        = 12,
<a name="l00258"></a>00258   JSONStringStateEscapedNeedEscapeForSurrogate   = 13,
<a name="l00259"></a>00259   JSONStringStateEscapedNeedEscapedUForSurrogate = 14,
<a name="l00260"></a>00260 };
<a name="l00261"></a>00261 
<a name="l00262"></a>00262 <span class="keyword">enum</span> {
<a name="l00263"></a>00263   JKParseAcceptValue      = (1 &lt;&lt; 0),
<a name="l00264"></a>00264   JKParseAcceptComma      = (1 &lt;&lt; 1),
<a name="l00265"></a>00265   JKParseAcceptEnd        = (1 &lt;&lt; 2),
<a name="l00266"></a>00266   JKParseAcceptValueOrEnd = (JKParseAcceptValue | JKParseAcceptEnd),
<a name="l00267"></a>00267   JKParseAcceptCommaOrEnd = (JKParseAcceptComma | JKParseAcceptEnd),
<a name="l00268"></a>00268 };
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 <span class="keyword">enum</span> {
<a name="l00271"></a>00271   JKClassUnknown    = 0,
<a name="l00272"></a>00272   JKClassString     = 1,
<a name="l00273"></a>00273   JKClassNumber     = 2,
<a name="l00274"></a>00274   JKClassArray      = 3,
<a name="l00275"></a>00275   JKClassDictionary = 4,
<a name="l00276"></a>00276   JKClassNull       = 5,
<a name="l00277"></a>00277 };
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="keyword">enum</span> {
<a name="l00280"></a>00280   JKManagedBufferOnStack        = 1,
<a name="l00281"></a>00281   JKManagedBufferOnHeap         = 2,
<a name="l00282"></a>00282   JKManagedBufferLocationMask   = (0x3),
<a name="l00283"></a>00283   JKManagedBufferLocationShift  = (0),
<a name="l00284"></a>00284   
<a name="l00285"></a>00285   JKManagedBufferMustFree       = (1 &lt;&lt; 2),
<a name="l00286"></a>00286 };
<a name="l00287"></a>00287 <span class="keyword">typedef</span> JKFlags JKManagedBufferFlags;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="keyword">enum</span> {
<a name="l00290"></a>00290   JKObjectStackOnStack        = 1,
<a name="l00291"></a>00291   JKObjectStackOnHeap         = 2,
<a name="l00292"></a>00292   JKObjectStackLocationMask   = (0x3),
<a name="l00293"></a>00293   JKObjectStackLocationShift  = (0),
<a name="l00294"></a>00294   
<a name="l00295"></a>00295   JKObjectStackMustFree       = (1 &lt;&lt; 2),
<a name="l00296"></a>00296 };
<a name="l00297"></a>00297 <span class="keyword">typedef</span> JKFlags JKObjectStackFlags;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 <span class="keyword">enum</span> {
<a name="l00300"></a>00300   JKTokenTypeInvalid     = 0,
<a name="l00301"></a>00301   JKTokenTypeNumber      = 1,
<a name="l00302"></a>00302   JKTokenTypeString      = 2,
<a name="l00303"></a>00303   JKTokenTypeObjectBegin = 3,
<a name="l00304"></a>00304   JKTokenTypeObjectEnd   = 4,
<a name="l00305"></a>00305   JKTokenTypeArrayBegin  = 5,
<a name="l00306"></a>00306   JKTokenTypeArrayEnd    = 6,
<a name="l00307"></a>00307   JKTokenTypeSeparator   = 7,
<a name="l00308"></a>00308   JKTokenTypeComma       = 8,
<a name="l00309"></a>00309   JKTokenTypeTrue        = 9,
<a name="l00310"></a>00310   JKTokenTypeFalse       = 10,
<a name="l00311"></a>00311   JKTokenTypeNull        = 11,
<a name="l00312"></a>00312   JKTokenTypeWhiteSpace  = 12,
<a name="l00313"></a>00313 };
<a name="l00314"></a>00314 <span class="keyword">typedef</span> NSUInteger JKTokenType;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="comment">// These are prime numbers to assist with hash slot probing.</span>
<a name="l00317"></a>00317 <span class="keyword">enum</span> {
<a name="l00318"></a>00318   JKValueTypeNone             = 0,
<a name="l00319"></a>00319   JKValueTypeString           = 5,
<a name="l00320"></a>00320   JKValueTypeLongLong         = 7,
<a name="l00321"></a>00321   JKValueTypeUnsignedLongLong = 11,
<a name="l00322"></a>00322   JKValueTypeDouble           = 13,
<a name="l00323"></a>00323 };
<a name="l00324"></a>00324 <span class="keyword">typedef</span> NSUInteger JKValueType;
<a name="l00325"></a>00325 
<a name="l00326"></a>00326 <span class="keyword">enum</span> {
<a name="l00327"></a>00327   JKEncodeOptionAsData              = 1,
<a name="l00328"></a>00328   JKEncodeOptionAsString            = 2,
<a name="l00329"></a>00329   JKEncodeOptionAsTypeMask          = 0x7,
<a name="l00330"></a>00330   JKEncodeOptionCollectionObj       = (1 &lt;&lt; 3),
<a name="l00331"></a>00331   JKEncodeOptionStringObj           = (1 &lt;&lt; 4),
<a name="l00332"></a>00332   JKEncodeOptionStringObjTrimQuotes = (1 &lt;&lt; 5),
<a name="l00333"></a>00333   
<a name="l00334"></a>00334 };
<a name="l00335"></a>00335 <span class="keyword">typedef</span> NSUInteger JKEncodeOptionType;
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <span class="keyword">typedef</span> NSUInteger JKHash;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKTokenCacheItem  JKTokenCacheItem;
<a name="l00340"></a>00340 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKTokenCache      JKTokenCache;
<a name="l00341"></a>00341 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKTokenValue      JKTokenValue;
<a name="l00342"></a>00342 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKParseToken      JKParseToken;
<a name="l00343"></a>00343 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKPtrRange        JKPtrRange;
<a name="l00344"></a>00344 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKObjectStack     JKObjectStack;
<a name="l00345"></a>00345 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKBuffer          JKBuffer;
<a name="l00346"></a>00346 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKConstBuffer     JKConstBuffer;
<a name="l00347"></a>00347 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKConstPtrRange   JKConstPtrRange;
<a name="l00348"></a>00348 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKRange           JKRange;
<a name="l00349"></a>00349 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKManagedBuffer   JKManagedBuffer;
<a name="l00350"></a>00350 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKFastClassLookup JKFastClassLookup;
<a name="l00351"></a>00351 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKEncodeCache     JKEncodeCache;
<a name="l00352"></a>00352 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKEncodeState     JKEncodeState;
<a name="l00353"></a>00353 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKObjCImpCache    JKObjCImpCache;
<a name="l00354"></a>00354 <span class="keyword">typedef</span> <span class="keyword">struct </span>JKHashTableEntry  JKHashTableEntry;
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="keyword">typedef</span> id (*NSNumberAllocImp)(<span class="keywordtype">id</span> receiver, <span class="keywordtype">SEL</span> selector);
<a name="l00357"></a>00357 <span class="keyword">typedef</span> id (*NSNumberInitWithUnsignedLongLongImp)(<span class="keywordtype">id</span> receiver, <span class="keywordtype">SEL</span> selector, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> value);
<a name="l00358"></a>00358 <span class="keyword">typedef</span> id (*JKClassFormatterIMP)(<span class="keywordtype">id</span> receiver, <span class="keywordtype">SEL</span> selector, <span class="keywordtype">id</span> object);
<a name="l00359"></a>00359 <span class="preprocessor">#ifdef __BLOCKS__</span>
<a name="l00360"></a>00360 <span class="preprocessor"></span><span class="keyword">typedef</span> id (^JKClassFormatterBlock)(<span class="keywordtype">id</span> formatObject);
<a name="l00361"></a>00361 <span class="preprocessor">#endif</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span>
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 <span class="keyword">struct </span>JKPtrRange {
<a name="l00365"></a>00365   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ptr;
<a name="l00366"></a>00366   <span class="keywordtype">size_t</span>         length;
<a name="l00367"></a>00367 };
<a name="l00368"></a>00368 
<a name="l00369"></a>00369 <span class="keyword">struct </span>JKConstPtrRange {
<a name="l00370"></a>00370   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ptr;
<a name="l00371"></a>00371   <span class="keywordtype">size_t</span>               length;
<a name="l00372"></a>00372 };
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 <span class="keyword">struct </span>JKRange {
<a name="l00375"></a>00375   <span class="keywordtype">size_t</span> location, length;
<a name="l00376"></a>00376 };
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="keyword">struct </span>JKManagedBuffer {
<a name="l00379"></a>00379   JKPtrRange           bytes;
<a name="l00380"></a>00380   JKManagedBufferFlags flags;
<a name="l00381"></a>00381   <span class="keywordtype">size_t</span>               roundSizeUpToMultipleOf;
<a name="l00382"></a>00382 };
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 <span class="keyword">struct </span>JKObjectStack {
<a name="l00385"></a>00385   <span class="keywordtype">void</span>               **objects, **keys;
<a name="l00386"></a>00386   CFHashCode          *cfHashes;
<a name="l00387"></a>00387   <span class="keywordtype">size_t</span>               count, index, roundSizeUpToMultipleOf;
<a name="l00388"></a>00388   JKObjectStackFlags   flags;
<a name="l00389"></a>00389 };
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 <span class="keyword">struct </span>JKBuffer {
<a name="l00392"></a>00392   JKPtrRange bytes;
<a name="l00393"></a>00393 };
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 <span class="keyword">struct </span>JKConstBuffer {
<a name="l00396"></a>00396   JKConstPtrRange bytes;
<a name="l00397"></a>00397 };
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 <span class="keyword">struct </span>JKTokenValue {
<a name="l00400"></a>00400   JKConstPtrRange   ptrRange;
<a name="l00401"></a>00401   JKValueType       type;
<a name="l00402"></a>00402   JKHash            hash;
<a name="l00403"></a>00403   <span class="keyword">union </span>{
<a name="l00404"></a>00404     <span class="keywordtype">long</span> <span class="keywordtype">long</span>          longLongValue;
<a name="l00405"></a>00405     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> unsignedLongLongValue;
<a name="l00406"></a>00406     <span class="keywordtype">double</span>             doubleValue;
<a name="l00407"></a>00407   } number;
<a name="l00408"></a>00408   JKTokenCacheItem *cacheItem;
<a name="l00409"></a>00409 };
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="keyword">struct </span>JKParseToken {
<a name="l00412"></a>00412   JKConstPtrRange tokenPtrRange;
<a name="l00413"></a>00413   JKTokenType     type;
<a name="l00414"></a>00414   JKTokenValue    value;
<a name="l00415"></a>00415   JKManagedBuffer tokenBuffer;
<a name="l00416"></a>00416 };
<a name="l00417"></a>00417 
<a name="l00418"></a>00418 <span class="keyword">struct </span>JKTokenCacheItem {
<a name="l00419"></a>00419   <span class="keywordtype">void</span>          *object;
<a name="l00420"></a>00420   JKHash         hash;
<a name="l00421"></a>00421   CFHashCode     cfHash;
<a name="l00422"></a>00422   <span class="keywordtype">size_t</span>         size;
<a name="l00423"></a>00423   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *bytes;
<a name="l00424"></a>00424   JKValueType    type;
<a name="l00425"></a>00425 };
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 <span class="keyword">struct </span>JKTokenCache {
<a name="l00428"></a>00428   JKTokenCacheItem *items;
<a name="l00429"></a>00429   <span class="keywordtype">size_t</span>            count;
<a name="l00430"></a>00430   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      prng_lfsr;
<a name="l00431"></a>00431   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>     age[JK_CACHE_SLOTS];
<a name="l00432"></a>00432 };
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 <span class="keyword">struct </span>JKObjCImpCache {
<a name="l00435"></a>00435   Class                               NSNumberClass;
<a name="l00436"></a>00436   NSNumberAllocImp                    NSNumberAlloc;
<a name="l00437"></a>00437   NSNumberInitWithUnsignedLongLongImp NSNumberInitWithUnsignedLongLong;
<a name="l00438"></a>00438 };
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 <span class="keyword">struct </span>JKParseState {
<a name="l00441"></a>00441   JKParseOptionFlags  parseOptionFlags;
<a name="l00442"></a>00442   JKConstBuffer       stringBuffer;
<a name="l00443"></a>00443   <span class="keywordtype">size_t</span>              atIndex, lineNumber, lineStartIndex;
<a name="l00444"></a>00444   <span class="keywordtype">size_t</span>              prev_atIndex, prev_lineNumber, prev_lineStartIndex;
<a name="l00445"></a>00445   JKParseToken        token;
<a name="l00446"></a>00446   JKObjectStack       objectStack;
<a name="l00447"></a>00447   JKTokenCache        cache;
<a name="l00448"></a>00448   JKObjCImpCache      objCImpCache;
<a name="l00449"></a>00449   NSError            *error;
<a name="l00450"></a>00450   <span class="keywordtype">int</span>                 errorIsPrev;
<a name="l00451"></a>00451   BOOL                mutableCollections;
<a name="l00452"></a>00452 };
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="keyword">struct </span>JKFastClassLookup {
<a name="l00455"></a>00455   <span class="keywordtype">void</span> *stringClass;
<a name="l00456"></a>00456   <span class="keywordtype">void</span> *numberClass;
<a name="l00457"></a>00457   <span class="keywordtype">void</span> *arrayClass;
<a name="l00458"></a>00458   <span class="keywordtype">void</span> *dictionaryClass;
<a name="l00459"></a>00459   <span class="keywordtype">void</span> *nullClass;
<a name="l00460"></a>00460 };
<a name="l00461"></a>00461 
<a name="l00462"></a>00462 <span class="keyword">struct </span>JKEncodeCache {
<a name="l00463"></a>00463   <span class="keywordtype">id</span> object;
<a name="l00464"></a>00464   <span class="keywordtype">size_t</span> offset;
<a name="l00465"></a>00465   <span class="keywordtype">size_t</span> length;
<a name="l00466"></a>00466 };
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 <span class="keyword">struct </span>JKEncodeState {
<a name="l00469"></a>00469   JKManagedBuffer         utf8ConversionBuffer;
<a name="l00470"></a>00470   JKManagedBuffer         stringBuffer;
<a name="l00471"></a>00471   <span class="keywordtype">size_t</span>                  atIndex;
<a name="l00472"></a>00472   JKFastClassLookup       fastClassLookup;
<a name="l00473"></a>00473   JKEncodeCache           cache[JK_ENCODE_CACHE_SLOTS];
<a name="l00474"></a>00474   JKSerializeOptionFlags  serializeOptionFlags;
<a name="l00475"></a>00475   JKEncodeOptionType      encodeOption;
<a name="l00476"></a>00476   <span class="keywordtype">size_t</span>                  depth;
<a name="l00477"></a>00477   NSError                *error;
<a name="l00478"></a>00478   <span class="keywordtype">id</span>                      classFormatterDelegate;
<a name="l00479"></a>00479   <span class="keywordtype">SEL</span>                     classFormatterSelector;
<a name="l00480"></a>00480   JKClassFormatterIMP     classFormatterIMP;
<a name="l00481"></a>00481 <span class="preprocessor">#ifdef __BLOCKS__</span>
<a name="l00482"></a>00482 <span class="preprocessor"></span>  JKClassFormatterBlock   classFormatterBlock;
<a name="l00483"></a>00483 <span class="preprocessor">#endif</span>
<a name="l00484"></a>00484 <span class="preprocessor"></span>};
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 <span class="comment">// This is a JSONKit private class.</span>
<a name="l00487"></a>00487 <span class="keyword">@interface </span>JKSerializer : NSObject {
<a name="l00488"></a>00488   JKEncodeState *encodeState;
<a name="l00489"></a>00489 }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="preprocessor">#ifdef __BLOCKS__</span>
<a name="l00492"></a>00492 <span class="preprocessor"></span><span class="preprocessor">#define JKSERIALIZER_BLOCKS_PROTO id(^)(id object)</span>
<a name="l00493"></a>00493 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00494"></a>00494 <span class="preprocessor"></span><span class="preprocessor">#define JKSERIALIZER_BLOCKS_PROTO id</span>
<a name="l00495"></a>00495 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00496"></a>00496 <span class="preprocessor"></span>
<a name="l00497"></a>00497 + (id)serializeObject:(<span class="keywordtype">id</span>)object options:(JKSerializeOptionFlags)optionFlags encodeOption:(JKEncodeOptionType)encodeOption block:(JKSERIALIZER_BLOCKS_PROTO)block delegate:(<span class="keywordtype">id</span>)delegate selector:(<span class="keywordtype">SEL</span>)selector error:(NSError **)error;
<a name="l00498"></a>00498 - (id)serializeObject:(<span class="keywordtype">id</span>)object options:(JKSerializeOptionFlags)optionFlags encodeOption:(JKEncodeOptionType)encodeOption block:(JKSERIALIZER_BLOCKS_PROTO)block delegate:(<span class="keywordtype">id</span>)delegate selector:(<span class="keywordtype">SEL</span>)selector error:(NSError **)error;
<a name="l00499"></a>00499 - (void)releaseState;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 <span class="keyword">@end</span>
<a name="l00502"></a>00502 
<a name="l00503"></a>00503 <span class="keyword">struct </span>JKHashTableEntry {
<a name="l00504"></a>00504   NSUInteger keyHash;
<a name="l00505"></a>00505   <span class="keywordtype">id</span> key, object;
<a name="l00506"></a>00506 };
<a name="l00507"></a>00507 
<a name="l00508"></a>00508 
<a name="l00509"></a>00509 <span class="keyword">typedef</span> uint32_t UTF32; <span class="comment">/* at least 32 bits */</span>
<a name="l00510"></a>00510 <span class="keyword">typedef</span> uint16_t UTF16; <span class="comment">/* at least 16 bits */</span>
<a name="l00511"></a>00511 <span class="keyword">typedef</span> uint8_t  UTF8;  <span class="comment">/* typically 8 bits */</span>
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l00514"></a>00514   conversionOK,           <span class="comment">/* conversion successful */</span>
<a name="l00515"></a>00515   sourceExhausted,        <span class="comment">/* partial character in source, but hit end */</span>
<a name="l00516"></a>00516   targetExhausted,        <span class="comment">/* insuff. room in target for conversion */</span>
<a name="l00517"></a>00517   sourceIllegal           <span class="comment">/* source sequence is illegal/malformed */</span>
<a name="l00518"></a>00518 } ConversionResult;
<a name="l00519"></a>00519 
<a name="l00520"></a>00520 <span class="preprocessor">#define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD</span>
<a name="l00521"></a>00521 <span class="preprocessor"></span><span class="preprocessor">#define UNI_MAX_BMP          (UTF32)0x0000FFFF</span>
<a name="l00522"></a>00522 <span class="preprocessor"></span><span class="preprocessor">#define UNI_MAX_UTF16        (UTF32)0x0010FFFF</span>
<a name="l00523"></a>00523 <span class="preprocessor"></span><span class="preprocessor">#define UNI_MAX_UTF32        (UTF32)0x7FFFFFFF</span>
<a name="l00524"></a>00524 <span class="preprocessor"></span><span class="preprocessor">#define UNI_MAX_LEGAL_UTF32  (UTF32)0x0010FFFF</span>
<a name="l00525"></a>00525 <span class="preprocessor"></span><span class="preprocessor">#define UNI_SUR_HIGH_START   (UTF32)0xD800</span>
<a name="l00526"></a>00526 <span class="preprocessor"></span><span class="preprocessor">#define UNI_SUR_HIGH_END     (UTF32)0xDBFF</span>
<a name="l00527"></a>00527 <span class="preprocessor"></span><span class="preprocessor">#define UNI_SUR_LOW_START    (UTF32)0xDC00</span>
<a name="l00528"></a>00528 <span class="preprocessor"></span><span class="preprocessor">#define UNI_SUR_LOW_END      (UTF32)0xDFFF</span>
<a name="l00529"></a>00529 <span class="preprocessor"></span>
<a name="l00530"></a>00530 
<a name="l00531"></a>00531 <span class="preprocessor">#if !defined(JK_FAST_TRAILING_BYTES)</span>
<a name="l00532"></a>00532 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> trailingBytesForUTF8[256] = {
<a name="l00533"></a>00533     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
<a name="l00534"></a>00534     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
<a name="l00535"></a>00535     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
<a name="l00536"></a>00536     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
<a name="l00537"></a>00537     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
<a name="l00538"></a>00538     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
<a name="l00539"></a>00539     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<a name="l00540"></a>00540     2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
<a name="l00541"></a>00541 };
<a name="l00542"></a>00542 <span class="preprocessor">#endif</span>
<a name="l00543"></a>00543 <span class="preprocessor"></span>
<a name="l00544"></a>00544 <span class="keyword">static</span> <span class="keyword">const</span> UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL, 0x03C82080UL, 0xFA082080UL, 0x82082080UL };
<a name="l00545"></a>00545 <span class="keyword">static</span> <span class="keyword">const</span> UTF8  firstByteMark[7]   = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
<a name="l00546"></a>00546 
<a name="l00547"></a>00547 <span class="preprocessor">#define JK_AT_STRING_PTR(x)  (&amp;((x)-&gt;stringBuffer.bytes.ptr[(x)-&gt;atIndex]))</span>
<a name="l00548"></a>00548 <span class="preprocessor"></span><span class="preprocessor">#define JK_END_STRING_PTR(x) (&amp;((x)-&gt;stringBuffer.bytes.ptr[(x)-&gt;stringBuffer.bytes.length]))</span>
<a name="l00549"></a>00549 <span class="preprocessor"></span>
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 <span class="keyword">static</span> JKArray          *_JKArrayCreate(<span class="keywordtype">id</span> *objects, NSUInteger count, BOOL mutableCollection);
<a name="l00552"></a>00552 <span class="keyword">static</span> <span class="keywordtype">void</span>              _JKArrayInsertObjectAtIndex(JKArray *array, <span class="keywordtype">id</span> newObject, NSUInteger objectIndex);
<a name="l00553"></a>00553 <span class="keyword">static</span> <span class="keywordtype">void</span>              _JKArrayReplaceObjectAtIndexWithObject(JKArray *array, NSUInteger objectIndex, <span class="keywordtype">id</span> newObject);
<a name="l00554"></a>00554 <span class="keyword">static</span> <span class="keywordtype">void</span>              _JKArrayRemoveObjectAtIndex(JKArray *array, NSUInteger objectIndex);
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 
<a name="l00557"></a>00557 <span class="keyword">static</span> NSUInteger        _JKDictionaryCapacityForCount(NSUInteger count);
<a name="l00558"></a>00558 <span class="keyword">static</span> JKDictionary     *_JKDictionaryCreate(<span class="keywordtype">id</span> *keys, NSUInteger *keyHashes, <span class="keywordtype">id</span> *objects, NSUInteger count, BOOL mutableCollection);
<a name="l00559"></a>00559 <span class="keyword">static</span> JKHashTableEntry *_JKDictionaryHashEntry(JKDictionary *dictionary);
<a name="l00560"></a>00560 <span class="keyword">static</span> NSUInteger        _JKDictionaryCapacity(JKDictionary *dictionary);
<a name="l00561"></a>00561 <span class="keyword">static</span> <span class="keywordtype">void</span>              _JKDictionaryResizeIfNeccessary(JKDictionary *dictionary);
<a name="l00562"></a>00562 <span class="keyword">static</span> <span class="keywordtype">void</span>              _JKDictionaryRemoveObjectWithEntry(JKDictionary *dictionary, JKHashTableEntry *entry);
<a name="l00563"></a>00563 <span class="keyword">static</span> <span class="keywordtype">void</span>              _JKDictionaryAddObject(JKDictionary *dictionary, NSUInteger keyHash, <span class="keywordtype">id</span> key, <span class="keywordtype">id</span> <span class="keywordtype">object</span>);
<a name="l00564"></a>00564 <span class="keyword">static</span> JKHashTableEntry *_JKDictionaryHashTableEntryForKey(JKDictionary *dictionary, <span class="keywordtype">id</span> aKey);
<a name="l00565"></a>00565 
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 <span class="keyword">static</span> <span class="keywordtype">void</span> _JSONDecoderCleanup(JSONDecoder *decoder);
<a name="l00568"></a>00568 
<a name="l00569"></a>00569 <span class="keyword">static</span> <span class="keywordtype">id</span> _NSStringObjectFromJSONString(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *jsonString, JKParseOptionFlags parseOptionFlags, NSError **error, BOOL mutableCollection);
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 
<a name="l00572"></a>00572 <span class="keyword">static</span> <span class="keywordtype">void</span> jk_managedBuffer_release(JKManagedBuffer *managedBuffer);
<a name="l00573"></a>00573 <span class="keyword">static</span> <span class="keywordtype">void</span> jk_managedBuffer_setToStackBuffer(JKManagedBuffer *managedBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ptr, <span class="keywordtype">size_t</span> length);
<a name="l00574"></a>00574 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *jk_managedBuffer_resize(JKManagedBuffer *managedBuffer, <span class="keywordtype">size_t</span> newSize);
<a name="l00575"></a>00575 <span class="keyword">static</span> <span class="keywordtype">void</span> jk_objectStack_release(JKObjectStack *objectStack);
<a name="l00576"></a>00576 <span class="keyword">static</span> <span class="keywordtype">void</span> jk_objectStack_setToStackBuffer(JKObjectStack *objectStack, <span class="keywordtype">void</span> **objects, <span class="keywordtype">void</span> **keys, CFHashCode *cfHashes, <span class="keywordtype">size_t</span> count);
<a name="l00577"></a>00577 <span class="keyword">static</span> <span class="keywordtype">int</span>  jk_objectStack_resize(JKObjectStack *objectStack, <span class="keywordtype">size_t</span> newCount);
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 <span class="keyword">static</span> <span class="keywordtype">void</span>   jk_error(JKParseState *parseState, <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *format, ...);
<a name="l00580"></a>00580 <span class="keyword">static</span> <span class="keywordtype">int</span>    jk_parse_string(JKParseState *parseState);
<a name="l00581"></a>00581 <span class="keyword">static</span> <span class="keywordtype">int</span>    jk_parse_number(JKParseState *parseState);
<a name="l00582"></a>00582 <span class="keyword">static</span> <span class="keywordtype">size_t</span> jk_parse_is_newline(JKParseState *parseState, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *atCharacterPtr);
<a name="l00583"></a>00583 JK_STATIC_INLINE <span class="keywordtype">int</span> jk_parse_skip_newline(JKParseState *parseState);
<a name="l00584"></a>00584 JK_STATIC_INLINE <span class="keywordtype">void</span> jk_parse_skip_whitespace(JKParseState *parseState);
<a name="l00585"></a>00585 <span class="keyword">static</span> <span class="keywordtype">int</span>    jk_parse_next_token(JKParseState *parseState);
<a name="l00586"></a>00586 <span class="keyword">static</span> <span class="keywordtype">void</span>   jk_error_parse_accept_or3(JKParseState *parseState, <span class="keywordtype">int</span> state, <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *or1String, <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *or2String, <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *or3String);
<a name="l00587"></a>00587 <span class="keyword">static</span> <span class="keywordtype">void</span>  *jk_create_dictionary(JKParseState *parseState, <span class="keywordtype">size_t</span> startingObjectIndex);
<a name="l00588"></a>00588 <span class="keyword">static</span> <span class="keywordtype">void</span>  *jk_parse_dictionary(JKParseState *parseState);
<a name="l00589"></a>00589 <span class="keyword">static</span> <span class="keywordtype">void</span>  *jk_parse_array(JKParseState *parseState);
<a name="l00590"></a>00590 <span class="keyword">static</span> <span class="keywordtype">void</span>  *jk_object_for_token(JKParseState *parseState);
<a name="l00591"></a>00591 <span class="keyword">static</span> <span class="keywordtype">void</span>  *jk_cachedObjects(JKParseState *parseState);
<a name="l00592"></a>00592 JK_STATIC_INLINE <span class="keywordtype">void</span> jk_cache_age(JKParseState *parseState);
<a name="l00593"></a>00593 JK_STATIC_INLINE <span class="keywordtype">void</span> jk_set_parsed_token(JKParseState *parseState, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ptr, <span class="keywordtype">size_t</span> length, JKTokenType type, <span class="keywordtype">size_t</span> advanceBy);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595 
<a name="l00596"></a>00596 <span class="keyword">static</span> <span class="keywordtype">void</span> jk_encode_error(JKEncodeState *encodeState, <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *format, ...);
<a name="l00597"></a>00597 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_encode_printf(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, <span class="keywordtype">size_t</span> startingAtIndex, <span class="keywordtype">id</span> <span class="keywordtype">object</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...);
<a name="l00598"></a>00598 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_encode_write(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, <span class="keywordtype">size_t</span> startingAtIndex, <span class="keywordtype">id</span> <span class="keywordtype">object</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *format);
<a name="l00599"></a>00599 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_encode_writePrettyPrintWhiteSpace(JKEncodeState *encodeState);
<a name="l00600"></a>00600 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_encode_write1slow(JKEncodeState *encodeState, ssize_t depthChange, <span class="keyword">const</span> <span class="keywordtype">char</span> *format);
<a name="l00601"></a>00601 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_encode_write1fast(JKEncodeState *encodeState, ssize_t depthChange JK_UNUSED_ARG, <span class="keyword">const</span> <span class="keywordtype">char</span> *format);
<a name="l00602"></a>00602 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_encode_writen(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, <span class="keywordtype">size_t</span> startingAtIndex, <span class="keywordtype">id</span> <span class="keywordtype">object</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *format, <span class="keywordtype">size_t</span> length);
<a name="l00603"></a>00603 JK_STATIC_INLINE JKHash jk_encode_object_hash(<span class="keywordtype">void</span> *objectPtr);
<a name="l00604"></a>00604 JK_STATIC_INLINE <span class="keywordtype">void</span> jk_encode_updateCache(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, <span class="keywordtype">size_t</span> startingAtIndex, <span class="keywordtype">id</span> <span class="keywordtype">object</span>);
<a name="l00605"></a>00605 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_encode_add_atom_to_buffer(JKEncodeState *encodeState, <span class="keywordtype">void</span> *objectPtr);
<a name="l00606"></a>00606 
<a name="l00607"></a>00607 <span class="preprocessor">#define jk_encode_write1(es, dc, f)  (JK_EXPECT_F(_jk_encode_prettyPrint) ? jk_encode_write1slow(es, dc, f) : jk_encode_write1fast(es, dc, f))</span>
<a name="l00608"></a>00608 <span class="preprocessor"></span>
<a name="l00609"></a>00609 
<a name="l00610"></a>00610 JK_STATIC_INLINE <span class="keywordtype">size_t</span> jk_min(<span class="keywordtype">size_t</span> a, <span class="keywordtype">size_t</span> b);
<a name="l00611"></a>00611 JK_STATIC_INLINE <span class="keywordtype">size_t</span> jk_max(<span class="keywordtype">size_t</span> a, <span class="keywordtype">size_t</span> b);
<a name="l00612"></a>00612 JK_STATIC_INLINE JKHash calculateHash(JKHash currentHash, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c);
<a name="l00613"></a>00613 
<a name="l00614"></a>00614 <span class="comment">// JSONKit v1.4 used both a JKArray : NSArray and JKMutableArray : NSMutableArray, and the same for the dictionary collection type.</span>
<a name="l00615"></a>00615 <span class="comment">// However, Louis Gerbarg (via cocoa-dev) pointed out that Cocoa / Core Foundation actually implements only a single class that inherits from the </span>
<a name="l00616"></a>00616 <span class="comment">// mutable version, and keeps an ivar bit for whether or not that instance is mutable.  This means that the immutable versions of the collection</span>
<a name="l00617"></a>00617 <span class="comment">// classes receive the mutating methods, but this is handled by having those methods throw an exception when the ivar bit is set to immutable.</span>
<a name="l00618"></a>00618 <span class="comment">// We adopt the same strategy here.  It&#39;s both cleaner and gets rid of the method swizzling hackery used in JSONKit v1.4.</span>
<a name="l00619"></a>00619 
<a name="l00620"></a>00620 
<a name="l00621"></a>00621 <span class="comment">// This is a workaround for issue #23 https://github.com/johnezang/JSONKit/pull/23</span>
<a name="l00622"></a>00622 <span class="comment">// Basically, there seem to be a problem with using +load in static libraries on iOS.  However, __attribute__ ((constructor)) does work correctly.</span>
<a name="l00623"></a>00623 <span class="comment">// Since we do not require anything &quot;special&quot; that +load provides, and we can accomplish the same thing using __attribute__ ((constructor)), the +load logic was moved here.</span>
<a name="l00624"></a>00624 
<a name="l00625"></a>00625 <span class="keyword">static</span> Class                               _JKArrayClass                           = NULL;
<a name="l00626"></a>00626 <span class="keyword">static</span> <span class="keywordtype">size_t</span>                              _JKArrayInstanceSize                    = 0UL;
<a name="l00627"></a>00627 <span class="keyword">static</span> Class                               _JKDictionaryClass                      = NULL;
<a name="l00628"></a>00628 <span class="keyword">static</span> <span class="keywordtype">size_t</span>                              _JKDictionaryInstanceSize               = 0UL;
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 <span class="comment">// For JSONDecoder...</span>
<a name="l00631"></a>00631 <span class="keyword">static</span> Class                               _jk_NSNumberClass                       = NULL;
<a name="l00632"></a>00632 <span class="keyword">static</span> NSNumberAllocImp                    _jk_NSNumberAllocImp                    = NULL;
<a name="l00633"></a>00633 <span class="keyword">static</span> NSNumberInitWithUnsignedLongLongImp _jk_NSNumberInitWithUnsignedLongLongImp = NULL;
<a name="l00634"></a>00634 
<a name="l00635"></a>00635 <span class="keyword">extern</span> <span class="keywordtype">void</span> jk_collectionClassLoadTimeInitialization(<span class="keywordtype">void</span>) __attribute__ ((constructor));
<a name="l00636"></a>00636 
<a name="l00637"></a>00637 <span class="keywordtype">void</span> jk_collectionClassLoadTimeInitialization(<span class="keywordtype">void</span>) {
<a name="l00638"></a>00638   NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; <span class="comment">// Though technically not required, the run time environment at load time initialization may be less than ideal.</span>
<a name="l00639"></a>00639   
<a name="l00640"></a>00640   _JKArrayClass             = objc_getClass(<span class="stringliteral">&quot;JKArray&quot;</span>);
<a name="l00641"></a>00641   _JKArrayInstanceSize      = jk_max(16UL, class_getInstanceSize(_JKArrayClass));
<a name="l00642"></a>00642   
<a name="l00643"></a>00643   _JKDictionaryClass        = objc_getClass(<span class="stringliteral">&quot;JKDictionary&quot;</span>);
<a name="l00644"></a>00644   _JKDictionaryInstanceSize = jk_max(16UL, class_getInstanceSize(_JKDictionaryClass));
<a name="l00645"></a>00645   
<a name="l00646"></a>00646   <span class="comment">// For JSONDecoder...</span>
<a name="l00647"></a>00647   _jk_NSNumberClass = [NSNumber class];
<a name="l00648"></a>00648   _jk_NSNumberAllocImp = (NSNumberAllocImp)[NSNumber methodForSelector:<span class="keyword">@selector</span>(alloc)];
<a name="l00649"></a>00649   
<a name="l00650"></a>00650   <span class="comment">// Hacktacular.  Need to do it this way due to the nature of class clusters.</span>
<a name="l00651"></a>00651   <span class="keywordtype">id</span> temp_NSNumber = [NSNumber alloc];
<a name="l00652"></a>00652   _jk_NSNumberInitWithUnsignedLongLongImp = (NSNumberInitWithUnsignedLongLongImp)[temp_NSNumber methodForSelector:<span class="keyword">@selector</span>(initWithUnsignedLongLong:)];
<a name="l00653"></a>00653   [[temp_NSNumber init] release];
<a name="l00654"></a>00654   temp_NSNumber = NULL;
<a name="l00655"></a>00655   
<a name="l00656"></a>00656   [pool release]; pool = NULL;
<a name="l00657"></a>00657 }
<a name="l00658"></a>00658 
<a name="l00659"></a>00659 
<a name="l00660"></a>00660 <span class="preprocessor">#pragma mark -</span>
<a name="l00661"></a>00661 <span class="preprocessor"></span><span class="keyword">@interface </span>JKArray : NSMutableArray &lt;NSCopying, NSMutableCopying, NSFastEnumeration&gt; {
<a name="l00662"></a>00662   <span class="keywordtype">id</span>         *objects;
<a name="l00663"></a>00663   NSUInteger  count, capacity, mutations;
<a name="l00664"></a>00664 }
<a name="l00665"></a>00665 <span class="keyword">@end</span>
<a name="l00666"></a>00666 
<a name="l00667"></a>00667 <span class="keyword">@implementation </span>JKArray
<a name="l00668"></a>00668 
<a name="l00669"></a>00669 + (id)allocWithZone:(NSZone *)zone
<a name="l00670"></a>00670 {
<a name="l00671"></a>00671 <span class="preprocessor">#pragma unused(zone)</span>
<a name="l00672"></a>00672 <span class="preprocessor"></span>  [NSException raise:NSInvalidArgumentException format:@&quot;*** - [%@ %@]: The %@ class is private to JSONKit and should not be used in this fashion.&quot;, NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd), NSStringFromClass([<span class="keyword">self</span> class])];
<a name="l00673"></a>00673   <span class="keywordflow">return</span>(NULL);
<a name="l00674"></a>00674 }
<a name="l00675"></a>00675 
<a name="l00676"></a>00676 <span class="keyword">static</span> JKArray *_JKArrayCreate(<span class="keywordtype">id</span> *objects, NSUInteger count, BOOL mutableCollection) {
<a name="l00677"></a>00677   NSCParameterAssert((objects != NULL) &amp;&amp; (_JKArrayClass != NULL) &amp;&amp; (_JKArrayInstanceSize &gt; 0UL));
<a name="l00678"></a>00678   JKArray *array = NULL;
<a name="l00679"></a>00679   <span class="keywordflow">if</span>(JK_EXPECT_T((array = (JKArray *)calloc(1UL, _JKArrayInstanceSize)) != NULL)) { <span class="comment">// Directly allocate the JKArray instance via calloc.</span>
<a name="l00680"></a>00680     array-&gt;isa      = _JKArrayClass;
<a name="l00681"></a>00681     <span class="keywordflow">if</span>((array = [array init]) == NULL) { <span class="keywordflow">return</span>(NULL); }
<a name="l00682"></a>00682     array-&gt;capacity = count;
<a name="l00683"></a>00683     array-&gt;count    = count;
<a name="l00684"></a>00684     <span class="keywordflow">if</span>(JK_EXPECT_F((array-&gt;objects = (<span class="keywordtype">id</span> *)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">id</span>) * array-&gt;capacity)) == NULL)) { [array autorelease]; <span class="keywordflow">return</span>(NULL); }
<a name="l00685"></a>00685     memcpy(array-&gt;objects, objects, array-&gt;capacity * <span class="keyword">sizeof</span>(<span class="keywordtype">id</span>));
<a name="l00686"></a>00686     array-&gt;mutations = (mutableCollection == NO) ? 0UL : 1UL;
<a name="l00687"></a>00687   }
<a name="l00688"></a>00688   <span class="keywordflow">return</span>(array);
<a name="l00689"></a>00689 }
<a name="l00690"></a>00690 
<a name="l00691"></a>00691 <span class="comment">// Note: The caller is responsible for -retaining the object that is to be added.</span>
<a name="l00692"></a>00692 <span class="keyword">static</span> <span class="keywordtype">void</span> _JKArrayInsertObjectAtIndex(JKArray *array, <span class="keywordtype">id</span> newObject, NSUInteger objectIndex) {
<a name="l00693"></a>00693   NSCParameterAssert((array != NULL) &amp;&amp; (array-&gt;objects != NULL) &amp;&amp; (array-&gt;count &lt;= array-&gt;capacity) &amp;&amp; (objectIndex &lt;= array-&gt;count) &amp;&amp; (newObject != NULL));
<a name="l00694"></a>00694   <span class="keywordflow">if</span>(!((array != NULL) &amp;&amp; (array-&gt;objects != NULL) &amp;&amp; (objectIndex &lt;= array-&gt;count) &amp;&amp; (newObject != NULL))) { [newObject autorelease]; <span class="keywordflow">return</span>; }
<a name="l00695"></a>00695   array-&gt;count++;
<a name="l00696"></a>00696   <span class="keywordflow">if</span>(array-&gt;count &gt;= array-&gt;capacity) {
<a name="l00697"></a>00697     array-&gt;capacity += 16UL;
<a name="l00698"></a>00698     <span class="keywordtype">id</span> *newObjects = NULL;
<a name="l00699"></a>00699     <span class="keywordflow">if</span>((newObjects = (<span class="keywordtype">id</span> *)realloc(array-&gt;objects, <span class="keyword">sizeof</span>(<span class="keywordtype">id</span>) * array-&gt;capacity)) == NULL) { [NSException raise:NSMallocException format:@&quot;Unable to resize objects array.&quot;]; }
<a name="l00700"></a>00700     array-&gt;objects = newObjects;
<a name="l00701"></a>00701     memset(&amp;array-&gt;objects[array-&gt;count], 0, <span class="keyword">sizeof</span>(<span class="keywordtype">id</span>) * (array-&gt;capacity - array-&gt;count));
<a name="l00702"></a>00702   }
<a name="l00703"></a>00703   <span class="keywordflow">if</span>((objectIndex + 1UL) &lt; array-&gt;count) { memmove(&amp;array-&gt;objects[objectIndex + 1UL], &amp;array-&gt;objects[objectIndex], <span class="keyword">sizeof</span>(<span class="keywordtype">id</span>) * ((array-&gt;count - 1UL) - objectIndex)); array-&gt;objects[objectIndex] = NULL; }
<a name="l00704"></a>00704   array-&gt;objects[objectIndex] = newObject;
<a name="l00705"></a>00705 }
<a name="l00706"></a>00706 
<a name="l00707"></a>00707 <span class="comment">// Note: The caller is responsible for -retaining the object that is to be added.</span>
<a name="l00708"></a>00708 <span class="keyword">static</span> <span class="keywordtype">void</span> _JKArrayReplaceObjectAtIndexWithObject(JKArray *array, NSUInteger objectIndex, <span class="keywordtype">id</span> newObject) {
<a name="l00709"></a>00709   NSCParameterAssert((array != NULL) &amp;&amp; (array-&gt;objects != NULL) &amp;&amp; (array-&gt;count &lt;= array-&gt;capacity) &amp;&amp; (objectIndex &lt; array-&gt;count) &amp;&amp; (array-&gt;objects[objectIndex] != NULL) &amp;&amp; (newObject != NULL));
<a name="l00710"></a>00710   <span class="keywordflow">if</span>(!((array != NULL) &amp;&amp; (array-&gt;objects != NULL) &amp;&amp; (objectIndex &lt; array-&gt;count) &amp;&amp; (array-&gt;objects[objectIndex] != NULL) &amp;&amp; (newObject != NULL))) { [newObject autorelease]; <span class="keywordflow">return</span>; }
<a name="l00711"></a>00711   CFRelease(array-&gt;objects[objectIndex]);
<a name="l00712"></a>00712   array-&gt;objects[objectIndex] = NULL;
<a name="l00713"></a>00713   array-&gt;objects[objectIndex] = newObject;
<a name="l00714"></a>00714 }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716 <span class="keyword">static</span> <span class="keywordtype">void</span> _JKArrayRemoveObjectAtIndex(JKArray *array, NSUInteger objectIndex) {
<a name="l00717"></a>00717   NSCParameterAssert((array != NULL) &amp;&amp; (array-&gt;objects != NULL) &amp;&amp; (array-&gt;count &lt;= array-&gt;capacity) &amp;&amp; (objectIndex &lt; array-&gt;count) &amp;&amp; (array-&gt;objects[objectIndex] != NULL));
<a name="l00718"></a>00718   <span class="keywordflow">if</span>(!((array != NULL) &amp;&amp; (array-&gt;objects != NULL) &amp;&amp; (objectIndex &lt; array-&gt;count) &amp;&amp; (array-&gt;objects[objectIndex] != NULL))) { <span class="keywordflow">return</span>; }
<a name="l00719"></a>00719   CFRelease(array-&gt;objects[objectIndex]);
<a name="l00720"></a>00720   array-&gt;objects[objectIndex] = NULL;
<a name="l00721"></a>00721   <span class="keywordflow">if</span>((objectIndex + 1UL) &lt; array-&gt;count) { memmove(&amp;array-&gt;objects[objectIndex], &amp;array-&gt;objects[objectIndex + 1UL], <span class="keyword">sizeof</span>(<span class="keywordtype">id</span>) * ((array-&gt;count - 1UL) - objectIndex)); array-&gt;objects[array-&gt;count] = NULL; }
<a name="l00722"></a>00722   array-&gt;count--;
<a name="l00723"></a>00723 }
<a name="l00724"></a>00724 
<a name="l00725"></a>00725 - (void)dealloc
<a name="l00726"></a>00726 {
<a name="l00727"></a>00727   <span class="keywordflow">if</span>(JK_EXPECT_T(objects != NULL)) {
<a name="l00728"></a>00728     NSUInteger atObject = 0UL;
<a name="l00729"></a>00729     <span class="keywordflow">for</span>(atObject = 0UL; atObject &lt; count; atObject++) { <span class="keywordflow">if</span>(JK_EXPECT_T(objects[atObject] != NULL)) { CFRelease(objects[atObject]); objects[atObject] = NULL; } }
<a name="l00730"></a>00730     free(objects); objects = NULL;
<a name="l00731"></a>00731   }
<a name="l00732"></a>00732   
<a name="l00733"></a>00733   [<span class="keyword">super</span> dealloc];
<a name="l00734"></a>00734 }
<a name="l00735"></a>00735 
<a name="l00736"></a>00736 - (NSUInteger)count
<a name="l00737"></a>00737 {
<a name="l00738"></a>00738   NSParameterAssert((objects != NULL) &amp;&amp; (count &lt;= capacity));
<a name="l00739"></a>00739   <span class="keywordflow">return</span>(count);
<a name="l00740"></a>00740 }
<a name="l00741"></a>00741 
<a name="l00742"></a>00742 - (void)getObjects:(<span class="keywordtype">id</span> *)objectsPtr range:(NSRange)range
<a name="l00743"></a>00743 {
<a name="l00744"></a>00744   NSParameterAssert((objects != NULL) &amp;&amp; (count &lt;= capacity));
<a name="l00745"></a>00745   <span class="keywordflow">if</span>((objectsPtr     == NULL)  &amp;&amp; (NSMaxRange(range) &gt; 0UL))   { [NSException raise:NSRangeException format:@&quot;*** -[%@ %@]: pointer to objects array is NULL but range length is %lu&quot;, NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd), NSMaxRange(range)];        }
<a name="l00746"></a>00746   <span class="keywordflow">if</span>((range.location &gt;  count) || (NSMaxRange(range) &gt; count)) { [NSException raise:NSRangeException format:@&quot;*** -[%@ %@]: index (%lu) beyond bounds (%lu)&quot;,                          NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd), NSMaxRange(range), count]; }
<a name="l00747"></a>00747   memcpy(objectsPtr, objects + range.location, range.length * <span class="keyword">sizeof</span>(<span class="keywordtype">id</span>));
<a name="l00748"></a>00748 }
<a name="l00749"></a>00749 
<a name="l00750"></a>00750 - (id)objectAtIndex:(NSUInteger)objectIndex
<a name="l00751"></a>00751 {
<a name="l00752"></a>00752   <span class="keywordflow">if</span>(objectIndex &gt;= count) { [NSException raise:NSRangeException format:@&quot;*** -[%@ %@]: index (%lu) beyond bounds (%lu)&quot;, NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd), objectIndex, count]; }
<a name="l00753"></a>00753   NSParameterAssert((objects != NULL) &amp;&amp; (count &lt;= capacity) &amp;&amp; (objects[objectIndex] != NULL));
<a name="l00754"></a>00754   <span class="keywordflow">return</span>(objects[objectIndex]);
<a name="l00755"></a>00755 }
<a name="l00756"></a>00756 
<a name="l00757"></a>00757 - (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(<span class="keywordtype">id</span> *)stackbuf count:(NSUInteger)len
<a name="l00758"></a>00758 {
<a name="l00759"></a>00759   NSParameterAssert((state != NULL) &amp;&amp; (stackbuf != NULL) &amp;&amp; (len &gt; 0UL) &amp;&amp; (objects != NULL) &amp;&amp; (count &lt;= capacity));
<a name="l00760"></a>00760   <span class="keywordflow">if</span>(JK_EXPECT_F(state-&gt;state == 0UL))   { state-&gt;mutationsPtr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;mutations; state-&gt;itemsPtr = stackbuf; }
<a name="l00761"></a>00761   <span class="keywordflow">if</span>(JK_EXPECT_F(state-&gt;state &gt;= count)) { <span class="keywordflow">return</span>(0UL); }
<a name="l00762"></a>00762   
<a name="l00763"></a>00763   NSUInteger enumeratedCount  = 0UL;
<a name="l00764"></a>00764   <span class="keywordflow">while</span>(JK_EXPECT_T(enumeratedCount &lt; len) &amp;&amp; JK_EXPECT_T(state-&gt;state &lt; count)) { NSParameterAssert(objects[state-&gt;state] != NULL); stackbuf[enumeratedCount++] = objects[state-&gt;state++]; }
<a name="l00765"></a>00765   
<a name="l00766"></a>00766   <span class="keywordflow">return</span>(enumeratedCount);
<a name="l00767"></a>00767 }
<a name="l00768"></a>00768 
<a name="l00769"></a>00769 - (void)insertObject:(<span class="keywordtype">id</span>)anObject atIndex:(NSUInteger)objectIndex
<a name="l00770"></a>00770 {
<a name="l00771"></a>00771   <span class="keywordflow">if</span>(mutations   == 0UL)   { [NSException raise:NSInternalInconsistencyException format:@&quot;*** -[%@ %@]: mutating method sent to immutable object&quot;, NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd)]; }
<a name="l00772"></a>00772   <span class="keywordflow">if</span>(anObject    == NULL)  { [NSException raise:NSInvalidArgumentException       format:@&quot;*** -[%@ %@]: attempt to insert nil&quot;,                    NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd)]; }
<a name="l00773"></a>00773   <span class="keywordflow">if</span>(objectIndex &gt;  count) { [NSException raise:NSRangeException                 format:@&quot;*** -[%@ %@]: index (%lu) beyond bounds (%lu)&quot;,          NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd), objectIndex, count + 1UL]; }
<a name="l00774"></a>00774 <span class="preprocessor">#ifdef __clang_analyzer__</span>
<a name="l00775"></a>00775 <span class="preprocessor"></span>  [anObject retain]; <span class="comment">// Stupid clang analyzer...  Issue #19.</span>
<a name="l00776"></a>00776 <span class="preprocessor">#else</span>
<a name="l00777"></a>00777 <span class="preprocessor"></span>  anObject = [anObject retain];
<a name="l00778"></a>00778 <span class="preprocessor">#endif</span>
<a name="l00779"></a>00779 <span class="preprocessor"></span>  _JKArrayInsertObjectAtIndex(<span class="keyword">self</span>, anObject, objectIndex);
<a name="l00780"></a>00780   mutations = (mutations == NSUIntegerMax) ? 1UL : mutations + 1UL;
<a name="l00781"></a>00781 }
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 - (void)removeObjectAtIndex:(NSUInteger)objectIndex
<a name="l00784"></a>00784 {
<a name="l00785"></a>00785   <span class="keywordflow">if</span>(mutations   == 0UL)   { [NSException raise:NSInternalInconsistencyException format:@&quot;*** -[%@ %@]: mutating method sent to immutable object&quot;, NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd)]; }
<a name="l00786"></a>00786   <span class="keywordflow">if</span>(objectIndex &gt;= count) { [NSException raise:NSRangeException                 format:@&quot;*** -[%@ %@]: index (%lu) beyond bounds (%lu)&quot;,          NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd), objectIndex, count]; }
<a name="l00787"></a>00787   _JKArrayRemoveObjectAtIndex(<span class="keyword">self</span>, objectIndex);
<a name="l00788"></a>00788   mutations = (mutations == NSUIntegerMax) ? 1UL : mutations + 1UL;
<a name="l00789"></a>00789 }
<a name="l00790"></a>00790 
<a name="l00791"></a>00791 - (void)replaceObjectAtIndex:(NSUInteger)objectIndex withObject:(<span class="keywordtype">id</span>)anObject
<a name="l00792"></a>00792 {
<a name="l00793"></a>00793   <span class="keywordflow">if</span>(mutations   == 0UL)   { [NSException raise:NSInternalInconsistencyException format:@&quot;*** -[%@ %@]: mutating method sent to immutable object&quot;, NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd)]; }
<a name="l00794"></a>00794   <span class="keywordflow">if</span>(anObject    == NULL)  { [NSException raise:NSInvalidArgumentException       format:@&quot;*** -[%@ %@]: attempt to insert nil&quot;,                    NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd)]; }
<a name="l00795"></a>00795   <span class="keywordflow">if</span>(objectIndex &gt;= count) { [NSException raise:NSRangeException                 format:@&quot;*** -[%@ %@]: index (%lu) beyond bounds (%lu)&quot;,          NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd), objectIndex, count]; }
<a name="l00796"></a>00796 <span class="preprocessor">#ifdef __clang_analyzer__</span>
<a name="l00797"></a>00797 <span class="preprocessor"></span>  [anObject retain]; <span class="comment">// Stupid clang analyzer...  Issue #19.</span>
<a name="l00798"></a>00798 <span class="preprocessor">#else</span>
<a name="l00799"></a>00799 <span class="preprocessor"></span>  anObject = [anObject retain];
<a name="l00800"></a>00800 <span class="preprocessor">#endif</span>
<a name="l00801"></a>00801 <span class="preprocessor"></span>  _JKArrayReplaceObjectAtIndexWithObject(<span class="keyword">self</span>, objectIndex, anObject);
<a name="l00802"></a>00802   mutations = (mutations == NSUIntegerMax) ? 1UL : mutations + 1UL;
<a name="l00803"></a>00803 }
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 - (id)copyWithZone:(NSZone *)zone
<a name="l00806"></a>00806 {
<a name="l00807"></a>00807   NSParameterAssert((objects != NULL) &amp;&amp; (count &lt;= capacity));
<a name="l00808"></a>00808   <span class="keywordflow">return</span>((mutations == 0UL) ? [<span class="keyword">self</span> retain] : [[NSArray allocWithZone:zone] initWithObjects:objects count:count]);
<a name="l00809"></a>00809 }
<a name="l00810"></a>00810 
<a name="l00811"></a>00811 - (id)mutableCopyWithZone:(NSZone *)zone
<a name="l00812"></a>00812 {
<a name="l00813"></a>00813   NSParameterAssert((objects != NULL) &amp;&amp; (count &lt;= capacity));
<a name="l00814"></a>00814   <span class="keywordflow">return</span>([[NSMutableArray allocWithZone:zone] initWithObjects:objects count:count]);
<a name="l00815"></a>00815 }
<a name="l00816"></a>00816 
<a name="l00817"></a>00817 <span class="keyword">@end</span>
<a name="l00818"></a>00818 
<a name="l00819"></a>00819 
<a name="l00820"></a>00820 <span class="preprocessor">#pragma mark -</span>
<a name="l00821"></a>00821 <span class="preprocessor"></span><span class="keyword">@interface </span>JKDictionaryEnumerator : NSEnumerator {
<a name="l00822"></a>00822   <span class="keywordtype">id</span>         collection;
<a name="l00823"></a>00823   NSUInteger nextObject;
<a name="l00824"></a>00824 }
<a name="l00825"></a>00825 
<a name="l00826"></a>00826 - (id)initWithJKDictionary:(JKDictionary *)initDictionary;
<a name="l00827"></a>00827 - (NSArray *)allObjects;
<a name="l00828"></a>00828 - (id)nextObject;
<a name="l00829"></a>00829 
<a name="l00830"></a>00830 <span class="keyword">@end</span>
<a name="l00831"></a>00831 
<a name="l00832"></a>00832 <span class="keyword">@implementation </span>JKDictionaryEnumerator
<a name="l00833"></a>00833 
<a name="l00834"></a>00834 - (id)initWithJKDictionary:(JKDictionary *)initDictionary
<a name="l00835"></a>00835 {
<a name="l00836"></a>00836   NSParameterAssert(initDictionary != NULL);
<a name="l00837"></a>00837   <span class="keywordflow">if</span>((<span class="keyword">self</span> = [super init]) == NULL) { <span class="keywordflow">return</span>(NULL); }
<a name="l00838"></a>00838   <span class="keywordflow">if</span>((collection = (<span class="keywordtype">id</span>)CFRetain(initDictionary)) == NULL) { [<span class="keyword">self</span> autorelease]; <span class="keywordflow">return</span>(NULL); }
<a name="l00839"></a>00839   <span class="keywordflow">return</span>(<span class="keyword">self</span>);
<a name="l00840"></a>00840 }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842 - (void)dealloc
<a name="l00843"></a>00843 {
<a name="l00844"></a>00844   <span class="keywordflow">if</span>(collection != NULL) { CFRelease(collection); collection = NULL; }
<a name="l00845"></a>00845   [<span class="keyword">super</span> dealloc];
<a name="l00846"></a>00846 }
<a name="l00847"></a>00847 
<a name="l00848"></a>00848 - (NSArray *)allObjects
<a name="l00849"></a>00849 {
<a name="l00850"></a>00850   NSParameterAssert(collection != NULL);
<a name="l00851"></a>00851   NSUInteger count = [collection count], atObject = 0UL;
<a name="l00852"></a>00852   <span class="keywordtype">id</span>         objects[count];
<a name="l00853"></a>00853 
<a name="l00854"></a>00854   <span class="keywordflow">while</span>((objects[atObject] = [<span class="keyword">self</span> nextObject]) != NULL) { NSParameterAssert(atObject &lt; count); atObject++; }
<a name="l00855"></a>00855 
<a name="l00856"></a>00856   <span class="keywordflow">return</span>([NSArray arrayWithObjects:objects count:atObject]);
<a name="l00857"></a>00857 }
<a name="l00858"></a>00858 
<a name="l00859"></a>00859 - (id)nextObject
<a name="l00860"></a>00860 {
<a name="l00861"></a>00861   NSParameterAssert((collection != NULL) &amp;&amp; (_JKDictionaryHashEntry(collection) != NULL));
<a name="l00862"></a>00862   JKHashTableEntry *entry        = _JKDictionaryHashEntry(collection);
<a name="l00863"></a>00863   NSUInteger        capacity     = _JKDictionaryCapacity(collection);
<a name="l00864"></a>00864   <span class="keywordtype">id</span>                returnObject = NULL;
<a name="l00865"></a>00865 
<a name="l00866"></a>00866   <span class="keywordflow">if</span>(entry != NULL) { <span class="keywordflow">while</span>((nextObject &lt; capacity) &amp;&amp; ((returnObject = entry[nextObject++].key) == NULL)) { <span class="comment">/* ... */</span> } }
<a name="l00867"></a>00867   
<a name="l00868"></a>00868   <span class="keywordflow">return</span>(returnObject);
<a name="l00869"></a>00869 }
<a name="l00870"></a>00870 
<a name="l00871"></a>00871 <span class="keyword">@end</span>
<a name="l00872"></a>00872 
<a name="l00873"></a>00873 <span class="preprocessor">#pragma mark -</span>
<a name="l00874"></a>00874 <span class="preprocessor"></span><span class="keyword">@interface </span>JKDictionary : NSMutableDictionary &lt;NSCopying, NSMutableCopying, NSFastEnumeration&gt; {
<a name="l00875"></a>00875   NSUInteger count, capacity, mutations;
<a name="l00876"></a>00876   JKHashTableEntry *entry;
<a name="l00877"></a>00877 }
<a name="l00878"></a>00878 <span class="keyword">@end</span>
<a name="l00879"></a>00879 
<a name="l00880"></a>00880 <span class="keyword">@implementation </span>JKDictionary
<a name="l00881"></a>00881 
<a name="l00882"></a>00882 + (id)allocWithZone:(NSZone *)zone
<a name="l00883"></a>00883 {
<a name="l00884"></a>00884 <span class="preprocessor">#pragma unused(zone)</span>
<a name="l00885"></a>00885 <span class="preprocessor"></span>  [NSException raise:NSInvalidArgumentException format:@&quot;*** - [%@ %@]: The %@ class is private to JSONKit and should not be used in this fashion.&quot;, NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd), NSStringFromClass([<span class="keyword">self</span> class])];
<a name="l00886"></a>00886   <span class="keywordflow">return</span>(NULL);
<a name="l00887"></a>00887 }
<a name="l00888"></a>00888 
<a name="l00889"></a>00889 <span class="comment">// These values are taken from Core Foundation CF-550 CFBasicHash.m.  As a bonus, they align very well with our JKHashTableEntry struct too.</span>
<a name="l00890"></a>00890 <span class="keyword">static</span> <span class="keyword">const</span> NSUInteger jk_dictionaryCapacities[] = {
<a name="l00891"></a>00891   0UL, 3UL, 7UL, 13UL, 23UL, 41UL, 71UL, 127UL, 191UL, 251UL, 383UL, 631UL, 1087UL, 1723UL,
<a name="l00892"></a>00892   2803UL, 4523UL, 7351UL, 11959UL, 19447UL, 31231UL, 50683UL, 81919UL, 132607UL,
<a name="l00893"></a>00893   214519UL, 346607UL, 561109UL, 907759UL, 1468927UL, 2376191UL, 3845119UL,
<a name="l00894"></a>00894   6221311UL, 10066421UL, 16287743UL, 26354171UL, 42641881UL, 68996069UL,
<a name="l00895"></a>00895   111638519UL, 180634607UL, 292272623UL, 472907251UL
<a name="l00896"></a>00896 };
<a name="l00897"></a>00897 
<a name="l00898"></a>00898 <span class="keyword">static</span> NSUInteger _JKDictionaryCapacityForCount(NSUInteger count) {
<a name="l00899"></a>00899   NSUInteger bottom = 0UL, top = <span class="keyword">sizeof</span>(jk_dictionaryCapacities) / <span class="keyword">sizeof</span>(NSUInteger), mid = 0UL, tableSize = lround(floor((count) * 1.33));
<a name="l00900"></a>00900   <span class="keywordflow">while</span>(top &gt; bottom) { mid = (top + bottom) / 2UL; <span class="keywordflow">if</span>(jk_dictionaryCapacities[mid] &lt; tableSize) { bottom = mid + 1UL; } <span class="keywordflow">else</span> { top = mid; } }
<a name="l00901"></a>00901   <span class="keywordflow">return</span>(jk_dictionaryCapacities[bottom]);
<a name="l00902"></a>00902 }
<a name="l00903"></a>00903 
<a name="l00904"></a>00904 <span class="keyword">static</span> <span class="keywordtype">void</span> _JKDictionaryResizeIfNeccessary(JKDictionary *dictionary) {
<a name="l00905"></a>00905   NSCParameterAssert((dictionary != NULL) &amp;&amp; (dictionary-&gt;entry != NULL) &amp;&amp; (dictionary-&gt;count &lt;= dictionary-&gt;capacity));
<a name="l00906"></a>00906 
<a name="l00907"></a>00907   NSUInteger capacityForCount = 0UL;
<a name="l00908"></a>00908   <span class="keywordflow">if</span>(dictionary-&gt;capacity &lt; (capacityForCount = _JKDictionaryCapacityForCount(dictionary-&gt;count + 1UL))) { <span class="comment">// resize</span>
<a name="l00909"></a>00909     NSUInteger        oldCapacity = dictionary-&gt;capacity;
<a name="l00910"></a>00910 <span class="preprocessor">#ifndef NS_BLOCK_ASSERTIONS</span>
<a name="l00911"></a>00911 <span class="preprocessor"></span>    NSUInteger oldCount = dictionary-&gt;count;
<a name="l00912"></a>00912 <span class="preprocessor">#endif</span>
<a name="l00913"></a>00913 <span class="preprocessor"></span>    JKHashTableEntry *oldEntry    = dictionary-&gt;entry;
<a name="l00914"></a>00914     <span class="keywordflow">if</span>(JK_EXPECT_F((dictionary-&gt;entry = (JKHashTableEntry *)calloc(1UL, <span class="keyword">sizeof</span>(JKHashTableEntry) * capacityForCount)) == NULL)) { [NSException raise:NSMallocException format:@&quot;Unable to allocate memory for hash table.&quot;]; }
<a name="l00915"></a>00915     dictionary-&gt;capacity = capacityForCount;
<a name="l00916"></a>00916     dictionary-&gt;count    = 0UL;
<a name="l00917"></a>00917     
<a name="l00918"></a>00918     NSUInteger idx = 0UL;
<a name="l00919"></a>00919     <span class="keywordflow">for</span>(idx = 0UL; idx &lt; oldCapacity; idx++) { <span class="keywordflow">if</span>(oldEntry[idx].key != NULL) { _JKDictionaryAddObject(dictionary, oldEntry[idx].keyHash, oldEntry[idx].key, oldEntry[idx].<span class="keywordtype">object</span>); oldEntry[idx].keyHash = 0UL; oldEntry[idx].key = NULL; oldEntry[idx].object = NULL; } }
<a name="l00920"></a>00920     NSCParameterAssert((oldCount == dictionary-&gt;count));
<a name="l00921"></a>00921     free(oldEntry); oldEntry = NULL;
<a name="l00922"></a>00922   }
<a name="l00923"></a>00923 }
<a name="l00924"></a>00924 
<a name="l00925"></a>00925 <span class="keyword">static</span> JKDictionary *_JKDictionaryCreate(<span class="keywordtype">id</span> *keys, NSUInteger *keyHashes, <span class="keywordtype">id</span> *objects, NSUInteger count, BOOL mutableCollection) {
<a name="l00926"></a>00926   NSCParameterAssert((keys != NULL) &amp;&amp; (keyHashes != NULL) &amp;&amp; (objects != NULL) &amp;&amp; (_JKDictionaryClass != NULL) &amp;&amp; (_JKDictionaryInstanceSize &gt; 0UL));
<a name="l00927"></a>00927   JKDictionary *dictionary = NULL;
<a name="l00928"></a>00928   <span class="keywordflow">if</span>(JK_EXPECT_T((dictionary = (JKDictionary *)calloc(1UL, _JKDictionaryInstanceSize)) != NULL)) { <span class="comment">// Directly allocate the JKDictionary instance via calloc.</span>
<a name="l00929"></a>00929     dictionary-&gt;isa      = _JKDictionaryClass;
<a name="l00930"></a>00930     <span class="keywordflow">if</span>((dictionary = [dictionary init]) == NULL) { <span class="keywordflow">return</span>(NULL); }
<a name="l00931"></a>00931     dictionary-&gt;capacity = _JKDictionaryCapacityForCount(count);
<a name="l00932"></a>00932     dictionary-&gt;count    = 0UL;
<a name="l00933"></a>00933     
<a name="l00934"></a>00934     <span class="keywordflow">if</span>(JK_EXPECT_F((dictionary-&gt;entry = (JKHashTableEntry *)calloc(1UL, <span class="keyword">sizeof</span>(JKHashTableEntry) * dictionary-&gt;capacity)) == NULL)) { [dictionary autorelease]; <span class="keywordflow">return</span>(NULL); }
<a name="l00935"></a>00935 
<a name="l00936"></a>00936     NSUInteger idx = 0UL;
<a name="l00937"></a>00937     <span class="keywordflow">for</span>(idx = 0UL; idx &lt; count; idx++) { _JKDictionaryAddObject(dictionary, keyHashes[idx], keys[idx], objects[idx]); }
<a name="l00938"></a>00938 
<a name="l00939"></a>00939     dictionary-&gt;mutations = (mutableCollection == NO) ? 0UL : 1UL;
<a name="l00940"></a>00940   }
<a name="l00941"></a>00941   <span class="keywordflow">return</span>(dictionary);
<a name="l00942"></a>00942 }
<a name="l00943"></a>00943 
<a name="l00944"></a>00944 - (void)dealloc
<a name="l00945"></a>00945 {
<a name="l00946"></a>00946   <span class="keywordflow">if</span>(JK_EXPECT_T(entry != NULL)) {
<a name="l00947"></a>00947     NSUInteger atEntry = 0UL;
<a name="l00948"></a>00948     <span class="keywordflow">for</span>(atEntry = 0UL; atEntry &lt; capacity; atEntry++) {
<a name="l00949"></a>00949       <span class="keywordflow">if</span>(JK_EXPECT_T(entry[atEntry].key    != NULL)) { CFRelease(entry[atEntry].key);    entry[atEntry].key    = NULL; }
<a name="l00950"></a>00950       <span class="keywordflow">if</span>(JK_EXPECT_T(entry[atEntry].<span class="keywordtype">object</span> != NULL)) { CFRelease(entry[atEntry].<span class="keywordtype">object</span>); entry[atEntry].object = NULL; }
<a name="l00951"></a>00951     }
<a name="l00952"></a>00952   
<a name="l00953"></a>00953     free(entry); entry = NULL;
<a name="l00954"></a>00954   }
<a name="l00955"></a>00955 
<a name="l00956"></a>00956   [<span class="keyword">super</span> dealloc];
<a name="l00957"></a>00957 }
<a name="l00958"></a>00958 
<a name="l00959"></a>00959 <span class="keyword">static</span> JKHashTableEntry *_JKDictionaryHashEntry(JKDictionary *dictionary) {
<a name="l00960"></a>00960   NSCParameterAssert(dictionary != NULL);
<a name="l00961"></a>00961   <span class="keywordflow">return</span>(dictionary-&gt;entry);
<a name="l00962"></a>00962 }
<a name="l00963"></a>00963 
<a name="l00964"></a>00964 <span class="keyword">static</span> NSUInteger _JKDictionaryCapacity(JKDictionary *dictionary) {
<a name="l00965"></a>00965   NSCParameterAssert(dictionary != NULL);
<a name="l00966"></a>00966   <span class="keywordflow">return</span>(dictionary-&gt;capacity);
<a name="l00967"></a>00967 }
<a name="l00968"></a>00968 
<a name="l00969"></a>00969 <span class="keyword">static</span> <span class="keywordtype">void</span> _JKDictionaryRemoveObjectWithEntry(JKDictionary *dictionary, JKHashTableEntry *entry) {
<a name="l00970"></a>00970   NSCParameterAssert((dictionary != NULL) &amp;&amp; (entry != NULL) &amp;&amp; (entry-&gt;key != NULL) &amp;&amp; (entry-&gt;object != NULL) &amp;&amp; (dictionary-&gt;count &gt; 0UL) &amp;&amp; (dictionary-&gt;count &lt;= dictionary-&gt;capacity));
<a name="l00971"></a>00971   CFRelease(entry-&gt;key);    entry-&gt;key    = NULL;
<a name="l00972"></a>00972   CFRelease(entry-&gt;object); entry-&gt;object = NULL;
<a name="l00973"></a>00973   entry-&gt;keyHash = 0UL;
<a name="l00974"></a>00974   dictionary-&gt;count--;
<a name="l00975"></a>00975   <span class="comment">// In order for certain invariants that are used to speed up the search for a particular key, we need to &quot;re-add&quot; all the entries in the hash table following this entry until we hit a NULL entry.</span>
<a name="l00976"></a>00976   NSUInteger removeIdx = entry - dictionary-&gt;entry, idx = 0UL;
<a name="l00977"></a>00977   NSCParameterAssert((removeIdx &lt; dictionary-&gt;capacity));
<a name="l00978"></a>00978   <span class="keywordflow">for</span>(idx = 0UL; idx &lt; dictionary-&gt;capacity; idx++) {
<a name="l00979"></a>00979     NSUInteger entryIdx = (removeIdx + idx + 1UL) % dictionary-&gt;capacity;
<a name="l00980"></a>00980     JKHashTableEntry *atEntry = &amp;dictionary-&gt;entry[entryIdx];
<a name="l00981"></a>00981     <span class="keywordflow">if</span>(atEntry-&gt;key == NULL) { <span class="keywordflow">break</span>; }
<a name="l00982"></a>00982     NSUInteger keyHash = atEntry-&gt;keyHash;
<a name="l00983"></a>00983     <span class="keywordtype">id</span> key = atEntry-&gt;key, <span class="keywordtype">object</span> = atEntry-&gt;object;
<a name="l00984"></a>00984     NSCParameterAssert(<span class="keywordtype">object</span> != NULL);
<a name="l00985"></a>00985     atEntry-&gt;keyHash = 0UL;
<a name="l00986"></a>00986     atEntry-&gt;key     = NULL;
<a name="l00987"></a>00987     atEntry-&gt;object  = NULL;
<a name="l00988"></a>00988     NSUInteger addKeyEntry = keyHash % dictionary-&gt;capacity, addIdx = 0UL;
<a name="l00989"></a>00989     <span class="keywordflow">for</span>(addIdx = 0UL; addIdx &lt; dictionary-&gt;capacity; addIdx++) {
<a name="l00990"></a>00990       JKHashTableEntry *atAddEntry = &amp;dictionary-&gt;entry[((addKeyEntry + addIdx) % dictionary-&gt;capacity)];
<a name="l00991"></a>00991       <span class="keywordflow">if</span>(JK_EXPECT_T(atAddEntry-&gt;key == NULL)) { NSCParameterAssert((atAddEntry-&gt;keyHash == 0UL) &amp;&amp; (atAddEntry-&gt;object == NULL)); atAddEntry-&gt;key = key; atAddEntry-&gt;object = <span class="keywordtype">object</span>; atAddEntry-&gt;keyHash = keyHash; <span class="keywordflow">break</span>; }
<a name="l00992"></a>00992     }
<a name="l00993"></a>00993   }
<a name="l00994"></a>00994 }
<a name="l00995"></a>00995 
<a name="l00996"></a>00996 <span class="keyword">static</span> <span class="keywordtype">void</span> _JKDictionaryAddObject(JKDictionary *dictionary, NSUInteger keyHash, <span class="keywordtype">id</span> key, <span class="keywordtype">id</span> <span class="keywordtype">object</span>) {
<a name="l00997"></a>00997   NSCParameterAssert((dictionary != NULL) &amp;&amp; (key != NULL) &amp;&amp; (<span class="keywordtype">object</span> != NULL) &amp;&amp; (dictionary-&gt;count &lt; dictionary-&gt;capacity) &amp;&amp; (dictionary-&gt;entry != NULL));
<a name="l00998"></a>00998   NSUInteger keyEntry = keyHash % dictionary-&gt;capacity, idx = 0UL;
<a name="l00999"></a>00999   <span class="keywordflow">for</span>(idx = 0UL; idx &lt; dictionary-&gt;capacity; idx++) {
<a name="l01000"></a>01000     NSUInteger entryIdx = (keyEntry + idx) % dictionary-&gt;capacity;
<a name="l01001"></a>01001     JKHashTableEntry *atEntry = &amp;dictionary-&gt;entry[entryIdx];
<a name="l01002"></a>01002     <span class="keywordflow">if</span>(JK_EXPECT_F(atEntry-&gt;keyHash == keyHash) &amp;&amp; JK_EXPECT_T(atEntry-&gt;key != NULL) &amp;&amp; (JK_EXPECT_F(key == atEntry-&gt;key) || JK_EXPECT_F(CFEqual(atEntry-&gt;key, key)))) { _JKDictionaryRemoveObjectWithEntry(dictionary, atEntry); }
<a name="l01003"></a>01003     <span class="keywordflow">if</span>(JK_EXPECT_T(atEntry-&gt;key == NULL)) { NSCParameterAssert((atEntry-&gt;keyHash == 0UL) &amp;&amp; (atEntry-&gt;object == NULL)); atEntry-&gt;key = key; atEntry-&gt;object = <span class="keywordtype">object</span>; atEntry-&gt;keyHash = keyHash; dictionary-&gt;count++; <span class="keywordflow">return</span>; }
<a name="l01004"></a>01004   }
<a name="l01005"></a>01005 
<a name="l01006"></a>01006   <span class="comment">// We should never get here.  If we do, we -release the key / object because it&#39;s our responsibility.</span>
<a name="l01007"></a>01007   CFRelease(key);
<a name="l01008"></a>01008   CFRelease(<span class="keywordtype">object</span>);
<a name="l01009"></a>01009 }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011 - (NSUInteger)count
<a name="l01012"></a>01012 {
<a name="l01013"></a>01013   <span class="keywordflow">return</span>(count);
<a name="l01014"></a>01014 }
<a name="l01015"></a>01015 
<a name="l01016"></a>01016 <span class="keyword">static</span> JKHashTableEntry *_JKDictionaryHashTableEntryForKey(JKDictionary *dictionary, <span class="keywordtype">id</span> aKey) {
<a name="l01017"></a>01017   NSCParameterAssert((dictionary != NULL) &amp;&amp; (dictionary-&gt;entry != NULL) &amp;&amp; (dictionary-&gt;count &lt;= dictionary-&gt;capacity));
<a name="l01018"></a>01018   <span class="keywordflow">if</span>((aKey == NULL) || (dictionary-&gt;capacity == 0UL)) { <span class="keywordflow">return</span>(NULL); }
<a name="l01019"></a>01019   NSUInteger        keyHash = CFHash(aKey), keyEntry = (keyHash % dictionary-&gt;capacity), idx = 0UL;
<a name="l01020"></a>01020   JKHashTableEntry *atEntry = NULL;
<a name="l01021"></a>01021   <span class="keywordflow">for</span>(idx = 0UL; idx &lt; dictionary-&gt;capacity; idx++) {
<a name="l01022"></a>01022     atEntry = &amp;dictionary-&gt;entry[(keyEntry + idx) % dictionary-&gt;capacity];
<a name="l01023"></a>01023     <span class="keywordflow">if</span>(JK_EXPECT_T(atEntry-&gt;keyHash == keyHash) &amp;&amp; JK_EXPECT_T(atEntry-&gt;key != NULL) &amp;&amp; ((atEntry-&gt;key == aKey) || CFEqual(atEntry-&gt;key, aKey))) { NSCParameterAssert(atEntry-&gt;object != NULL); <span class="keywordflow">return</span>(atEntry); <span class="keywordflow">break</span>; }
<a name="l01024"></a>01024     <span class="keywordflow">if</span>(JK_EXPECT_F(atEntry-&gt;key == NULL)) { NSCParameterAssert(atEntry-&gt;object == NULL); <span class="keywordflow">return</span>(NULL); <span class="keywordflow">break</span>; } <span class="comment">// If the key was in the table, we would have found it by now.</span>
<a name="l01025"></a>01025   }
<a name="l01026"></a>01026   <span class="keywordflow">return</span>(NULL);
<a name="l01027"></a>01027 }
<a name="l01028"></a>01028 
<a name="l01029"></a>01029 - (id)objectForKey:(<span class="keywordtype">id</span>)aKey
<a name="l01030"></a>01030 {
<a name="l01031"></a>01031   NSParameterAssert((entry != NULL) &amp;&amp; (count &lt;= capacity));
<a name="l01032"></a>01032   JKHashTableEntry *entryForKey = _JKDictionaryHashTableEntryForKey(<span class="keyword">self</span>, aKey);
<a name="l01033"></a>01033   <span class="keywordflow">return</span>((entryForKey != NULL) ? entryForKey-&gt;object : NULL);
<a name="l01034"></a>01034 }
<a name="l01035"></a>01035 
<a name="l01036"></a>01036 - (void)getObjects:(<span class="keywordtype">id</span> *)objects andKeys:(<span class="keywordtype">id</span> *)keys
<a name="l01037"></a>01037 {
<a name="l01038"></a>01038   NSParameterAssert((entry != NULL) &amp;&amp; (count &lt;= capacity));
<a name="l01039"></a>01039   NSUInteger atEntry = 0UL; NSUInteger arrayIdx = 0UL;
<a name="l01040"></a>01040   <span class="keywordflow">for</span>(atEntry = 0UL; atEntry &lt; capacity; atEntry++) {
<a name="l01041"></a>01041     <span class="keywordflow">if</span>(JK_EXPECT_T(entry[atEntry].key != NULL)) {
<a name="l01042"></a>01042       NSCParameterAssert((entry[atEntry].<span class="keywordtype">object</span> != NULL) &amp;&amp; (arrayIdx &lt; count));
<a name="l01043"></a>01043       <span class="keywordflow">if</span>(JK_EXPECT_T(keys    != NULL)) { keys[arrayIdx]    = entry[atEntry].key;    }
<a name="l01044"></a>01044       <span class="keywordflow">if</span>(JK_EXPECT_T(objects != NULL)) { objects[arrayIdx] = entry[atEntry].object; }
<a name="l01045"></a>01045       arrayIdx++;
<a name="l01046"></a>01046     }
<a name="l01047"></a>01047   }
<a name="l01048"></a>01048 }
<a name="l01049"></a>01049 
<a name="l01050"></a>01050 - (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(<span class="keywordtype">id</span> *)stackbuf count:(NSUInteger)len
<a name="l01051"></a>01051 {
<a name="l01052"></a>01052   NSParameterAssert((state != NULL) &amp;&amp; (stackbuf != NULL) &amp;&amp; (len &gt; 0UL) &amp;&amp; (entry != NULL) &amp;&amp; (count &lt;= capacity));
<a name="l01053"></a>01053   <span class="keywordflow">if</span>(JK_EXPECT_F(state-&gt;state == 0UL))      { state-&gt;mutationsPtr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;mutations; state-&gt;itemsPtr = stackbuf; }
<a name="l01054"></a>01054   <span class="keywordflow">if</span>(JK_EXPECT_F(state-&gt;state &gt;= capacity)) { <span class="keywordflow">return</span>(0UL); }
<a name="l01055"></a>01055   
<a name="l01056"></a>01056   NSUInteger enumeratedCount  = 0UL;
<a name="l01057"></a>01057   <span class="keywordflow">while</span>(JK_EXPECT_T(enumeratedCount &lt; len) &amp;&amp; JK_EXPECT_T(state-&gt;state &lt; capacity)) { <span class="keywordflow">if</span>(JK_EXPECT_T(entry[state-&gt;state].key != NULL)) { stackbuf[enumeratedCount++] = entry[state-&gt;state].key; } state-&gt;state++; }
<a name="l01058"></a>01058     
<a name="l01059"></a>01059   <span class="keywordflow">return</span>(enumeratedCount);
<a name="l01060"></a>01060 }
<a name="l01061"></a>01061 
<a name="l01062"></a>01062 - (NSEnumerator *)keyEnumerator
<a name="l01063"></a>01063 {
<a name="l01064"></a>01064   <span class="keywordflow">return</span>([[[JKDictionaryEnumerator alloc] initWithJKDictionary:<span class="keyword">self</span>] autorelease]);
<a name="l01065"></a>01065 }
<a name="l01066"></a>01066 
<a name="l01067"></a>01067 - (void)setObject:(<span class="keywordtype">id</span>)anObject forKey:(<span class="keywordtype">id</span>)aKey
<a name="l01068"></a>01068 {
<a name="l01069"></a>01069   <span class="keywordflow">if</span>(mutations == 0UL)  { [NSException raise:NSInternalInconsistencyException format:@&quot;*** -[%@ %@]: mutating method sent to immutable object&quot;, NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd)];       }
<a name="l01070"></a>01070   <span class="keywordflow">if</span>(aKey      == NULL) { [NSException raise:NSInvalidArgumentException       format:@&quot;*** -[%@ %@]: attempt to insert nil key&quot;,                NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd)];       }
<a name="l01071"></a>01071   <span class="keywordflow">if</span>(anObject  == NULL) { [NSException raise:NSInvalidArgumentException       format:@&quot;*** -[%@ %@]: attempt to insert nil value (key: %@)&quot;,    NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd), aKey]; }
<a name="l01072"></a>01072   
<a name="l01073"></a>01073   _JKDictionaryResizeIfNeccessary(<span class="keyword">self</span>);
<a name="l01074"></a>01074 <span class="preprocessor">#ifndef __clang_analyzer__</span>
<a name="l01075"></a>01075 <span class="preprocessor"></span>  aKey     = [aKey     copy];   <span class="comment">// Why on earth would clang complain that this -copy &quot;might leak&quot;, </span>
<a name="l01076"></a>01076   anObject = [anObject retain]; <span class="comment">// but this -retain doesn&#39;t!?</span>
<a name="l01077"></a>01077 <span class="preprocessor">#endif // __clang_analyzer__</span>
<a name="l01078"></a>01078 <span class="preprocessor"></span>  _JKDictionaryAddObject(<span class="keyword">self</span>, CFHash(aKey), aKey, anObject);
<a name="l01079"></a>01079   mutations = (mutations == NSUIntegerMax) ? 1UL : mutations + 1UL;
<a name="l01080"></a>01080 }
<a name="l01081"></a>01081 
<a name="l01082"></a>01082 - (void)removeObjectForKey:(<span class="keywordtype">id</span>)aKey
<a name="l01083"></a>01083 {
<a name="l01084"></a>01084   <span class="keywordflow">if</span>(mutations == 0UL)  { [NSException raise:NSInternalInconsistencyException format:@&quot;*** -[%@ %@]: mutating method sent to immutable object&quot;, NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd)]; }
<a name="l01085"></a>01085   <span class="keywordflow">if</span>(aKey      == NULL) { [NSException raise:NSInvalidArgumentException       format:@&quot;*** -[%@ %@]: attempt to remove nil key&quot;,                NSStringFromClass([<span class="keyword">self</span> class]), NSStringFromSelector(_cmd)]; }
<a name="l01086"></a>01086   JKHashTableEntry *entryForKey = _JKDictionaryHashTableEntryForKey(<span class="keyword">self</span>, aKey);
<a name="l01087"></a>01087   <span class="keywordflow">if</span>(entryForKey != NULL) {
<a name="l01088"></a>01088     _JKDictionaryRemoveObjectWithEntry(<span class="keyword">self</span>, entryForKey);
<a name="l01089"></a>01089     mutations = (mutations == NSUIntegerMax) ? 1UL : mutations + 1UL;
<a name="l01090"></a>01090   }
<a name="l01091"></a>01091 }
<a name="l01092"></a>01092 
<a name="l01093"></a>01093 - (id)copyWithZone:(NSZone *)zone
<a name="l01094"></a>01094 {
<a name="l01095"></a>01095   NSParameterAssert((entry != NULL) &amp;&amp; (count &lt;= capacity));
<a name="l01096"></a>01096   <span class="keywordflow">return</span>((mutations == 0UL) ? [<span class="keyword">self</span> retain] : [[NSDictionary allocWithZone:zone] initWithDictionary:<span class="keyword">self</span>]);
<a name="l01097"></a>01097 }
<a name="l01098"></a>01098 
<a name="l01099"></a>01099 - (id)mutableCopyWithZone:(NSZone *)zone
<a name="l01100"></a>01100 {
<a name="l01101"></a>01101   NSParameterAssert((entry != NULL) &amp;&amp; (count &lt;= capacity));
<a name="l01102"></a>01102   <span class="keywordflow">return</span>([[NSMutableDictionary allocWithZone:zone] initWithDictionary:<span class="keyword">self</span>]);
<a name="l01103"></a>01103 }
<a name="l01104"></a>01104 
<a name="l01105"></a>01105 <span class="keyword">@end</span>
<a name="l01106"></a>01106 
<a name="l01107"></a>01107 
<a name="l01108"></a>01108 
<a name="l01109"></a>01109 <span class="preprocessor">#pragma mark -</span>
<a name="l01110"></a>01110 <span class="preprocessor"></span>
<a name="l01111"></a>01111 JK_STATIC_INLINE <span class="keywordtype">size_t</span> jk_min(<span class="keywordtype">size_t</span> a, <span class="keywordtype">size_t</span> b) { <span class="keywordflow">return</span>((a &lt; b) ? a : b); }
<a name="l01112"></a>01112 JK_STATIC_INLINE <span class="keywordtype">size_t</span> jk_max(<span class="keywordtype">size_t</span> a, <span class="keywordtype">size_t</span> b) { <span class="keywordflow">return</span>((a &gt; b) ? a : b); }
<a name="l01113"></a>01113 
<a name="l01114"></a>01114 JK_STATIC_INLINE JKHash calculateHash(JKHash currentHash, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c) { <span class="keywordflow">return</span>(((currentHash &lt;&lt; 5) + currentHash) + c); }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116 <span class="keyword">static</span> <span class="keywordtype">void</span> jk_error(JKParseState *parseState, <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *format, ...) {
<a name="l01117"></a>01117   NSCParameterAssert((parseState != NULL) &amp;&amp; (format != NULL));
<a name="l01118"></a>01118 
<a name="l01119"></a>01119   va_list varArgsList;
<a name="l01120"></a>01120   va_start(varArgsList, format);
<a name="l01121"></a>01121   <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *formatString = [[[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> alloc] initWithFormat:format arguments:varArgsList] autorelease];
<a name="l01122"></a>01122   va_end(varArgsList);
<a name="l01123"></a>01123 
<a name="l01124"></a>01124 <span class="preprocessor">#if 0</span>
<a name="l01125"></a>01125 <span class="preprocessor"></span>  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *lineStart      = parseState-&gt;stringBuffer.bytes.ptr + parseState-&gt;lineStartIndex;
<a name="l01126"></a>01126   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *lineEnd        = lineStart;
<a name="l01127"></a>01127   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *atCharacterPtr = NULL;
<a name="l01128"></a>01128 
<a name="l01129"></a>01129   <span class="keywordflow">for</span>(atCharacterPtr = lineStart; atCharacterPtr &lt; JK_END_STRING_PTR(parseState); atCharacterPtr++) { lineEnd = atCharacterPtr; <span class="keywordflow">if</span>(jk_parse_is_newline(parseState, atCharacterPtr)) { <span class="keywordflow">break</span>; } }
<a name="l01130"></a>01130 
<a name="l01131"></a>01131   <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *lineString = <span class="stringliteral">@&quot;&quot;</span>, *carretString = <span class="stringliteral">@&quot;&quot;</span>;
<a name="l01132"></a>01132   <span class="keywordflow">if</span>(lineStart &lt; JK_END_STRING_PTR(parseState)) {
<a name="l01133"></a>01133     lineString   = [[[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> alloc] initWithBytes:lineStart length:(lineEnd - lineStart) encoding:NSUTF8StringEncoding] autorelease];
<a name="l01134"></a>01134     carretString = [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;%*.*s^&quot;, (int)(parseState-&gt;atIndex - parseState-&gt;lineStartIndex), (int)(parseState-&gt;atIndex - parseState-&gt;lineStartIndex), &quot; &quot;];
<a name="l01135"></a>01135   }
<a name="l01136"></a>01136 <span class="preprocessor">#endif</span>
<a name="l01137"></a>01137 <span class="preprocessor"></span>
<a name="l01138"></a>01138   <span class="keywordflow">if</span>(parseState-&gt;error == NULL) {
<a name="l01139"></a>01139     parseState-&gt;error = <span class="comment">//lineString,   @&quot;JKErrorLine0Key&quot;,</span><span class="comment">//carretString, @&quot;JKErrorLine1Key&quot;,</span>[NSError errorWithDomain:@&quot;JKErrorDomain&quot; code:-1L userInfo:
<a name="l01140"></a>01140                                    [NSDictionary dictionaryWithObjectsAndKeys:
<a name="l01141"></a>01141                                                                               formatString,                                             NSLocalizedDescriptionKey,
<a name="l01142"></a>01142                                                                               [NSNumber numberWithUnsignedLong:parseState-&gt;atIndex],    @&quot;JKAtIndexKey&quot;,
<a name="l01143"></a>01143                                                                               [NSNumber numberWithUnsignedLong:parseState-&gt;lineNumber], @&quot;JKLineNumberKey&quot;,
<a name="l01144"></a>01144                                                  
<a name="l01145"></a>01145                                                  
<a name="l01146"></a>01146                                                                               NULL]];
<a name="l01147"></a>01147   }
<a name="l01148"></a>01148 }
<a name="l01149"></a>01149 
<a name="l01150"></a>01150 <span class="preprocessor">#pragma mark -</span>
<a name="l01151"></a>01151 <span class="preprocessor"></span><span class="preprocessor">#pragma mark Buffer and Object Stack management functions</span>
<a name="l01152"></a>01152 <span class="preprocessor"></span>
<a name="l01153"></a>01153 <span class="keyword">static</span> <span class="keywordtype">void</span> jk_managedBuffer_release(JKManagedBuffer *managedBuffer) {
<a name="l01154"></a>01154   <span class="keywordflow">if</span>((managedBuffer-&gt;flags &amp; JKManagedBufferMustFree)) {
<a name="l01155"></a>01155     <span class="keywordflow">if</span>(managedBuffer-&gt;bytes.ptr != NULL) { free(managedBuffer-&gt;bytes.ptr); managedBuffer-&gt;bytes.ptr = NULL; }
<a name="l01156"></a>01156     managedBuffer-&gt;flags &amp;= ~JKManagedBufferMustFree;
<a name="l01157"></a>01157   }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159   managedBuffer-&gt;bytes.ptr     = NULL;
<a name="l01160"></a>01160   managedBuffer-&gt;bytes.length  = 0UL;
<a name="l01161"></a>01161   managedBuffer-&gt;flags        &amp;= ~JKManagedBufferLocationMask;
<a name="l01162"></a>01162 }
<a name="l01163"></a>01163 
<a name="l01164"></a>01164 <span class="keyword">static</span> <span class="keywordtype">void</span> jk_managedBuffer_setToStackBuffer(JKManagedBuffer *managedBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ptr, <span class="keywordtype">size_t</span> length) {
<a name="l01165"></a>01165   jk_managedBuffer_release(managedBuffer);
<a name="l01166"></a>01166   managedBuffer-&gt;bytes.ptr     = ptr;
<a name="l01167"></a>01167   managedBuffer-&gt;bytes.length  = length;
<a name="l01168"></a>01168   managedBuffer-&gt;flags         = (managedBuffer-&gt;flags &amp; ~JKManagedBufferLocationMask) | JKManagedBufferOnStack;
<a name="l01169"></a>01169 }
<a name="l01170"></a>01170 
<a name="l01171"></a>01171 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *jk_managedBuffer_resize(JKManagedBuffer *managedBuffer, <span class="keywordtype">size_t</span> newSize) {
<a name="l01172"></a>01172   <span class="keywordtype">size_t</span> roundedUpNewSize = newSize;
<a name="l01173"></a>01173 
<a name="l01174"></a>01174   <span class="keywordflow">if</span>(managedBuffer-&gt;roundSizeUpToMultipleOf &gt; 0UL) { roundedUpNewSize = newSize + ((managedBuffer-&gt;roundSizeUpToMultipleOf - (newSize % managedBuffer-&gt;roundSizeUpToMultipleOf)) % managedBuffer-&gt;roundSizeUpToMultipleOf); }
<a name="l01175"></a>01175 
<a name="l01176"></a>01176   <span class="keywordflow">if</span>((roundedUpNewSize != managedBuffer-&gt;bytes.length) &amp;&amp; (roundedUpNewSize &gt; managedBuffer-&gt;bytes.length)) {
<a name="l01177"></a>01177     <span class="keywordflow">if</span>((managedBuffer-&gt;flags &amp; JKManagedBufferLocationMask) == JKManagedBufferOnStack) {
<a name="l01178"></a>01178       NSCParameterAssert((managedBuffer-&gt;flags &amp; JKManagedBufferMustFree) == 0);
<a name="l01179"></a>01179       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *newBuffer = NULL, *oldBuffer = managedBuffer-&gt;bytes.ptr;
<a name="l01180"></a>01180       
<a name="l01181"></a>01181       <span class="keywordflow">if</span>((newBuffer = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)malloc(roundedUpNewSize)) == NULL) { <span class="keywordflow">return</span>(NULL); }
<a name="l01182"></a>01182       memcpy(newBuffer, oldBuffer, jk_min(managedBuffer-&gt;bytes.length, roundedUpNewSize));
<a name="l01183"></a>01183       managedBuffer-&gt;flags        = (managedBuffer-&gt;flags &amp; ~JKManagedBufferLocationMask) | (JKManagedBufferOnHeap | JKManagedBufferMustFree);
<a name="l01184"></a>01184       managedBuffer-&gt;bytes.ptr    = newBuffer;
<a name="l01185"></a>01185       managedBuffer-&gt;bytes.length = roundedUpNewSize;
<a name="l01186"></a>01186     } <span class="keywordflow">else</span> {
<a name="l01187"></a>01187       NSCParameterAssert(((managedBuffer-&gt;flags &amp; JKManagedBufferMustFree) != 0) &amp;&amp; ((managedBuffer-&gt;flags &amp; JKManagedBufferLocationMask) == JKManagedBufferOnHeap));
<a name="l01188"></a>01188       <span class="keywordflow">if</span>((managedBuffer-&gt;bytes.ptr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)reallocf(managedBuffer-&gt;bytes.ptr, roundedUpNewSize)) == NULL) { <span class="keywordflow">return</span>(NULL); }
<a name="l01189"></a>01189       managedBuffer-&gt;bytes.length = roundedUpNewSize;
<a name="l01190"></a>01190     }
<a name="l01191"></a>01191   }
<a name="l01192"></a>01192 
<a name="l01193"></a>01193   <span class="keywordflow">return</span>(managedBuffer-&gt;bytes.ptr);
<a name="l01194"></a>01194 }
<a name="l01195"></a>01195 
<a name="l01196"></a>01196 
<a name="l01197"></a>01197 
<a name="l01198"></a>01198 <span class="keyword">static</span> <span class="keywordtype">void</span> jk_objectStack_release(JKObjectStack *objectStack) {
<a name="l01199"></a>01199   NSCParameterAssert(objectStack != NULL);
<a name="l01200"></a>01200 
<a name="l01201"></a>01201   NSCParameterAssert(objectStack-&gt;index &lt;= objectStack-&gt;count);
<a name="l01202"></a>01202   <span class="keywordtype">size_t</span> atIndex = 0UL;
<a name="l01203"></a>01203   <span class="keywordflow">for</span>(atIndex = 0UL; atIndex &lt; objectStack-&gt;index; atIndex++) {
<a name="l01204"></a>01204     <span class="keywordflow">if</span>(objectStack-&gt;objects[atIndex] != NULL) { CFRelease(objectStack-&gt;objects[atIndex]); objectStack-&gt;objects[atIndex] = NULL; }
<a name="l01205"></a>01205     <span class="keywordflow">if</span>(objectStack-&gt;keys[atIndex]    != NULL) { CFRelease(objectStack-&gt;keys[atIndex]);    objectStack-&gt;keys[atIndex]    = NULL; }
<a name="l01206"></a>01206   }
<a name="l01207"></a>01207   objectStack-&gt;index = 0UL;
<a name="l01208"></a>01208 
<a name="l01209"></a>01209   <span class="keywordflow">if</span>(objectStack-&gt;flags &amp; JKObjectStackMustFree) {
<a name="l01210"></a>01210     NSCParameterAssert((objectStack-&gt;flags &amp; JKObjectStackLocationMask) == JKObjectStackOnHeap);
<a name="l01211"></a>01211     <span class="keywordflow">if</span>(objectStack-&gt;objects  != NULL) { free(objectStack-&gt;objects);  objectStack-&gt;objects  = NULL; }
<a name="l01212"></a>01212     <span class="keywordflow">if</span>(objectStack-&gt;keys     != NULL) { free(objectStack-&gt;keys);     objectStack-&gt;keys     = NULL; }
<a name="l01213"></a>01213     <span class="keywordflow">if</span>(objectStack-&gt;cfHashes != NULL) { free(objectStack-&gt;cfHashes); objectStack-&gt;cfHashes = NULL; }
<a name="l01214"></a>01214     objectStack-&gt;flags &amp;= ~JKObjectStackMustFree;
<a name="l01215"></a>01215   }
<a name="l01216"></a>01216 
<a name="l01217"></a>01217   objectStack-&gt;objects  = NULL;
<a name="l01218"></a>01218   objectStack-&gt;keys     = NULL;
<a name="l01219"></a>01219   objectStack-&gt;cfHashes = NULL;
<a name="l01220"></a>01220 
<a name="l01221"></a>01221   objectStack-&gt;count    = 0UL;
<a name="l01222"></a>01222   objectStack-&gt;flags   &amp;= ~JKObjectStackLocationMask;
<a name="l01223"></a>01223 }
<a name="l01224"></a>01224 
<a name="l01225"></a>01225 <span class="keyword">static</span> <span class="keywordtype">void</span> jk_objectStack_setToStackBuffer(JKObjectStack *objectStack, <span class="keywordtype">void</span> **objects, <span class="keywordtype">void</span> **keys, CFHashCode *cfHashes, <span class="keywordtype">size_t</span> count) {
<a name="l01226"></a>01226   NSCParameterAssert((objectStack != NULL) &amp;&amp; (objects != NULL) &amp;&amp; (keys != NULL) &amp;&amp; (cfHashes != NULL) &amp;&amp; (count &gt; 0UL));
<a name="l01227"></a>01227   jk_objectStack_release(objectStack);
<a name="l01228"></a>01228   objectStack-&gt;objects  = objects;
<a name="l01229"></a>01229   objectStack-&gt;keys     = keys;
<a name="l01230"></a>01230   objectStack-&gt;cfHashes = cfHashes;
<a name="l01231"></a>01231   objectStack-&gt;count    = count;
<a name="l01232"></a>01232   objectStack-&gt;flags    = (objectStack-&gt;flags &amp; ~JKObjectStackLocationMask) | JKObjectStackOnStack;
<a name="l01233"></a>01233 <span class="preprocessor">#ifndef NS_BLOCK_ASSERTIONS</span>
<a name="l01234"></a>01234 <span class="preprocessor"></span>  <span class="keywordtype">size_t</span> idx;
<a name="l01235"></a>01235   <span class="keywordflow">for</span>(idx = 0UL; idx &lt; objectStack-&gt;count; idx++) { objectStack-&gt;objects[idx] = NULL; objectStack-&gt;keys[idx] = NULL; objectStack-&gt;cfHashes[idx] = 0UL; }
<a name="l01236"></a>01236 <span class="preprocessor">#endif</span>
<a name="l01237"></a>01237 <span class="preprocessor"></span>}
<a name="l01238"></a>01238 
<a name="l01239"></a>01239 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_objectStack_resize(JKObjectStack *objectStack, <span class="keywordtype">size_t</span> newCount) {
<a name="l01240"></a>01240   <span class="keywordtype">size_t</span> roundedUpNewCount = newCount;
<a name="l01241"></a>01241   <span class="keywordtype">int</span>    returnCode = 0;
<a name="l01242"></a>01242 
<a name="l01243"></a>01243   <span class="keywordtype">void</span>       **newObjects  = NULL, **newKeys = NULL;
<a name="l01244"></a>01244   CFHashCode  *newCFHashes = NULL;
<a name="l01245"></a>01245 
<a name="l01246"></a>01246   <span class="keywordflow">if</span>(objectStack-&gt;roundSizeUpToMultipleOf &gt; 0UL) { roundedUpNewCount = newCount + ((objectStack-&gt;roundSizeUpToMultipleOf - (newCount % objectStack-&gt;roundSizeUpToMultipleOf)) % objectStack-&gt;roundSizeUpToMultipleOf); }
<a name="l01247"></a>01247 
<a name="l01248"></a>01248   <span class="keywordflow">if</span>((roundedUpNewCount != objectStack-&gt;count) &amp;&amp; (roundedUpNewCount &gt; objectStack-&gt;count)) {
<a name="l01249"></a>01249     <span class="keywordflow">if</span>((objectStack-&gt;flags &amp; JKObjectStackLocationMask) == JKObjectStackOnStack) {
<a name="l01250"></a>01250       NSCParameterAssert((objectStack-&gt;flags &amp; JKObjectStackMustFree) == 0);
<a name="l01251"></a>01251 
<a name="l01252"></a>01252       <span class="keywordflow">if</span>((newObjects  = (<span class="keywordtype">void</span> **     )calloc(1UL, roundedUpNewCount * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *    ))) == NULL) { returnCode = 1; <span class="keywordflow">goto</span> errorExit; }
<a name="l01253"></a>01253       memcpy(newObjects, objectStack-&gt;objects,   jk_min(objectStack-&gt;count, roundedUpNewCount) * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *));
<a name="l01254"></a>01254       <span class="keywordflow">if</span>((newKeys     = (<span class="keywordtype">void</span> **     )calloc(1UL, roundedUpNewCount * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *    ))) == NULL) { returnCode = 1; <span class="keywordflow">goto</span> errorExit; }
<a name="l01255"></a>01255       memcpy(newKeys,     objectStack-&gt;keys,     jk_min(objectStack-&gt;count, roundedUpNewCount) * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *));
<a name="l01256"></a>01256 
<a name="l01257"></a>01257       <span class="keywordflow">if</span>((newCFHashes = (CFHashCode *)calloc(1UL, roundedUpNewCount * <span class="keyword">sizeof</span>(CFHashCode))) == NULL) { returnCode = 1; <span class="keywordflow">goto</span> errorExit; }
<a name="l01258"></a>01258       memcpy(newCFHashes, objectStack-&gt;cfHashes, jk_min(objectStack-&gt;count, roundedUpNewCount) * <span class="keyword">sizeof</span>(CFHashCode));
<a name="l01259"></a>01259 
<a name="l01260"></a>01260       objectStack-&gt;flags    = (objectStack-&gt;flags &amp; ~JKObjectStackLocationMask) | (JKObjectStackOnHeap | JKObjectStackMustFree);
<a name="l01261"></a>01261       objectStack-&gt;objects  = newObjects;  newObjects  = NULL;
<a name="l01262"></a>01262       objectStack-&gt;keys     = newKeys;     newKeys     = NULL;
<a name="l01263"></a>01263       objectStack-&gt;cfHashes = newCFHashes; newCFHashes = NULL;
<a name="l01264"></a>01264       objectStack-&gt;count    = roundedUpNewCount;
<a name="l01265"></a>01265     } <span class="keywordflow">else</span> {
<a name="l01266"></a>01266       NSCParameterAssert(((objectStack-&gt;flags &amp; JKObjectStackMustFree) != 0) &amp;&amp; ((objectStack-&gt;flags &amp; JKObjectStackLocationMask) == JKObjectStackOnHeap));
<a name="l01267"></a>01267       <span class="keywordflow">if</span>((newObjects  = (<span class="keywordtype">void</span>  **    )realloc(objectStack-&gt;objects,  roundedUpNewCount * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *    ))) != NULL) { objectStack-&gt;objects  = newObjects;  newObjects  = NULL; } <span class="keywordflow">else</span> { returnCode = 1; <span class="keywordflow">goto</span> errorExit; }
<a name="l01268"></a>01268       <span class="keywordflow">if</span>((newKeys     = (<span class="keywordtype">void</span>  **    )realloc(objectStack-&gt;keys,     roundedUpNewCount * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *    ))) != NULL) { objectStack-&gt;keys     = newKeys;     newKeys     = NULL; } <span class="keywordflow">else</span> { returnCode = 1; <span class="keywordflow">goto</span> errorExit; }
<a name="l01269"></a>01269       <span class="keywordflow">if</span>((newCFHashes = (CFHashCode *)realloc(objectStack-&gt;cfHashes, roundedUpNewCount * <span class="keyword">sizeof</span>(CFHashCode))) != NULL) { objectStack-&gt;cfHashes = newCFHashes; newCFHashes = NULL; } <span class="keywordflow">else</span> { returnCode = 1; <span class="keywordflow">goto</span> errorExit; }
<a name="l01270"></a>01270 
<a name="l01271"></a>01271 <span class="preprocessor">#ifndef NS_BLOCK_ASSERTIONS</span>
<a name="l01272"></a>01272 <span class="preprocessor"></span>      <span class="keywordtype">size_t</span> idx;
<a name="l01273"></a>01273       <span class="keywordflow">for</span>(idx = objectStack-&gt;count; idx &lt; roundedUpNewCount; idx++) { objectStack-&gt;objects[idx] = NULL; objectStack-&gt;keys[idx] = NULL; objectStack-&gt;cfHashes[idx] = 0UL; }
<a name="l01274"></a>01274 <span class="preprocessor">#endif</span>
<a name="l01275"></a>01275 <span class="preprocessor"></span>      objectStack-&gt;count = roundedUpNewCount;
<a name="l01276"></a>01276     }
<a name="l01277"></a>01277   }
<a name="l01278"></a>01278 
<a name="l01279"></a>01279  errorExit:
<a name="l01280"></a>01280   <span class="keywordflow">if</span>(newObjects  != NULL) { free(newObjects);  newObjects  = NULL; }
<a name="l01281"></a>01281   <span class="keywordflow">if</span>(newKeys     != NULL) { free(newKeys);     newKeys     = NULL; }
<a name="l01282"></a>01282   <span class="keywordflow">if</span>(newCFHashes != NULL) { free(newCFHashes); newCFHashes = NULL; }
<a name="l01283"></a>01283 
<a name="l01284"></a>01284   <span class="keywordflow">return</span>(returnCode);
<a name="l01285"></a>01285 }
<a name="l01286"></a>01286 
<a name="l01288"></a>01288 <span class="preprocessor">#pragma mark -</span>
<a name="l01289"></a>01289 <span class="preprocessor"></span><span class="preprocessor">#pragma mark Unicode related functions</span>
<a name="l01290"></a>01290 <span class="preprocessor"></span>
<a name="l01291"></a>01291 JK_STATIC_INLINE ConversionResult isValidCodePoint(UTF32 *u32CodePoint) {
<a name="l01292"></a>01292   ConversionResult result = conversionOK;
<a name="l01293"></a>01293   UTF32            ch     = *u32CodePoint;
<a name="l01294"></a>01294 
<a name="l01295"></a>01295   <span class="keywordflow">if</span>(JK_EXPECT_F(ch &gt;= UNI_SUR_HIGH_START) &amp;&amp; (JK_EXPECT_T(ch &lt;= UNI_SUR_LOW_END)))                                                        { result = sourceIllegal; ch = UNI_REPLACEMENT_CHAR; <span class="keywordflow">goto</span> finished; }
<a name="l01296"></a>01296   <span class="keywordflow">if</span>(JK_EXPECT_F(ch &gt;= 0xFDD0U) &amp;&amp; (JK_EXPECT_F(ch &lt;= 0xFDEFU) || JK_EXPECT_F((ch &amp; 0xFFFEU) == 0xFFFEU)) &amp;&amp; JK_EXPECT_T(ch &lt;= 0x10FFFFU)) { result = sourceIllegal; ch = UNI_REPLACEMENT_CHAR; <span class="keywordflow">goto</span> finished; }
<a name="l01297"></a>01297   <span class="keywordflow">if</span>(JK_EXPECT_F(ch == 0U))                                                                                                                { result = sourceIllegal; ch = UNI_REPLACEMENT_CHAR; <span class="keywordflow">goto</span> finished; }
<a name="l01298"></a>01298 
<a name="l01299"></a>01299  finished:
<a name="l01300"></a>01300   *u32CodePoint = ch;
<a name="l01301"></a>01301   <span class="keywordflow">return</span>(result);
<a name="l01302"></a>01302 }
<a name="l01303"></a>01303 
<a name="l01304"></a>01304 
<a name="l01305"></a>01305 <span class="keyword">static</span> <span class="keywordtype">int</span> isLegalUTF8(<span class="keyword">const</span> UTF8 *source, <span class="keywordtype">size_t</span> length) {
<a name="l01306"></a>01306   <span class="keyword">const</span> UTF8 *srcptr = source + length;
<a name="l01307"></a>01307   UTF8 a;
<a name="l01308"></a>01308 
<a name="l01309"></a>01309   <span class="keywordflow">switch</span>(length) {
<a name="l01310"></a>01310     <span class="keywordflow">default</span>: <span class="keywordflow">return</span>(0); <span class="comment">// Everything else falls through when &quot;true&quot;...</span>
<a name="l01311"></a>01311     <span class="keywordflow">case</span> 4: <span class="keywordflow">if</span>(JK_EXPECT_F(((a = (*--srcptr)) &lt; 0x80) || (a &gt; 0xBF))) { <span class="keywordflow">return</span>(0); }
<a name="l01312"></a>01312     <span class="keywordflow">case</span> 3: <span class="keywordflow">if</span>(JK_EXPECT_F(((a = (*--srcptr)) &lt; 0x80) || (a &gt; 0xBF))) { <span class="keywordflow">return</span>(0); }
<a name="l01313"></a>01313     <span class="keywordflow">case</span> 2: <span class="keywordflow">if</span>(JK_EXPECT_F( (a = (*--srcptr)) &gt; 0xBF               )) { <span class="keywordflow">return</span>(0); }
<a name="l01314"></a>01314       
<a name="l01315"></a>01315       <span class="keywordflow">switch</span>(*source) { <span class="comment">// no fall-through in this inner switch</span>
<a name="l01316"></a>01316         <span class="keywordflow">case</span> 0xE0: <span class="keywordflow">if</span>(JK_EXPECT_F(a &lt; 0xA0)) { <span class="keywordflow">return</span>(0); } <span class="keywordflow">break</span>;
<a name="l01317"></a>01317         <span class="keywordflow">case</span> 0xED: <span class="keywordflow">if</span>(JK_EXPECT_F(a &gt; 0x9F)) { <span class="keywordflow">return</span>(0); } <span class="keywordflow">break</span>;
<a name="l01318"></a>01318         <span class="keywordflow">case</span> 0xF0: <span class="keywordflow">if</span>(JK_EXPECT_F(a &lt; 0x90)) { <span class="keywordflow">return</span>(0); } <span class="keywordflow">break</span>;
<a name="l01319"></a>01319         <span class="keywordflow">case</span> 0xF4: <span class="keywordflow">if</span>(JK_EXPECT_F(a &gt; 0x8F)) { <span class="keywordflow">return</span>(0); } <span class="keywordflow">break</span>;
<a name="l01320"></a>01320         <span class="keywordflow">default</span>:   <span class="keywordflow">if</span>(JK_EXPECT_F(a &lt; 0x80)) { <span class="keywordflow">return</span>(0); }
<a name="l01321"></a>01321       }
<a name="l01322"></a>01322       
<a name="l01323"></a>01323     <span class="keywordflow">case</span> 1: <span class="keywordflow">if</span>(JK_EXPECT_F((JK_EXPECT_T(*source &lt; 0xC2)) &amp;&amp; JK_EXPECT_F(*source &gt;= 0x80))) { <span class="keywordflow">return</span>(0); }
<a name="l01324"></a>01324   }
<a name="l01325"></a>01325 
<a name="l01326"></a>01326   <span class="keywordflow">if</span>(JK_EXPECT_F(*source &gt; 0xF4)) { <span class="keywordflow">return</span>(0); }
<a name="l01327"></a>01327 
<a name="l01328"></a>01328   <span class="keywordflow">return</span>(1);
<a name="l01329"></a>01329 }
<a name="l01330"></a>01330 
<a name="l01331"></a>01331 <span class="keyword">static</span> ConversionResult ConvertSingleCodePointInUTF8(<span class="keyword">const</span> UTF8 *sourceStart, <span class="keyword">const</span> UTF8 *sourceEnd, UTF8 <span class="keyword">const</span> **nextUTF8, UTF32 *convertedUTF32) {
<a name="l01332"></a>01332   ConversionResult result = conversionOK;
<a name="l01333"></a>01333   <span class="keyword">const</span> UTF8 *source = sourceStart;
<a name="l01334"></a>01334   UTF32 ch = 0UL;
<a name="l01335"></a>01335 
<a name="l01336"></a>01336 <span class="preprocessor">#if !defined(JK_FAST_TRAILING_BYTES)</span>
<a name="l01337"></a>01337 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> extraBytesToRead = trailingBytesForUTF8[*source];
<a name="l01338"></a>01338 <span class="preprocessor">#else</span>
<a name="l01339"></a>01339 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> extraBytesToRead = __builtin_clz(((*source)^0xff) &lt;&lt; 25);
<a name="l01340"></a>01340 <span class="preprocessor">#endif</span>
<a name="l01341"></a>01341 <span class="preprocessor"></span>
<a name="l01342"></a>01342   <span class="keywordflow">if</span>(JK_EXPECT_F((source + extraBytesToRead + 1) &gt; sourceEnd) || JK_EXPECT_F(!isLegalUTF8(source, extraBytesToRead + 1))) {
<a name="l01343"></a>01343     source++;
<a name="l01344"></a>01344     <span class="keywordflow">while</span>((source &lt; sourceEnd) &amp;&amp; (((*source) &amp; 0xc0) == 0x80) &amp;&amp; ((source - sourceStart) &lt; (extraBytesToRead + 1))) { source++; } 
<a name="l01345"></a>01345     NSCParameterAssert(source &lt;= sourceEnd);
<a name="l01346"></a>01346     result = ((source &lt; sourceEnd) &amp;&amp; (((*source) &amp; 0xc0) != 0x80)) ? sourceIllegal : ((sourceStart + extraBytesToRead + 1) &gt; sourceEnd) ? sourceExhausted : sourceIllegal;
<a name="l01347"></a>01347     ch = UNI_REPLACEMENT_CHAR;
<a name="l01348"></a>01348     <span class="keywordflow">goto</span> finished;
<a name="l01349"></a>01349   }
<a name="l01350"></a>01350 
<a name="l01351"></a>01351   <span class="keywordflow">switch</span>(extraBytesToRead) { <span class="comment">// The cases all fall through.</span>
<a name="l01352"></a>01352     <span class="keywordflow">case</span> 5: ch += *source++; ch &lt;&lt;= 6;
<a name="l01353"></a>01353     <span class="keywordflow">case</span> 4: ch += *source++; ch &lt;&lt;= 6;
<a name="l01354"></a>01354     <span class="keywordflow">case</span> 3: ch += *source++; ch &lt;&lt;= 6;
<a name="l01355"></a>01355     <span class="keywordflow">case</span> 2: ch += *source++; ch &lt;&lt;= 6;
<a name="l01356"></a>01356     <span class="keywordflow">case</span> 1: ch += *source++; ch &lt;&lt;= 6;
<a name="l01357"></a>01357     <span class="keywordflow">case</span> 0: ch += *source++;
<a name="l01358"></a>01358   }
<a name="l01359"></a>01359   ch -= offsetsFromUTF8[extraBytesToRead];
<a name="l01360"></a>01360 
<a name="l01361"></a>01361   result = isValidCodePoint(&amp;ch);
<a name="l01362"></a>01362   
<a name="l01363"></a>01363  finished:
<a name="l01364"></a>01364   *nextUTF8       = source;
<a name="l01365"></a>01365   *convertedUTF32 = ch;
<a name="l01366"></a>01366   
<a name="l01367"></a>01367   <span class="keywordflow">return</span>(result);
<a name="l01368"></a>01368 }
<a name="l01369"></a>01369 
<a name="l01370"></a>01370 
<a name="l01371"></a>01371 <span class="keyword">static</span> ConversionResult ConvertUTF32toUTF8 (UTF32 u32CodePoint, UTF8 **targetStart, UTF8 *targetEnd) {
<a name="l01372"></a>01372   <span class="keyword">const</span> UTF32       byteMask     = 0xBF, byteMark = 0x80;
<a name="l01373"></a>01373   ConversionResult  result       = conversionOK;
<a name="l01374"></a>01374   UTF8             *target       = *targetStart;
<a name="l01375"></a>01375   UTF32             ch           = u32CodePoint;
<a name="l01376"></a>01376   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>    bytesToWrite = 0;
<a name="l01377"></a>01377 
<a name="l01378"></a>01378   result = isValidCodePoint(&amp;ch);
<a name="l01379"></a>01379 
<a name="l01380"></a>01380   <span class="comment">// Figure out how many bytes the result will require. Turn any illegally large UTF32 things (&gt; Plane 17) into replacement chars.</span>
<a name="l01381"></a>01381        <span class="keywordflow">if</span>(ch &lt; (UTF32)0x80)          { bytesToWrite = 1; }
<a name="l01382"></a>01382   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ch &lt; (UTF32)0x800)         { bytesToWrite = 2; }
<a name="l01383"></a>01383   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ch &lt; (UTF32)0x10000)       { bytesToWrite = 3; }
<a name="l01384"></a>01384   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ch &lt;= UNI_MAX_LEGAL_UTF32) { bytesToWrite = 4; }
<a name="l01385"></a>01385   <span class="keywordflow">else</span> {                               bytesToWrite = 3; ch = UNI_REPLACEMENT_CHAR; result = sourceIllegal; }
<a name="l01386"></a>01386         
<a name="l01387"></a>01387   target += bytesToWrite;
<a name="l01388"></a>01388   <span class="keywordflow">if</span> (target &gt; targetEnd) { target -= bytesToWrite; result = targetExhausted; <span class="keywordflow">goto</span> finished; }
<a name="l01389"></a>01389 
<a name="l01390"></a>01390   <span class="keywordflow">switch</span> (bytesToWrite) { <span class="comment">// note: everything falls through.</span>
<a name="l01391"></a>01391     <span class="keywordflow">case</span> 4: *--target = (UTF8)((ch | byteMark) &amp; byteMask); ch &gt;&gt;= 6;
<a name="l01392"></a>01392     <span class="keywordflow">case</span> 3: *--target = (UTF8)((ch | byteMark) &amp; byteMask); ch &gt;&gt;= 6;
<a name="l01393"></a>01393     <span class="keywordflow">case</span> 2: *--target = (UTF8)((ch | byteMark) &amp; byteMask); ch &gt;&gt;= 6;
<a name="l01394"></a>01394     <span class="keywordflow">case</span> 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);
<a name="l01395"></a>01395   }
<a name="l01396"></a>01396 
<a name="l01397"></a>01397   target += bytesToWrite;
<a name="l01398"></a>01398 
<a name="l01399"></a>01399  finished:
<a name="l01400"></a>01400   *targetStart = target;
<a name="l01401"></a>01401   <span class="keywordflow">return</span>(result);
<a name="l01402"></a>01402 }
<a name="l01403"></a>01403 
<a name="l01404"></a>01404 JK_STATIC_INLINE <span class="keywordtype">int</span> jk_string_add_unicodeCodePoint(JKParseState *parseState, uint32_t unicodeCodePoint, <span class="keywordtype">size_t</span> *tokenBufferIdx, JKHash *stringHash) {
<a name="l01405"></a>01405   UTF8             *u8s = &amp;parseState-&gt;token.tokenBuffer.bytes.ptr[*tokenBufferIdx];
<a name="l01406"></a>01406   ConversionResult  result;
<a name="l01407"></a>01407 
<a name="l01408"></a>01408   <span class="keywordflow">if</span>((result = ConvertUTF32toUTF8(unicodeCodePoint, &amp;u8s, (parseState-&gt;token.tokenBuffer.bytes.ptr + parseState-&gt;token.tokenBuffer.bytes.length))) != conversionOK) { <span class="keywordflow">if</span>(result == targetExhausted) { <span class="keywordflow">return</span>(1); } }
<a name="l01409"></a>01409   <span class="keywordtype">size_t</span> utf8len = u8s - &amp;parseState-&gt;token.tokenBuffer.bytes.ptr[*tokenBufferIdx], nextIdx = (*tokenBufferIdx) + utf8len;
<a name="l01410"></a>01410   
<a name="l01411"></a>01411   <span class="keywordflow">while</span>(*tokenBufferIdx &lt; nextIdx) { *stringHash = calculateHash(*stringHash, parseState-&gt;token.tokenBuffer.bytes.ptr[(*tokenBufferIdx)++]); }
<a name="l01412"></a>01412 
<a name="l01413"></a>01413   <span class="keywordflow">return</span>(0);
<a name="l01414"></a>01414 }
<a name="l01415"></a>01415 
<a name="l01417"></a>01417 <span class="preprocessor">#pragma mark -</span>
<a name="l01418"></a>01418 <span class="preprocessor"></span><span class="preprocessor">#pragma mark Decoding / parsing / deserializing functions</span>
<a name="l01419"></a>01419 <span class="preprocessor"></span>
<a name="l01420"></a>01420 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_parse_string(JKParseState *parseState) {
<a name="l01421"></a>01421   NSCParameterAssert((parseState != NULL) &amp;&amp; (JK_AT_STRING_PTR(parseState) &lt;= JK_END_STRING_PTR(parseState)));
<a name="l01422"></a>01422   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *stringStart       = JK_AT_STRING_PTR(parseState) + 1;
<a name="l01423"></a>01423   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *endOfBuffer       = JK_END_STRING_PTR(parseState);
<a name="l01424"></a>01424   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *atStringCharacter = stringStart;
<a name="l01425"></a>01425   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>       *tokenBuffer       = parseState-&gt;token.tokenBuffer.bytes.ptr;
<a name="l01426"></a>01426   <span class="keywordtype">size_t</span>               tokenStartIndex   = parseState-&gt;atIndex;
<a name="l01427"></a>01427   <span class="keywordtype">size_t</span>               tokenBufferIdx    = 0UL;
<a name="l01428"></a>01428 
<a name="l01429"></a>01429   <span class="keywordtype">int</span>      onlySimpleString        = 1,  stringState     = JSONStringStateStart;
<a name="l01430"></a>01430   uint16_t escapedUnicode1         = 0U, escapedUnicode2 = 0U;
<a name="l01431"></a>01431   uint32_t escapedUnicodeCodePoint = 0U;
<a name="l01432"></a>01432   JKHash   stringHash              = JK_HASH_INIT;
<a name="l01433"></a>01433     
<a name="l01434"></a>01434   <span class="keywordflow">while</span>(1) {
<a name="l01435"></a>01435     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> currentChar;
<a name="l01436"></a>01436 
<a name="l01437"></a>01437     <span class="keywordflow">if</span>(JK_EXPECT_F(atStringCharacter == endOfBuffer)) { <span class="comment">/* XXX Add error message */</span> stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; }
<a name="l01438"></a>01438     
<a name="l01439"></a>01439     <span class="keywordflow">if</span>(JK_EXPECT_F((currentChar = *atStringCharacter++) &gt;= 0x80UL)) {
<a name="l01440"></a>01440       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *nextValidCharacter = NULL;
<a name="l01441"></a>01441       UTF32                u32ch              = 0U;
<a name="l01442"></a>01442       ConversionResult     result;
<a name="l01443"></a>01443 
<a name="l01444"></a>01444       <span class="keywordflow">if</span>(JK_EXPECT_F((result = ConvertSingleCodePointInUTF8(atStringCharacter - 1, endOfBuffer, (UTF8 <span class="keyword">const</span> **)&amp;nextValidCharacter, &amp;u32ch)) != conversionOK)) { <span class="keywordflow">goto</span> switchToSlowPath; }
<a name="l01445"></a>01445       stringHash = calculateHash(stringHash, currentChar);
<a name="l01446"></a>01446       <span class="keywordflow">while</span>(atStringCharacter &lt; nextValidCharacter) { NSCParameterAssert(JK_AT_STRING_PTR(parseState) &lt;= JK_END_STRING_PTR(parseState)); stringHash = calculateHash(stringHash, *atStringCharacter++); }
<a name="l01447"></a>01447       <span class="keywordflow">continue</span>;
<a name="l01448"></a>01448     } <span class="keywordflow">else</span> {
<a name="l01449"></a>01449       <span class="keywordflow">if</span>(JK_EXPECT_F(currentChar == (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)<span class="charliteral">&#39;&quot;&#39;</span>)) { stringState = JSONStringStateFinished; <span class="keywordflow">goto</span> finishedParsing; }
<a name="l01450"></a>01450 
<a name="l01451"></a>01451       <span class="keywordflow">if</span>(JK_EXPECT_F(currentChar == (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)<span class="charliteral">&#39;\\&#39;</span>)) {
<a name="l01452"></a>01452       switchToSlowPath:
<a name="l01453"></a>01453         onlySimpleString = 0;
<a name="l01454"></a>01454         stringState      = JSONStringStateParsing;
<a name="l01455"></a>01455         tokenBufferIdx   = (atStringCharacter - stringStart) - 1L;
<a name="l01456"></a>01456         <span class="keywordflow">if</span>(JK_EXPECT_F((tokenBufferIdx + 16UL) &gt; parseState-&gt;token.tokenBuffer.bytes.length)) { <span class="keywordflow">if</span>((tokenBuffer = jk_managedBuffer_resize(&amp;parseState-&gt;token.tokenBuffer, tokenBufferIdx + 1024UL)) == NULL) { jk_error(parseState, <span class="stringliteral">@&quot;Internal error: Unable to resize temporary buffer. %@ line #%ld&quot;</span>, [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithUTF8String:__FILE__], (<span class="keywordtype">long</span>)__LINE__); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; } }
<a name="l01457"></a>01457         memcpy(tokenBuffer, stringStart, tokenBufferIdx);
<a name="l01458"></a>01458         <span class="keywordflow">goto</span> slowMatch;
<a name="l01459"></a>01459       }
<a name="l01460"></a>01460 
<a name="l01461"></a>01461       <span class="keywordflow">if</span>(JK_EXPECT_F(currentChar &lt; 0x20UL)) { jk_error(parseState, <span class="stringliteral">@&quot;Invalid character &lt; 0x20 found in string: 0x%2.2x.&quot;</span>, currentChar); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; }
<a name="l01462"></a>01462 
<a name="l01463"></a>01463       stringHash = calculateHash(stringHash, currentChar);
<a name="l01464"></a>01464     }
<a name="l01465"></a>01465   }
<a name="l01466"></a>01466 
<a name="l01467"></a>01467  slowMatch:
<a name="l01468"></a>01468 
<a name="l01469"></a>01469   <span class="keywordflow">for</span>(atStringCharacter = (stringStart + ((atStringCharacter - stringStart) - 1L)); (atStringCharacter &lt; endOfBuffer) &amp;&amp; (tokenBufferIdx &lt; parseState-&gt;token.tokenBuffer.bytes.length); atStringCharacter++) {
<a name="l01470"></a>01470     <span class="keywordflow">if</span>((tokenBufferIdx + 16UL) &gt; parseState-&gt;token.tokenBuffer.bytes.length) { <span class="keywordflow">if</span>((tokenBuffer = jk_managedBuffer_resize(&amp;parseState-&gt;token.tokenBuffer, tokenBufferIdx + 1024UL)) == NULL) { jk_error(parseState, <span class="stringliteral">@&quot;Internal error: Unable to resize temporary buffer. %@ line #%ld&quot;</span>, [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithUTF8String:__FILE__], (<span class="keywordtype">long</span>)__LINE__); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; } }
<a name="l01471"></a>01471 
<a name="l01472"></a>01472     NSCParameterAssert(tokenBufferIdx &lt; parseState-&gt;token.tokenBuffer.bytes.length);
<a name="l01473"></a>01473 
<a name="l01474"></a>01474     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> currentChar = (*atStringCharacter), escapedChar;
<a name="l01475"></a>01475 
<a name="l01476"></a>01476     <span class="keywordflow">if</span>(JK_EXPECT_T(stringState == JSONStringStateParsing)) {
<a name="l01477"></a>01477       <span class="keywordflow">if</span>(JK_EXPECT_T(currentChar &gt;= 0x20UL)) {
<a name="l01478"></a>01478         <span class="keywordflow">if</span>(JK_EXPECT_T(currentChar &lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)0x80)) { <span class="comment">// Not a UTF8 sequence</span>
<a name="l01479"></a>01479           <span class="keywordflow">if</span>(JK_EXPECT_F(currentChar == (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)<span class="charliteral">&#39;&quot;&#39;</span>))  { stringState = JSONStringStateFinished; atStringCharacter++; <span class="keywordflow">goto</span> finishedParsing; }
<a name="l01480"></a>01480           <span class="keywordflow">if</span>(JK_EXPECT_F(currentChar == (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)<span class="charliteral">&#39;\\&#39;</span>)) { stringState = JSONStringStateEscape; <span class="keywordflow">continue</span>; }
<a name="l01481"></a>01481           stringHash = calculateHash(stringHash, currentChar);
<a name="l01482"></a>01482           tokenBuffer[tokenBufferIdx++] = currentChar;
<a name="l01483"></a>01483           <span class="keywordflow">continue</span>;
<a name="l01484"></a>01484         } <span class="keywordflow">else</span> { <span class="comment">// UTF8 sequence</span>
<a name="l01485"></a>01485           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *nextValidCharacter = NULL;
<a name="l01486"></a>01486           UTF32                u32ch              = 0U;
<a name="l01487"></a>01487           ConversionResult     result;
<a name="l01488"></a>01488           
<a name="l01489"></a>01489           <span class="keywordflow">if</span>(JK_EXPECT_F((result = ConvertSingleCodePointInUTF8(atStringCharacter, endOfBuffer, (UTF8 <span class="keyword">const</span> **)&amp;nextValidCharacter, &amp;u32ch)) != conversionOK)) {
<a name="l01490"></a>01490             <span class="keywordflow">if</span>((result == sourceIllegal) &amp;&amp; ((parseState-&gt;parseOptionFlags &amp; JKParseOptionLooseUnicode) == 0)) { jk_error(parseState, <span class="stringliteral">@&quot;Illegal UTF8 sequence found in \&quot;</span>\<span class="stringliteral">&quot; string.&quot;</span>);              stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; }
<a name="l01491"></a>01491             <span class="keywordflow">if</span>(result == sourceExhausted)                                                                      { jk_error(parseState, <span class="stringliteral">@&quot;End of buffer reached while parsing UTF8 in \&quot;</span>\<span class="stringliteral">&quot; string.&quot;</span>); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; }
<a name="l01492"></a>01492             <span class="keywordflow">if</span>(jk_string_add_unicodeCodePoint(parseState, u32ch, &amp;tokenBufferIdx, &amp;stringHash))                { jk_error(parseState, <span class="stringliteral">@&quot;Internal error: Unable to add UTF8 sequence to internal string buffer. %@ line #%ld&quot;</span>, [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithUTF8String:__FILE__], (<span class="keywordtype">long</span>)__LINE__); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; }
<a name="l01493"></a>01493             atStringCharacter = nextValidCharacter - 1;
<a name="l01494"></a>01494             <span class="keywordflow">continue</span>;
<a name="l01495"></a>01495           } <span class="keywordflow">else</span> {
<a name="l01496"></a>01496             <span class="keywordflow">while</span>(atStringCharacter &lt; nextValidCharacter) { tokenBuffer[tokenBufferIdx++] = *atStringCharacter; stringHash = calculateHash(stringHash, *atStringCharacter++); }
<a name="l01497"></a>01497             atStringCharacter--;
<a name="l01498"></a>01498             <span class="keywordflow">continue</span>;
<a name="l01499"></a>01499           }
<a name="l01500"></a>01500         }
<a name="l01501"></a>01501       } <span class="keywordflow">else</span> { <span class="comment">// currentChar &lt; 0x20</span>
<a name="l01502"></a>01502         jk_error(parseState, <span class="stringliteral">@&quot;Invalid character &lt; 0x20 found in string: 0x%2.2x.&quot;</span>, currentChar); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing;
<a name="l01503"></a>01503       }
<a name="l01504"></a>01504 
<a name="l01505"></a>01505     } <span class="keywordflow">else</span> { <span class="comment">// stringState != JSONStringStateParsing</span>
<a name="l01506"></a>01506       <span class="keywordtype">int</span> isSurrogate = 1;
<a name="l01507"></a>01507 
<a name="l01508"></a>01508       <span class="keywordflow">switch</span>(stringState) {
<a name="l01509"></a>01509         <span class="keywordflow">case</span> JSONStringStateEscape:
<a name="l01510"></a>01510           <span class="keywordflow">switch</span>(currentChar) {
<a name="l01511"></a>01511             <span class="keywordflow">case</span> <span class="charliteral">&#39;u&#39;</span>: escapedUnicode1 = 0U; escapedUnicode2 = 0U; escapedUnicodeCodePoint = 0U; stringState = JSONStringStateEscapedUnicode1; <span class="keywordflow">break</span>;
<a name="l01512"></a>01512 
<a name="l01513"></a>01513             <span class="keywordflow">case</span> <span class="charliteral">&#39;b&#39;</span>:  escapedChar = <span class="charliteral">&#39;\b&#39;</span>; <span class="keywordflow">goto</span> parsedEscapedChar;
<a name="l01514"></a>01514             <span class="keywordflow">case</span> <span class="charliteral">&#39;f&#39;</span>:  escapedChar = <span class="charliteral">&#39;\f&#39;</span>; <span class="keywordflow">goto</span> parsedEscapedChar;
<a name="l01515"></a>01515             <span class="keywordflow">case</span> <span class="charliteral">&#39;n&#39;</span>:  escapedChar = <span class="charliteral">&#39;\n&#39;</span>; <span class="keywordflow">goto</span> parsedEscapedChar;
<a name="l01516"></a>01516             <span class="keywordflow">case</span> <span class="charliteral">&#39;r&#39;</span>:  escapedChar = <span class="charliteral">&#39;\r&#39;</span>; <span class="keywordflow">goto</span> parsedEscapedChar;
<a name="l01517"></a>01517             <span class="keywordflow">case</span> <span class="charliteral">&#39;t&#39;</span>:  escapedChar = <span class="charliteral">&#39;\t&#39;</span>; <span class="keywordflow">goto</span> parsedEscapedChar;
<a name="l01518"></a>01518             <span class="keywordflow">case</span> <span class="charliteral">&#39;\\&#39;</span>: escapedChar = <span class="charliteral">&#39;\\&#39;</span>; <span class="keywordflow">goto</span> parsedEscapedChar;
<a name="l01519"></a>01519             <span class="keywordflow">case</span> <span class="charliteral">&#39;/&#39;</span>:  escapedChar = <span class="charliteral">&#39;/&#39;</span>;  <span class="keywordflow">goto</span> parsedEscapedChar;
<a name="l01520"></a>01520             <span class="keywordflow">case</span> <span class="charliteral">&#39;&quot;&#39;</span>:  escapedChar = <span class="charliteral">&#39;&quot;&#39;</span>;  <span class="keywordflow">goto</span> parsedEscapedChar;
<a name="l01521"></a>01521               
<a name="l01522"></a>01522             parsedEscapedChar:
<a name="l01523"></a>01523               stringState = JSONStringStateParsing;
<a name="l01524"></a>01524               stringHash  = calculateHash(stringHash, escapedChar);
<a name="l01525"></a>01525               tokenBuffer[tokenBufferIdx++] = escapedChar;
<a name="l01526"></a>01526               <span class="keywordflow">break</span>;
<a name="l01527"></a>01527               
<a name="l01528"></a>01528             <span class="keywordflow">default</span>: jk_error(parseState, <span class="stringliteral">@&quot;Invalid escape sequence found in \&quot;</span>\<span class="stringliteral">&quot; string.&quot;</span>); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; <span class="keywordflow">break</span>;
<a name="l01529"></a>01529           }
<a name="l01530"></a>01530           <span class="keywordflow">break</span>;
<a name="l01531"></a>01531 
<a name="l01532"></a>01532         <span class="keywordflow">case</span> JSONStringStateEscapedUnicode1:
<a name="l01533"></a>01533         <span class="keywordflow">case</span> JSONStringStateEscapedUnicode2:
<a name="l01534"></a>01534         <span class="keywordflow">case</span> JSONStringStateEscapedUnicode3:
<a name="l01535"></a>01535         <span class="keywordflow">case</span> JSONStringStateEscapedUnicode4:           isSurrogate = 0;
<a name="l01536"></a>01536         <span class="keywordflow">case</span> JSONStringStateEscapedUnicodeSurrogate1:
<a name="l01537"></a>01537         <span class="keywordflow">case</span> JSONStringStateEscapedUnicodeSurrogate2:
<a name="l01538"></a>01538         <span class="keywordflow">case</span> JSONStringStateEscapedUnicodeSurrogate3:
<a name="l01539"></a>01539         <span class="keywordflow">case</span> JSONStringStateEscapedUnicodeSurrogate4:
<a name="l01540"></a>01540           {
<a name="l01541"></a>01541             uint16_t hexValue = 0U;
<a name="l01542"></a>01542 
<a name="l01543"></a>01543             <span class="keywordflow">switch</span>(currentChar) {
<a name="l01544"></a>01544               <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span> ... <span class="charliteral">&#39;9&#39;</span>: hexValue =  currentChar - &#39;0&#39;;        <span class="keywordflow">goto</span> parsedHex;
<a name="l01545"></a>01545               <span class="keywordflow">case</span> <span class="charliteral">&#39;a&#39;</span> ... <span class="charliteral">&#39;f&#39;</span>: hexValue = (currentChar - &#39;a&#39;) + 10U; <span class="keywordflow">goto</span> parsedHex;
<a name="l01546"></a>01546               <span class="keywordflow">case</span> <span class="charliteral">&#39;A&#39;</span> ... <span class="charliteral">&#39;F&#39;</span>: hexValue = (currentChar - &#39;A&#39;) + 10U; <span class="keywordflow">goto</span> parsedHex;
<a name="l01547"></a>01547                 
<a name="l01548"></a>01548               parsedHex:
<a name="l01549"></a>01549               <span class="keywordflow">if</span>(!isSurrogate) { escapedUnicode1 = (escapedUnicode1 &lt;&lt; 4) | hexValue; } <span class="keywordflow">else</span> { escapedUnicode2 = (escapedUnicode2 &lt;&lt; 4) | hexValue; }
<a name="l01550"></a>01550                 
<a name="l01551"></a>01551               <span class="keywordflow">if</span>(stringState == JSONStringStateEscapedUnicode4) {
<a name="l01552"></a>01552                 <span class="keywordflow">if</span>(((escapedUnicode1 &gt;= 0xD800U) &amp;&amp; (escapedUnicode1 &lt; 0xE000U))) {
<a name="l01553"></a>01553                   <span class="keywordflow">if</span>((escapedUnicode1 &gt;= 0xD800U) &amp;&amp; (escapedUnicode1 &lt; 0xDC00U)) { stringState = JSONStringStateEscapedNeedEscapeForSurrogate; }
<a name="l01554"></a>01554                   <span class="keywordflow">else</span> <span class="keywordflow">if</span>((escapedUnicode1 &gt;= 0xDC00U) &amp;&amp; (escapedUnicode1 &lt; 0xE000U)) { 
<a name="l01555"></a>01555                     <span class="keywordflow">if</span>((parseState-&gt;parseOptionFlags &amp; JKParseOptionLooseUnicode)) { escapedUnicodeCodePoint = UNI_REPLACEMENT_CHAR; }
<a name="l01556"></a>01556                     <span class="keywordflow">else</span> { jk_error(parseState, <span class="stringliteral">@&quot;Illegal \\u Unicode escape sequence.&quot;</span>); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; }
<a name="l01557"></a>01557                   }
<a name="l01558"></a>01558                 }
<a name="l01559"></a>01559                 <span class="keywordflow">else</span> { escapedUnicodeCodePoint = escapedUnicode1; }
<a name="l01560"></a>01560               }
<a name="l01561"></a>01561 
<a name="l01562"></a>01562               <span class="keywordflow">if</span>(stringState == JSONStringStateEscapedUnicodeSurrogate4) {
<a name="l01563"></a>01563                 <span class="keywordflow">if</span>((escapedUnicode2 &lt; 0xdc00) || (escapedUnicode2 &gt; 0xdfff)) {
<a name="l01564"></a>01564                   <span class="keywordflow">if</span>((parseState-&gt;parseOptionFlags &amp; JKParseOptionLooseUnicode)) { escapedUnicodeCodePoint = UNI_REPLACEMENT_CHAR; }
<a name="l01565"></a>01565                   <span class="keywordflow">else</span> { jk_error(parseState, <span class="stringliteral">@&quot;Illegal \\u Unicode escape sequence.&quot;</span>); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; }
<a name="l01566"></a>01566                 }
<a name="l01567"></a>01567                 <span class="keywordflow">else</span> { escapedUnicodeCodePoint = ((escapedUnicode1 - 0xd800) * 0x400) + (escapedUnicode2 - 0xdc00) + 0x10000; }
<a name="l01568"></a>01568               }
<a name="l01569"></a>01569                 
<a name="l01570"></a>01570               <span class="keywordflow">if</span>((stringState == JSONStringStateEscapedUnicode4) || (stringState == JSONStringStateEscapedUnicodeSurrogate4)) { 
<a name="l01571"></a>01571                 <span class="keywordflow">if</span>((isValidCodePoint(&amp;escapedUnicodeCodePoint) == sourceIllegal) &amp;&amp; ((parseState-&gt;parseOptionFlags &amp; JKParseOptionLooseUnicode) == 0)) { jk_error(parseState, <span class="stringliteral">@&quot;Illegal \\u Unicode escape sequence.&quot;</span>); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; }
<a name="l01572"></a>01572                 stringState = JSONStringStateParsing;
<a name="l01573"></a>01573                 <span class="keywordflow">if</span>(jk_string_add_unicodeCodePoint(parseState, escapedUnicodeCodePoint, &amp;tokenBufferIdx, &amp;stringHash)) { jk_error(parseState, <span class="stringliteral">@&quot;Internal error: Unable to add UTF8 sequence to internal string buffer. %@ line #%ld&quot;</span>, [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithUTF8String:__FILE__], (<span class="keywordtype">long</span>)__LINE__); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; }
<a name="l01574"></a>01574               }
<a name="l01575"></a>01575               <span class="keywordflow">else</span> <span class="keywordflow">if</span>((stringState &gt;= JSONStringStateEscapedUnicode1) &amp;&amp; (stringState &lt;= JSONStringStateEscapedUnicodeSurrogate4)) { stringState++; }
<a name="l01576"></a>01576               <span class="keywordflow">break</span>;
<a name="l01577"></a>01577 
<a name="l01578"></a>01578               <span class="keywordflow">default</span>: jk_error(parseState, <span class="stringliteral">@&quot;Unexpected character found in \\u Unicode escape sequence.  Found &#39;%c&#39;, expected [0-9a-fA-F].&quot;</span>, currentChar); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; <span class="keywordflow">break</span>;
<a name="l01579"></a>01579             }
<a name="l01580"></a>01580           }
<a name="l01581"></a>01581           <span class="keywordflow">break</span>;
<a name="l01582"></a>01582 
<a name="l01583"></a>01583         <span class="keywordflow">case</span> JSONStringStateEscapedNeedEscapeForSurrogate:
<a name="l01584"></a>01584           <span class="keywordflow">if</span>(currentChar == <span class="charliteral">&#39;\\&#39;</span>) { stringState = JSONStringStateEscapedNeedEscapedUForSurrogate; }
<a name="l01585"></a>01585           <span class="keywordflow">else</span> { 
<a name="l01586"></a>01586             <span class="keywordflow">if</span>((parseState-&gt;parseOptionFlags &amp; JKParseOptionLooseUnicode) == 0) { jk_error(parseState, <span class="stringliteral">@&quot;Required a second \\u Unicode escape sequence following a surrogate \\u Unicode escape sequence.&quot;</span>); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; }
<a name="l01587"></a>01587             <span class="keywordflow">else</span> { stringState = JSONStringStateParsing; atStringCharacter--;    <span class="keywordflow">if</span>(jk_string_add_unicodeCodePoint(parseState, UNI_REPLACEMENT_CHAR, &amp;tokenBufferIdx, &amp;stringHash)) { jk_error(parseState, <span class="stringliteral">@&quot;Internal error: Unable to add UTF8 sequence to internal string buffer. %@ line #%ld&quot;</span>, [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithUTF8String:__FILE__], (<span class="keywordtype">long</span>)__LINE__); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; } }
<a name="l01588"></a>01588           }
<a name="l01589"></a>01589           <span class="keywordflow">break</span>;
<a name="l01590"></a>01590 
<a name="l01591"></a>01591         <span class="keywordflow">case</span> JSONStringStateEscapedNeedEscapedUForSurrogate:
<a name="l01592"></a>01592           <span class="keywordflow">if</span>(currentChar == <span class="charliteral">&#39;u&#39;</span>) { stringState = JSONStringStateEscapedUnicodeSurrogate1; }
<a name="l01593"></a>01593           <span class="keywordflow">else</span> { 
<a name="l01594"></a>01594             <span class="keywordflow">if</span>((parseState-&gt;parseOptionFlags &amp; JKParseOptionLooseUnicode) == 0) { jk_error(parseState, <span class="stringliteral">@&quot;Required a second \\u Unicode escape sequence following a surrogate \\u Unicode escape sequence.&quot;</span>); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; }
<a name="l01595"></a>01595             <span class="keywordflow">else</span> { stringState = JSONStringStateParsing; atStringCharacter -= 2; <span class="keywordflow">if</span>(jk_string_add_unicodeCodePoint(parseState, UNI_REPLACEMENT_CHAR, &amp;tokenBufferIdx, &amp;stringHash)) { jk_error(parseState, <span class="stringliteral">@&quot;Internal error: Unable to add UTF8 sequence to internal string buffer. %@ line #%ld&quot;</span>, [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithUTF8String:__FILE__], (<span class="keywordtype">long</span>)__LINE__); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; } }
<a name="l01596"></a>01596           }
<a name="l01597"></a>01597           <span class="keywordflow">break</span>;
<a name="l01598"></a>01598 
<a name="l01599"></a>01599         <span class="keywordflow">default</span>: jk_error(parseState, <span class="stringliteral">@&quot;Internal error: Unknown stringState. %@ line #%ld&quot;</span>, [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithUTF8String:__FILE__], (<span class="keywordtype">long</span>)__LINE__); stringState = JSONStringStateError; <span class="keywordflow">goto</span> finishedParsing; <span class="keywordflow">break</span>;
<a name="l01600"></a>01600       }
<a name="l01601"></a>01601     }
<a name="l01602"></a>01602   }
<a name="l01603"></a>01603 
<a name="l01604"></a>01604 finishedParsing:
<a name="l01605"></a>01605 
<a name="l01606"></a>01606   <span class="keywordflow">if</span>(JK_EXPECT_T(stringState == JSONStringStateFinished)) {
<a name="l01607"></a>01607     NSCParameterAssert((parseState-&gt;stringBuffer.bytes.ptr + tokenStartIndex) &lt; atStringCharacter);
<a name="l01608"></a>01608 
<a name="l01609"></a>01609     parseState-&gt;token.tokenPtrRange.ptr    = parseState-&gt;stringBuffer.bytes.ptr + tokenStartIndex;
<a name="l01610"></a>01610     parseState-&gt;token.tokenPtrRange.length = (atStringCharacter - parseState-&gt;token.tokenPtrRange.ptr);
<a name="l01611"></a>01611 
<a name="l01612"></a>01612     <span class="keywordflow">if</span>(JK_EXPECT_T(onlySimpleString)) {
<a name="l01613"></a>01613       NSCParameterAssert(((parseState-&gt;token.tokenPtrRange.ptr + 1) &lt; endOfBuffer) &amp;&amp; (parseState-&gt;token.tokenPtrRange.length &gt;= 2UL) &amp;&amp; (((parseState-&gt;token.tokenPtrRange.ptr + 1) + (parseState-&gt;token.tokenPtrRange.length - 2)) &lt; endOfBuffer));
<a name="l01614"></a>01614       parseState-&gt;token.value.ptrRange.ptr    = parseState-&gt;token.tokenPtrRange.ptr    + 1;
<a name="l01615"></a>01615       parseState-&gt;token.value.ptrRange.length = parseState-&gt;token.tokenPtrRange.length - 2UL;
<a name="l01616"></a>01616     } <span class="keywordflow">else</span> {
<a name="l01617"></a>01617       parseState-&gt;token.value.ptrRange.ptr    = parseState-&gt;token.tokenBuffer.bytes.ptr;
<a name="l01618"></a>01618       parseState-&gt;token.value.ptrRange.length = tokenBufferIdx;
<a name="l01619"></a>01619     }
<a name="l01620"></a>01620     
<a name="l01621"></a>01621     parseState-&gt;token.value.hash = stringHash;
<a name="l01622"></a>01622     parseState-&gt;token.value.type = JKValueTypeString;
<a name="l01623"></a>01623     parseState-&gt;atIndex          = (atStringCharacter - parseState-&gt;stringBuffer.bytes.ptr);
<a name="l01624"></a>01624   }
<a name="l01625"></a>01625 
<a name="l01626"></a>01626   <span class="keywordflow">if</span>(JK_EXPECT_F(stringState != JSONStringStateFinished)) { jk_error(parseState, <span class="stringliteral">@&quot;Invalid string.&quot;</span>); }
<a name="l01627"></a>01627   <span class="keywordflow">return</span>(JK_EXPECT_T(stringState == JSONStringStateFinished) ? 0 : 1);
<a name="l01628"></a>01628 }
<a name="l01629"></a>01629 
<a name="l01630"></a>01630 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_parse_number(JKParseState *parseState) {
<a name="l01631"></a>01631   NSCParameterAssert((parseState != NULL) &amp;&amp; (JK_AT_STRING_PTR(parseState) &lt;= JK_END_STRING_PTR(parseState)));
<a name="l01632"></a>01632   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *numberStart       = JK_AT_STRING_PTR(parseState);
<a name="l01633"></a>01633   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *endOfBuffer       = JK_END_STRING_PTR(parseState);
<a name="l01634"></a>01634   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *atNumberCharacter = NULL;
<a name="l01635"></a>01635   <span class="keywordtype">int</span>                  numberState       = JSONNumberStateWholeNumberStart, isFloatingPoint = 0, isNegative = 0, backup = 0;
<a name="l01636"></a>01636   <span class="keywordtype">size_t</span>               startingIndex     = parseState-&gt;atIndex;
<a name="l01637"></a>01637   
<a name="l01638"></a>01638   <span class="keywordflow">for</span>(atNumberCharacter = numberStart; (JK_EXPECT_T(atNumberCharacter &lt; endOfBuffer)) &amp;&amp; (JK_EXPECT_T(!(JK_EXPECT_F(numberState == JSONNumberStateFinished) || JK_EXPECT_F(numberState == JSONNumberStateError)))); atNumberCharacter++) {
<a name="l01639"></a>01639     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> currentChar = (<span class="keywordtype">unsigned</span> long)(*atNumberCharacter), lowerCaseCC = currentChar | 0x20UL;
<a name="l01640"></a>01640     
<a name="l01641"></a>01641     <span class="keywordflow">switch</span>(numberState) {
<a name="l01642"></a>01642       <span class="keywordflow">case</span> JSONNumberStateWholeNumberStart: <span class="keywordflow">if</span>   (currentChar == <span class="charliteral">&#39;-&#39;</span>)                                                                              { numberState = JSONNumberStateWholeNumberMinus;      isNegative      = 1; <span class="keywordflow">break</span>; }
<a name="l01643"></a>01643       <span class="keywordflow">case</span> JSONNumberStateWholeNumberMinus: <span class="keywordflow">if</span>   (currentChar == <span class="charliteral">&#39;0&#39;</span>)                                                                              { numberState = JSONNumberStateWholeNumberZero;                            <span class="keywordflow">break</span>; }
<a name="l01644"></a>01644                                        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(  (currentChar &gt;= <span class="charliteral">&#39;1&#39;</span>) &amp;&amp; (currentChar &lt;= <span class="charliteral">&#39;9&#39;</span>))                                                     { numberState = JSONNumberStateWholeNumber;                                <span class="keywordflow">break</span>; }
<a name="l01645"></a>01645                                        <span class="keywordflow">else</span>                                                     { <span class="comment">/* XXX Add error message */</span>                        numberState = JSONNumberStateError;                                      <span class="keywordflow">break</span>; }
<a name="l01646"></a>01646       <span class="keywordflow">case</span> JSONNumberStateExponentStart:    <span class="keywordflow">if</span>(  (currentChar == <span class="charliteral">&#39;+&#39;</span>) || (currentChar == <span class="charliteral">&#39;-&#39;</span>))                                                     { numberState = JSONNumberStateExponentPlusMinus;                          <span class="keywordflow">break</span>; }
<a name="l01647"></a>01647       <span class="keywordflow">case</span> JSONNumberStateFractionalNumberStart:
<a name="l01648"></a>01648       <span class="keywordflow">case</span> JSONNumberStateExponentPlusMinus:<span class="keywordflow">if</span>(!((currentChar &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (currentChar &lt;= <span class="charliteral">&#39;9&#39;</span>))) { <span class="comment">/* XXX Add error message */</span>                        numberState = JSONNumberStateError;                                      <span class="keywordflow">break</span>; }
<a name="l01649"></a>01649                                        <span class="keywordflow">else</span> {                                              <span class="keywordflow">if</span>(numberState == JSONNumberStateFractionalNumberStart) { numberState = JSONNumberStateFractionalNumber; }
<a name="l01650"></a>01650                                                                                            <span class="keywordflow">else</span>                                                    { numberState = JSONNumberStateExponent;         }                         <span class="keywordflow">break</span>; }
<a name="l01651"></a>01651       <span class="keywordflow">case</span> JSONNumberStateWholeNumberZero:
<a name="l01652"></a>01652       <span class="keywordflow">case</span> JSONNumberStateWholeNumber:      <span class="keywordflow">if</span>   (currentChar == <span class="charliteral">&#39;.&#39;</span>)                                                                              { numberState = JSONNumberStateFractionalNumberStart; isFloatingPoint = 1; <span class="keywordflow">break</span>; }
<a name="l01653"></a>01653       <span class="keywordflow">case</span> JSONNumberStateFractionalNumber: <span class="keywordflow">if</span>   (lowerCaseCC == <span class="charliteral">&#39;e&#39;</span>)                                                                              { numberState = JSONNumberStateExponentStart;         isFloatingPoint = 1; <span class="keywordflow">break</span>; }
<a name="l01654"></a>01654       <span class="keywordflow">case</span> JSONNumberStateExponent:         <span class="keywordflow">if</span>(!((currentChar &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (currentChar &lt;= <span class="charliteral">&#39;9&#39;</span>)) || (numberState == JSONNumberStateWholeNumberZero)) { numberState = JSONNumberStateFinished;              backup          = 1; <span class="keywordflow">break</span>; }
<a name="l01655"></a>01655         <span class="keywordflow">break</span>;
<a name="l01656"></a>01656       <span class="keywordflow">default</span>:                                                                                    <span class="comment">/* XXX Add error message */</span>                        numberState = JSONNumberStateError;                                      <span class="keywordflow">break</span>;
<a name="l01657"></a>01657     }
<a name="l01658"></a>01658   }
<a name="l01659"></a>01659   
<a name="l01660"></a>01660   parseState-&gt;token.tokenPtrRange.ptr    = parseState-&gt;stringBuffer.bytes.ptr + startingIndex;
<a name="l01661"></a>01661   parseState-&gt;token.tokenPtrRange.length = (atNumberCharacter - parseState-&gt;token.tokenPtrRange.ptr) - backup;
<a name="l01662"></a>01662   parseState-&gt;atIndex                    = (parseState-&gt;token.tokenPtrRange.ptr + parseState-&gt;token.tokenPtrRange.length) - parseState-&gt;stringBuffer.bytes.ptr;
<a name="l01663"></a>01663 
<a name="l01664"></a>01664   <span class="keywordflow">if</span>(JK_EXPECT_T(numberState == JSONNumberStateFinished)) {
<a name="l01665"></a>01665     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  numberTempBuf[parseState-&gt;token.tokenPtrRange.length + 4UL];
<a name="l01666"></a>01666     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *endOfNumber = NULL;
<a name="l01667"></a>01667 
<a name="l01668"></a>01668     memcpy(numberTempBuf, parseState-&gt;token.tokenPtrRange.ptr, parseState-&gt;token.tokenPtrRange.length);
<a name="l01669"></a>01669     numberTempBuf[parseState-&gt;token.tokenPtrRange.length] = 0;
<a name="l01670"></a>01670 
<a name="l01671"></a>01671     errno = 0;
<a name="l01672"></a>01672     
<a name="l01673"></a>01673     <span class="comment">// Treat &quot;-0&quot; as a floating point number, which is capable of representing negative zeros.</span>
<a name="l01674"></a>01674     <span class="keywordflow">if</span>(JK_EXPECT_F(parseState-&gt;token.tokenPtrRange.length == 2UL) &amp;&amp; JK_EXPECT_F(numberTempBuf[1] == <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; JK_EXPECT_F(isNegative)) { isFloatingPoint = 1; }
<a name="l01675"></a>01675 
<a name="l01676"></a>01676     <span class="keywordflow">if</span>(isFloatingPoint) {
<a name="l01677"></a>01677       parseState-&gt;token.value.number.doubleValue = strtod((<span class="keyword">const</span> <span class="keywordtype">char</span> *)numberTempBuf, (<span class="keywordtype">char</span> **)&amp;endOfNumber); <span class="comment">// strtod is documented to return U+2261 (identical to) 0.0 on an underflow error (along with setting errno to ERANGE).</span>
<a name="l01678"></a>01678       parseState-&gt;token.value.type               = JKValueTypeDouble;
<a name="l01679"></a>01679       parseState-&gt;token.value.ptrRange.ptr       = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)&amp;parseState-&gt;token.value.number.doubleValue;
<a name="l01680"></a>01680       parseState-&gt;token.value.ptrRange.length    = <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>);
<a name="l01681"></a>01681       parseState-&gt;token.value.hash               = (JK_HASH_INIT + parseState-&gt;token.value.type);
<a name="l01682"></a>01682     } <span class="keywordflow">else</span> {
<a name="l01683"></a>01683       <span class="keywordflow">if</span>(isNegative) {
<a name="l01684"></a>01684         parseState-&gt;token.value.number.longLongValue = strtoll((<span class="keyword">const</span> <span class="keywordtype">char</span> *)numberTempBuf, (<span class="keywordtype">char</span> **)&amp;endOfNumber, 10);
<a name="l01685"></a>01685         parseState-&gt;token.value.type                 = JKValueTypeLongLong;
<a name="l01686"></a>01686         parseState-&gt;token.value.ptrRange.ptr         = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)&amp;parseState-&gt;token.value.number.longLongValue;
<a name="l01687"></a>01687         parseState-&gt;token.value.ptrRange.length      = <span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span>);
<a name="l01688"></a>01688         parseState-&gt;token.value.hash                 = (JK_HASH_INIT + parseState-&gt;token.value.type) + (JKHash)parseState-&gt;token.value.number.longLongValue;
<a name="l01689"></a>01689       } <span class="keywordflow">else</span> {
<a name="l01690"></a>01690         parseState-&gt;token.value.number.unsignedLongLongValue = strtoull((<span class="keyword">const</span> <span class="keywordtype">char</span> *)numberTempBuf, (<span class="keywordtype">char</span> **)&amp;endOfNumber, 10);
<a name="l01691"></a>01691         parseState-&gt;token.value.type                         = JKValueTypeUnsignedLongLong;
<a name="l01692"></a>01692         parseState-&gt;token.value.ptrRange.ptr                 = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)&amp;parseState-&gt;token.value.number.unsignedLongLongValue;
<a name="l01693"></a>01693         parseState-&gt;token.value.ptrRange.length              = <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>);
<a name="l01694"></a>01694         parseState-&gt;token.value.hash                         = (JK_HASH_INIT + parseState-&gt;token.value.type) + (JKHash)parseState-&gt;token.value.number.unsignedLongLongValue;
<a name="l01695"></a>01695       }
<a name="l01696"></a>01696     }
<a name="l01697"></a>01697 
<a name="l01698"></a>01698     <span class="keywordflow">if</span>(JK_EXPECT_F(errno != 0)) {
<a name="l01699"></a>01699       numberState = JSONNumberStateError;
<a name="l01700"></a>01700       <span class="keywordflow">if</span>(errno == ERANGE) {
<a name="l01701"></a>01701         <span class="keywordflow">switch</span>(parseState-&gt;token.value.type) {
<a name="l01702"></a>01702           <span class="keywordflow">case</span> JKValueTypeDouble:           jk_error(parseState, <span class="stringliteral">@&quot;The value &#39;%s&#39; could not be represented as a &#39;double&#39; due to %s.&quot;</span>,           numberTempBuf, (parseState-&gt;token.value.number.doubleValue == 0.0) ? <span class="stringliteral">&quot;underflow&quot;</span> : <span class="stringliteral">&quot;overflow&quot;</span>); <span class="keywordflow">break</span>; <span class="comment">// see above for == 0.0.</span>
<a name="l01703"></a>01703           <span class="keywordflow">case</span> JKValueTypeLongLong:         jk_error(parseState, <span class="stringliteral">@&quot;The value &#39;%s&#39; exceeded the minimum value that could be represented: %lld.&quot;</span>, numberTempBuf, parseState-&gt;token.value.number.longLongValue);                                   <span class="keywordflow">break</span>;
<a name="l01704"></a>01704           <span class="keywordflow">case</span> JKValueTypeUnsignedLongLong: jk_error(parseState, <span class="stringliteral">@&quot;The value &#39;%s&#39; exceeded the maximum value that could be represented: %llu.&quot;</span>, numberTempBuf, parseState-&gt;token.value.number.unsignedLongLongValue);                           <span class="keywordflow">break</span>;
<a name="l01705"></a>01705           <span class="keywordflow">default</span>:                          jk_error(parseState, <span class="stringliteral">@&quot;Internal error: Unknown token value type. %@ line #%ld&quot;</span>,                     [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithUTF8String:__FILE__], (<span class="keywordtype">long</span>)__LINE__);                                      <span class="keywordflow">break</span>;
<a name="l01706"></a>01706         }
<a name="l01707"></a>01707       }
<a name="l01708"></a>01708     }
<a name="l01709"></a>01709     <span class="keywordflow">if</span>(JK_EXPECT_F(endOfNumber != &amp;numberTempBuf[parseState-&gt;token.tokenPtrRange.length]) &amp;&amp; JK_EXPECT_F(numberState != JSONNumberStateError)) { numberState = JSONNumberStateError; jk_error(parseState, <span class="stringliteral">@&quot;The conversion function did not consume all of the number tokens characters.&quot;</span>); }
<a name="l01710"></a>01710 
<a name="l01711"></a>01711     <span class="keywordtype">size_t</span> hashIndex = 0UL;
<a name="l01712"></a>01712     <span class="keywordflow">for</span>(hashIndex = 0UL; hashIndex &lt; parseState-&gt;token.value.ptrRange.length; hashIndex++) { parseState-&gt;token.value.hash = calculateHash(parseState-&gt;token.value.hash, parseState-&gt;token.value.ptrRange.ptr[hashIndex]); }
<a name="l01713"></a>01713   }
<a name="l01714"></a>01714 
<a name="l01715"></a>01715   <span class="keywordflow">if</span>(JK_EXPECT_F(numberState != JSONNumberStateFinished)) { jk_error(parseState, <span class="stringliteral">@&quot;Invalid number.&quot;</span>); }
<a name="l01716"></a>01716   <span class="keywordflow">return</span>(JK_EXPECT_T((numberState == JSONNumberStateFinished)) ? 0 : 1);
<a name="l01717"></a>01717 }
<a name="l01718"></a>01718 
<a name="l01719"></a>01719 JK_STATIC_INLINE <span class="keywordtype">void</span> jk_set_parsed_token(JKParseState *parseState, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ptr, <span class="keywordtype">size_t</span> length, JKTokenType type, <span class="keywordtype">size_t</span> advanceBy) {
<a name="l01720"></a>01720   parseState-&gt;token.tokenPtrRange.ptr     = ptr;
<a name="l01721"></a>01721   parseState-&gt;token.tokenPtrRange.length  = length;
<a name="l01722"></a>01722   parseState-&gt;token.type                  = type;
<a name="l01723"></a>01723   parseState-&gt;atIndex                    += advanceBy;
<a name="l01724"></a>01724 }
<a name="l01725"></a>01725 
<a name="l01726"></a>01726 <span class="keyword">static</span> <span class="keywordtype">size_t</span> jk_parse_is_newline(JKParseState *parseState, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *atCharacterPtr) {
<a name="l01727"></a>01727   NSCParameterAssert((parseState != NULL) &amp;&amp; (atCharacterPtr != NULL) &amp;&amp; (atCharacterPtr &gt;= parseState-&gt;stringBuffer.bytes.ptr) &amp;&amp; (atCharacterPtr &lt; JK_END_STRING_PTR(parseState)));
<a name="l01728"></a>01728   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *endOfStringPtr = JK_END_STRING_PTR(parseState);
<a name="l01729"></a>01729 
<a name="l01730"></a>01730   <span class="keywordflow">if</span>(JK_EXPECT_F(atCharacterPtr &gt;= endOfStringPtr)) { <span class="keywordflow">return</span>(0UL); }
<a name="l01731"></a>01731 
<a name="l01732"></a>01732   <span class="keywordflow">if</span>(JK_EXPECT_F((*(atCharacterPtr + 0)) == <span class="charliteral">&#39;\n&#39;</span>)) { <span class="keywordflow">return</span>(1UL); }
<a name="l01733"></a>01733   <span class="keywordflow">if</span>(JK_EXPECT_F((*(atCharacterPtr + 0)) == <span class="charliteral">&#39;\r&#39;</span>)) { <span class="keywordflow">if</span>((JK_EXPECT_T((atCharacterPtr + 1) &lt; endOfStringPtr)) &amp;&amp; ((*(atCharacterPtr + 1)) == <span class="charliteral">&#39;\n&#39;</span>)) { <span class="keywordflow">return</span>(2UL); } <span class="keywordflow">return</span>(1UL); }
<a name="l01734"></a>01734   <span class="keywordflow">if</span>(parseState-&gt;parseOptionFlags &amp; JKParseOptionUnicodeNewlines) {
<a name="l01735"></a>01735     <span class="keywordflow">if</span>((JK_EXPECT_F((*(atCharacterPtr + 0)) == 0xc2)) &amp;&amp; (((atCharacterPtr + 1) &lt; endOfStringPtr) &amp;&amp; ((*(atCharacterPtr + 1)) == 0x85))) { <span class="keywordflow">return</span>(2UL); }
<a name="l01736"></a>01736     <span class="keywordflow">if</span>((JK_EXPECT_F((*(atCharacterPtr + 0)) == 0xe2)) &amp;&amp; (((atCharacterPtr + 2) &lt; endOfStringPtr) &amp;&amp; ((*(atCharacterPtr + 1)) == 0x80) &amp;&amp; (((*(atCharacterPtr + 2)) == 0xa8) || ((*(atCharacterPtr + 2)) == 0xa9)))) { <span class="keywordflow">return</span>(3UL); }
<a name="l01737"></a>01737   }
<a name="l01738"></a>01738 
<a name="l01739"></a>01739   <span class="keywordflow">return</span>(0UL);
<a name="l01740"></a>01740 }
<a name="l01741"></a>01741 
<a name="l01742"></a>01742 JK_STATIC_INLINE <span class="keywordtype">int</span> jk_parse_skip_newline(JKParseState *parseState) {
<a name="l01743"></a>01743   <span class="keywordtype">size_t</span> newlineAdvanceAtIndex = 0UL;
<a name="l01744"></a>01744   <span class="keywordflow">if</span>(JK_EXPECT_F((newlineAdvanceAtIndex = jk_parse_is_newline(parseState, JK_AT_STRING_PTR(parseState))) &gt; 0UL)) { parseState-&gt;lineNumber++; parseState-&gt;atIndex += (newlineAdvanceAtIndex - 1UL); parseState-&gt;lineStartIndex = parseState-&gt;atIndex + 1UL; <span class="keywordflow">return</span>(1); }
<a name="l01745"></a>01745   <span class="keywordflow">return</span>(0);
<a name="l01746"></a>01746 }
<a name="l01747"></a>01747 
<a name="l01748"></a>01748 JK_STATIC_INLINE <span class="keywordtype">void</span> jk_parse_skip_whitespace(JKParseState *parseState) {
<a name="l01749"></a>01749 <span class="preprocessor">#ifndef __clang_analyzer__</span>
<a name="l01750"></a>01750 <span class="preprocessor"></span>  NSCParameterAssert((parseState != NULL) &amp;&amp; (JK_AT_STRING_PTR(parseState) &lt;= JK_END_STRING_PTR(parseState)));
<a name="l01751"></a>01751   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *atCharacterPtr   = NULL;
<a name="l01752"></a>01752   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *endOfStringPtr   = JK_END_STRING_PTR(parseState);
<a name="l01753"></a>01753 
<a name="l01754"></a>01754   <span class="keywordflow">for</span>(atCharacterPtr = JK_AT_STRING_PTR(parseState); (JK_EXPECT_T((atCharacterPtr = JK_AT_STRING_PTR(parseState)) &lt; endOfStringPtr)); parseState-&gt;atIndex++) {
<a name="l01755"></a>01755     <span class="keywordflow">if</span>(((*(atCharacterPtr + 0)) == <span class="charliteral">&#39; &#39;</span>) || ((*(atCharacterPtr + 0)) == &#39;\t&#39;)) { <span class="keywordflow">continue</span>; }
<a name="l01756"></a>01756     <span class="keywordflow">if</span>(jk_parse_skip_newline(parseState)) { <span class="keywordflow">continue</span>; }
<a name="l01757"></a>01757     <span class="keywordflow">if</span>(parseState-&gt;parseOptionFlags &amp; JKParseOptionComments) {
<a name="l01758"></a>01758       <span class="keywordflow">if</span>((JK_EXPECT_F((*(atCharacterPtr + 0)) == <span class="charliteral">&#39;/&#39;</span>)) &amp;&amp; (JK_EXPECT_T((atCharacterPtr + 1) &lt; endOfStringPtr))) {
<a name="l01759"></a>01759         <span class="keywordflow">if</span>((*(atCharacterPtr + 1)) == <span class="charliteral">&#39;/&#39;</span>) {
<a name="l01760"></a>01760           parseState-&gt;atIndex++;
<a name="l01761"></a>01761           <span class="keywordflow">for</span>(atCharacterPtr = JK_AT_STRING_PTR(parseState); (JK_EXPECT_T((atCharacterPtr = JK_AT_STRING_PTR(parseState)) &lt; endOfStringPtr)); parseState-&gt;atIndex++) { <span class="keywordflow">if</span>(jk_parse_skip_newline(parseState)) { <span class="keywordflow">break</span>; } }
<a name="l01762"></a>01762           <span class="keywordflow">continue</span>;
<a name="l01763"></a>01763         }
<a name="l01764"></a>01764         <span class="keywordflow">if</span>((*(atCharacterPtr + 1)) == <span class="charliteral">&#39;*&#39;</span>) {
<a name="l01765"></a>01765           parseState-&gt;atIndex++;
<a name="l01766"></a>01766           <span class="keywordflow">for</span>(atCharacterPtr = JK_AT_STRING_PTR(parseState); (JK_EXPECT_T((atCharacterPtr = JK_AT_STRING_PTR(parseState)) &lt; endOfStringPtr)); parseState-&gt;atIndex++) {
<a name="l01767"></a>01767             <span class="keywordflow">if</span>(jk_parse_skip_newline(parseState)) { <span class="keywordflow">continue</span>; }
<a name="l01768"></a>01768             <span class="keywordflow">if</span>(((*(atCharacterPtr + 0)) == <span class="charliteral">&#39;*&#39;</span>) &amp;&amp; (((atCharacterPtr + 1) &lt; endOfStringPtr) &amp;&amp; ((*(atCharacterPtr + 1)) == &#39;/&#39;))) { parseState-&gt;atIndex++; <span class="keywordflow">break</span>; }
<a name="l01769"></a>01769           }
<a name="l01770"></a>01770           <span class="keywordflow">continue</span>;
<a name="l01771"></a>01771         }
<a name="l01772"></a>01772       }
<a name="l01773"></a>01773     }
<a name="l01774"></a>01774     <span class="keywordflow">break</span>;
<a name="l01775"></a>01775   }
<a name="l01776"></a>01776 <span class="preprocessor">#endif</span>
<a name="l01777"></a>01777 <span class="preprocessor"></span>}
<a name="l01778"></a>01778 
<a name="l01779"></a>01779 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_parse_next_token(JKParseState *parseState) {
<a name="l01780"></a>01780   NSCParameterAssert((parseState != NULL) &amp;&amp; (JK_AT_STRING_PTR(parseState) &lt;= JK_END_STRING_PTR(parseState)));
<a name="l01781"></a>01781   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *atCharacterPtr   = NULL;
<a name="l01782"></a>01782   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *endOfStringPtr   = JK_END_STRING_PTR(parseState);
<a name="l01783"></a>01783   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>        currentCharacter = 0U;
<a name="l01784"></a>01784   <span class="keywordtype">int</span>                  stopParsing      = 0;
<a name="l01785"></a>01785 
<a name="l01786"></a>01786   parseState-&gt;prev_atIndex        = parseState-&gt;atIndex;
<a name="l01787"></a>01787   parseState-&gt;prev_lineNumber     = parseState-&gt;lineNumber;
<a name="l01788"></a>01788   parseState-&gt;prev_lineStartIndex = parseState-&gt;lineStartIndex;
<a name="l01789"></a>01789 
<a name="l01790"></a>01790   jk_parse_skip_whitespace(parseState);
<a name="l01791"></a>01791 
<a name="l01792"></a>01792   <span class="keywordflow">if</span>((JK_AT_STRING_PTR(parseState) == endOfStringPtr)) { stopParsing = 1; }
<a name="l01793"></a>01793 
<a name="l01794"></a>01794   <span class="keywordflow">if</span>((JK_EXPECT_T(stopParsing == 0)) &amp;&amp; (JK_EXPECT_T((atCharacterPtr = JK_AT_STRING_PTR(parseState)) &lt; endOfStringPtr))) {
<a name="l01795"></a>01795     currentCharacter = *atCharacterPtr;
<a name="l01796"></a>01796 
<a name="l01797"></a>01797          <span class="keywordflow">if</span>(JK_EXPECT_T(currentCharacter == <span class="charliteral">&#39;&quot;&#39;</span>)) { <span class="keywordflow">if</span>(JK_EXPECT_T((stopParsing = jk_parse_string(parseState)) == 0)) { jk_set_parsed_token(parseState, parseState-&gt;token.tokenPtrRange.ptr, parseState-&gt;token.tokenPtrRange.length, JKTokenTypeString, 0UL); } }
<a name="l01798"></a>01798     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T(currentCharacter == <span class="charliteral">&#39;:&#39;</span>)) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeSeparator,   1UL); }
<a name="l01799"></a>01799     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T(currentCharacter == <span class="charliteral">&#39;,&#39;</span>)) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeComma,       1UL); }
<a name="l01800"></a>01800     <span class="keywordflow">else</span> <span class="keywordflow">if</span>((JK_EXPECT_T(currentCharacter &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; JK_EXPECT_T(currentCharacter &lt;= <span class="charliteral">&#39;9&#39;</span>)) || JK_EXPECT_T(currentCharacter == <span class="charliteral">&#39;-&#39;</span>)) { <span class="keywordflow">if</span>(JK_EXPECT_T((stopParsing = jk_parse_number(parseState)) == 0)) { jk_set_parsed_token(parseState, parseState-&gt;token.tokenPtrRange.ptr, parseState-&gt;token.tokenPtrRange.length, JKTokenTypeNumber, 0UL); } }
<a name="l01801"></a>01801     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T(currentCharacter == <span class="charliteral">&#39;{&#39;</span>)) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeObjectBegin, 1UL); }
<a name="l01802"></a>01802     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T(currentCharacter == <span class="charliteral">&#39;}&#39;</span>)) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeObjectEnd,   1UL); }
<a name="l01803"></a>01803     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T(currentCharacter == <span class="charliteral">&#39;[&#39;</span>)) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeArrayBegin,  1UL); }
<a name="l01804"></a>01804     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T(currentCharacter == <span class="charliteral">&#39;]&#39;</span>)) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeArrayEnd,    1UL); }
<a name="l01805"></a>01805     
<a name="l01806"></a>01806     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T(currentCharacter == <span class="charliteral">&#39;t&#39;</span>)) { <span class="keywordflow">if</span>(!((JK_EXPECT_T((atCharacterPtr + 4UL) &lt; endOfStringPtr)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[1] == <span class="charliteral">&#39;r&#39;</span>)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[2] == <span class="charliteral">&#39;u&#39;</span>)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[3] == <span class="charliteral">&#39;e&#39;</span>))))                                            { stopParsing = 1; <span class="comment">/* XXX Add error message */</span> } <span class="keywordflow">else</span> { jk_set_parsed_token(parseState, atCharacterPtr, 4UL, JKTokenTypeTrue,  4UL); } }
<a name="l01807"></a>01807     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T(currentCharacter == <span class="charliteral">&#39;f&#39;</span>)) { <span class="keywordflow">if</span>(!((JK_EXPECT_T((atCharacterPtr + 5UL) &lt; endOfStringPtr)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[1] == <span class="charliteral">&#39;a&#39;</span>)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[2] == <span class="charliteral">&#39;l&#39;</span>)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[3] == <span class="charliteral">&#39;s&#39;</span>)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[4] == <span class="charliteral">&#39;e&#39;</span>)))) { stopParsing = 1; <span class="comment">/* XXX Add error message */</span> } <span class="keywordflow">else</span> { jk_set_parsed_token(parseState, atCharacterPtr, 5UL, JKTokenTypeFalse, 5UL); } }
<a name="l01808"></a>01808     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T(currentCharacter == <span class="charliteral">&#39;n&#39;</span>)) { <span class="keywordflow">if</span>(!((JK_EXPECT_T((atCharacterPtr + 4UL) &lt; endOfStringPtr)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[1] == <span class="charliteral">&#39;u&#39;</span>)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[2] == <span class="charliteral">&#39;l&#39;</span>)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[3] == <span class="charliteral">&#39;l&#39;</span>))))                                            { stopParsing = 1; <span class="comment">/* XXX Add error message */</span> } <span class="keywordflow">else</span> { jk_set_parsed_token(parseState, atCharacterPtr, 4UL, JKTokenTypeNull,  4UL); } }
<a name="l01809"></a>01809     <span class="keywordflow">else</span> { stopParsing = 1; <span class="comment">/* XXX Add error message */</span> }    
<a name="l01810"></a>01810   }
<a name="l01811"></a>01811 
<a name="l01812"></a>01812   <span class="keywordflow">if</span>(JK_EXPECT_F(stopParsing)) { jk_error(parseState, <span class="stringliteral">@&quot;Unexpected token, wanted &#39;{&#39;, &#39;}&#39;, &#39;[&#39;, &#39;]&#39;, &#39;,&#39;, &#39;:&#39;, &#39;true&#39;, &#39;false&#39;, &#39;null&#39;, &#39;\&quot;</span>STRING\<span class="stringliteral">&quot;&#39;, &#39;NUMBER&#39;.&quot;</span>); }
<a name="l01813"></a>01813   <span class="keywordflow">return</span>(stopParsing);
<a name="l01814"></a>01814 }
<a name="l01815"></a>01815 
<a name="l01816"></a>01816 <span class="keyword">static</span> <span class="keywordtype">void</span> jk_error_parse_accept_or3(JKParseState *parseState, <span class="keywordtype">int</span> state, <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *or1String, <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *or2String, <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *or3String) {
<a name="l01817"></a>01817   <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *acceptStrings[16];
<a name="l01818"></a>01818   <span class="keywordtype">int</span> acceptIdx = 0;
<a name="l01819"></a>01819   <span class="keywordflow">if</span>(state &amp; JKParseAcceptValue) { acceptStrings[acceptIdx++] = or1String; }
<a name="l01820"></a>01820   <span class="keywordflow">if</span>(state &amp; JKParseAcceptComma) { acceptStrings[acceptIdx++] = or2String; }
<a name="l01821"></a>01821   <span class="keywordflow">if</span>(state &amp; JKParseAcceptEnd)   { acceptStrings[acceptIdx++] = or3String; }
<a name="l01822"></a>01822        <span class="keywordflow">if</span>(acceptIdx == 1) { jk_error(parseState, <span class="stringliteral">@&quot;Expected %@, not &#39;%*.*s&#39;&quot;</span>,           acceptStrings[0],                                     (<span class="keywordtype">int</span>)parseState-&gt;token.tokenPtrRange.length, (<span class="keywordtype">int</span>)parseState-&gt;token.tokenPtrRange.length, parseState-&gt;token.tokenPtrRange.ptr); }
<a name="l01823"></a>01823   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(acceptIdx == 2) { jk_error(parseState, <span class="stringliteral">@&quot;Expected %@ or %@, not &#39;%*.*s&#39;&quot;</span>,     acceptStrings[0], acceptStrings[1],                   (<span class="keywordtype">int</span>)parseState-&gt;token.tokenPtrRange.length, (<span class="keywordtype">int</span>)parseState-&gt;token.tokenPtrRange.length, parseState-&gt;token.tokenPtrRange.ptr); }
<a name="l01824"></a>01824   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(acceptIdx == 3) { jk_error(parseState, <span class="stringliteral">@&quot;Expected %@, %@, or %@, not &#39;%*.*s&quot;</span>, acceptStrings[0], acceptStrings[1], acceptStrings[2], (<span class="keywordtype">int</span>)parseState-&gt;token.tokenPtrRange.length, (<span class="keywordtype">int</span>)parseState-&gt;token.tokenPtrRange.length, parseState-&gt;token.tokenPtrRange.ptr); }
<a name="l01825"></a>01825 }
<a name="l01826"></a>01826 
<a name="l01827"></a>01827 <span class="keyword">static</span> <span class="keywordtype">void</span> *jk_parse_array(JKParseState *parseState) {
<a name="l01828"></a>01828   <span class="keywordtype">size_t</span>  startingObjectIndex = parseState-&gt;objectStack.index;
<a name="l01829"></a>01829   <span class="keywordtype">int</span>     arrayState          = JKParseAcceptValueOrEnd, stopParsing = 0;
<a name="l01830"></a>01830   <span class="keywordtype">void</span>   *parsedArray         = NULL;
<a name="l01831"></a>01831 
<a name="l01832"></a>01832   <span class="keywordflow">while</span>(JK_EXPECT_T((JK_EXPECT_T(stopParsing == 0)) &amp;&amp; (JK_EXPECT_T(parseState-&gt;atIndex &lt; parseState-&gt;stringBuffer.bytes.length)))) {
<a name="l01833"></a>01833     <span class="keywordflow">if</span>(JK_EXPECT_F(parseState-&gt;objectStack.index &gt; (parseState-&gt;objectStack.count - 4UL))) { <span class="keywordflow">if</span>(jk_objectStack_resize(&amp;parseState-&gt;objectStack, parseState-&gt;objectStack.count + 128UL)) { jk_error(parseState, <span class="stringliteral">@&quot;Internal error: [array] objectsIndex &gt; %zu, resize failed? %@ line %#ld&quot;</span>, (parseState-&gt;objectStack.count - 4UL), [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithUTF8String:__FILE__], (<span class="keywordtype">long</span>)__LINE__); <span class="keywordflow">break</span>; } }
<a name="l01834"></a>01834 
<a name="l01835"></a>01835     <span class="keywordflow">if</span>(JK_EXPECT_T((stopParsing = jk_parse_next_token(parseState)) == 0)) {
<a name="l01836"></a>01836       <span class="keywordtype">void</span> *<span class="keywordtype">object</span> = NULL;
<a name="l01837"></a>01837 <span class="preprocessor">#ifndef NS_BLOCK_ASSERTIONS</span>
<a name="l01838"></a>01838 <span class="preprocessor"></span>      parseState-&gt;objectStack.objects[parseState-&gt;objectStack.index] = NULL;
<a name="l01839"></a>01839       parseState-&gt;objectStack.keys   [parseState-&gt;objectStack.index] = NULL;
<a name="l01840"></a>01840 <span class="preprocessor">#endif</span>
<a name="l01841"></a>01841 <span class="preprocessor"></span>      <span class="keywordflow">switch</span>(parseState-&gt;token.type) {
<a name="l01842"></a>01842         <span class="keywordflow">case</span> JKTokenTypeNumber:
<a name="l01843"></a>01843         <span class="keywordflow">case</span> JKTokenTypeString:
<a name="l01844"></a>01844         <span class="keywordflow">case</span> JKTokenTypeTrue:
<a name="l01845"></a>01845         <span class="keywordflow">case</span> JKTokenTypeFalse:
<a name="l01846"></a>01846         <span class="keywordflow">case</span> JKTokenTypeNull:
<a name="l01847"></a>01847         <span class="keywordflow">case</span> JKTokenTypeArrayBegin:
<a name="l01848"></a>01848         <span class="keywordflow">case</span> JKTokenTypeObjectBegin:
<a name="l01849"></a>01849           <span class="keywordflow">if</span>(JK_EXPECT_F((arrayState &amp; JKParseAcceptValue)          == 0))    { parseState-&gt;errorIsPrev = 1; jk_error(parseState, <span class="stringliteral">@&quot;Unexpected value.&quot;</span>);              stopParsing = 1; <span class="keywordflow">break</span>; }
<a name="l01850"></a>01850           <span class="keywordflow">if</span>(JK_EXPECT_F((<span class="keywordtype">object</span> = jk_object_for_token(parseState)) == NULL)) {                              jk_error(parseState, <span class="stringliteral">@&quot;Internal error: Object == NULL&quot;</span>); stopParsing = 1; <span class="keywordflow">break</span>; } <span class="keywordflow">else</span> { parseState-&gt;objectStack.objects[parseState-&gt;objectStack.index++] = object; arrayState = JKParseAcceptCommaOrEnd; }
<a name="l01851"></a>01851           <span class="keywordflow">break</span>;
<a name="l01852"></a>01852         <span class="keywordflow">case</span> JKTokenTypeArrayEnd: <span class="keywordflow">if</span>(JK_EXPECT_T(arrayState &amp; JKParseAcceptEnd)) { NSCParameterAssert(parseState-&gt;objectStack.index &gt;= startingObjectIndex); parsedArray = (<span class="keywordtype">void</span> *)_JKArrayCreate((<span class="keywordtype">id</span> *)&amp;parseState-&gt;objectStack.objects[startingObjectIndex], (parseState-&gt;objectStack.index - startingObjectIndex), parseState-&gt;mutableCollections); } <span class="keywordflow">else</span> { parseState-&gt;errorIsPrev = 1; jk_error(parseState, <span class="stringliteral">@&quot;Unexpected &#39;]&#39;.&quot;</span>); } stopParsing = 1; <span class="keywordflow">break</span>;
<a name="l01853"></a>01853         <span class="keywordflow">case</span> JKTokenTypeComma:    <span class="keywordflow">if</span>(JK_EXPECT_T(arrayState &amp; JKParseAcceptComma)) { arrayState = JKParseAcceptValue; } <span class="keywordflow">else</span> { parseState-&gt;errorIsPrev = 1; jk_error(parseState, <span class="stringliteral">@&quot;Unexpected &#39;,&#39;.&quot;</span>); stopParsing = 1; } <span class="keywordflow">break</span>;
<a name="l01854"></a>01854         <span class="keywordflow">default</span>: parseState-&gt;errorIsPrev = 1; jk_error_parse_accept_or3(parseState, arrayState, <span class="stringliteral">@&quot;a value&quot;</span>, <span class="stringliteral">@&quot;a comma&quot;</span>, <span class="stringliteral">@&quot;a &#39;]&#39;&quot;</span>); stopParsing = 1; <span class="keywordflow">break</span>;
<a name="l01855"></a>01855       }
<a name="l01856"></a>01856     }
<a name="l01857"></a>01857   }
<a name="l01858"></a>01858 
<a name="l01859"></a>01859   <span class="keywordflow">if</span>(JK_EXPECT_F(parsedArray == NULL)) { <span class="keywordtype">size_t</span> idx = 0UL; <span class="keywordflow">for</span>(idx = startingObjectIndex; idx &lt; parseState-&gt;objectStack.index; idx++) { <span class="keywordflow">if</span>(parseState-&gt;objectStack.objects[idx] != NULL) { CFRelease(parseState-&gt;objectStack.objects[idx]); parseState-&gt;objectStack.objects[idx] = NULL; } } }
<a name="l01860"></a>01860 <span class="preprocessor">#if !defined(NS_BLOCK_ASSERTIONS)</span>
<a name="l01861"></a>01861 <span class="preprocessor"></span>  <span class="keywordflow">else</span> { <span class="keywordtype">size_t</span> idx = 0UL; <span class="keywordflow">for</span>(idx = startingObjectIndex; idx &lt; parseState-&gt;objectStack.index; idx++) { parseState-&gt;objectStack.objects[idx] = NULL; parseState-&gt;objectStack.keys[idx] = NULL; } }
<a name="l01862"></a>01862 <span class="preprocessor">#endif</span>
<a name="l01863"></a>01863 <span class="preprocessor"></span>  
<a name="l01864"></a>01864   parseState-&gt;objectStack.index = startingObjectIndex;
<a name="l01865"></a>01865   <span class="keywordflow">return</span>(parsedArray);
<a name="l01866"></a>01866 }
<a name="l01867"></a>01867 
<a name="l01868"></a>01868 <span class="keyword">static</span> <span class="keywordtype">void</span> *jk_create_dictionary(JKParseState *parseState, <span class="keywordtype">size_t</span> startingObjectIndex) {
<a name="l01869"></a>01869   <span class="keywordtype">void</span> *parsedDictionary = NULL;
<a name="l01870"></a>01870 
<a name="l01871"></a>01871   parseState-&gt;objectStack.index--;
<a name="l01872"></a>01872 
<a name="l01873"></a>01873   parsedDictionary = _JKDictionaryCreate((<span class="keywordtype">id</span> *)&amp;parseState-&gt;objectStack.keys[startingObjectIndex], (NSUInteger *)&amp;parseState-&gt;objectStack.cfHashes[startingObjectIndex], (<span class="keywordtype">id</span> *)&amp;parseState-&gt;objectStack.objects[startingObjectIndex], (parseState-&gt;objectStack.index - startingObjectIndex), parseState-&gt;mutableCollections);
<a name="l01874"></a>01874 
<a name="l01875"></a>01875   <span class="keywordflow">return</span>(parsedDictionary);
<a name="l01876"></a>01876 }
<a name="l01877"></a>01877 
<a name="l01878"></a>01878 <span class="keyword">static</span> <span class="keywordtype">void</span> *jk_parse_dictionary(JKParseState *parseState) {
<a name="l01879"></a>01879   <span class="keywordtype">size_t</span>  startingObjectIndex = parseState-&gt;objectStack.index;
<a name="l01880"></a>01880   <span class="keywordtype">int</span>     dictState           = JKParseAcceptValueOrEnd, stopParsing = 0;
<a name="l01881"></a>01881   <span class="keywordtype">void</span>   *parsedDictionary    = NULL;
<a name="l01882"></a>01882 
<a name="l01883"></a>01883   <span class="keywordflow">while</span>(JK_EXPECT_T((JK_EXPECT_T(stopParsing == 0)) &amp;&amp; (JK_EXPECT_T(parseState-&gt;atIndex &lt; parseState-&gt;stringBuffer.bytes.length)))) {
<a name="l01884"></a>01884     <span class="keywordflow">if</span>(JK_EXPECT_F(parseState-&gt;objectStack.index &gt; (parseState-&gt;objectStack.count - 4UL))) { <span class="keywordflow">if</span>(jk_objectStack_resize(&amp;parseState-&gt;objectStack, parseState-&gt;objectStack.count + 128UL)) { jk_error(parseState, <span class="stringliteral">@&quot;Internal error: [dictionary] objectsIndex &gt; %zu, resize failed? %@ line #%ld&quot;</span>, (parseState-&gt;objectStack.count - 4UL), [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithUTF8String:__FILE__], (<span class="keywordtype">long</span>)__LINE__); <span class="keywordflow">break</span>; } }
<a name="l01885"></a>01885 
<a name="l01886"></a>01886     <span class="keywordtype">size_t</span> objectStackIndex = parseState-&gt;objectStack.index++;
<a name="l01887"></a>01887     parseState-&gt;objectStack.keys[objectStackIndex]    = NULL;
<a name="l01888"></a>01888     parseState-&gt;objectStack.objects[objectStackIndex] = NULL;
<a name="l01889"></a>01889     <span class="keywordtype">void</span> *key = NULL, *<span class="keywordtype">object</span> = NULL;
<a name="l01890"></a>01890 
<a name="l01891"></a>01891     <span class="keywordflow">if</span>(JK_EXPECT_T((JK_EXPECT_T(stopParsing == 0)) &amp;&amp; (JK_EXPECT_T((stopParsing = jk_parse_next_token(parseState)) == 0)))) {
<a name="l01892"></a>01892       <span class="keywordflow">switch</span>(parseState-&gt;token.type) {
<a name="l01893"></a>01893         <span class="keywordflow">case</span> JKTokenTypeString:
<a name="l01894"></a>01894           <span class="keywordflow">if</span>(JK_EXPECT_F((dictState &amp; JKParseAcceptValue)        == 0))    { parseState-&gt;errorIsPrev = 1; jk_error(parseState, <span class="stringliteral">@&quot;Unexpected string.&quot;</span>);           stopParsing = 1; <span class="keywordflow">break</span>; }
<a name="l01895"></a>01895           <span class="keywordflow">if</span>(JK_EXPECT_F((key = jk_object_for_token(parseState)) == NULL)) {                              jk_error(parseState, <span class="stringliteral">@&quot;Internal error: Key == NULL.&quot;</span>); stopParsing = 1; <span class="keywordflow">break</span>; }
<a name="l01896"></a>01896           <span class="keywordflow">else</span> {
<a name="l01897"></a>01897             parseState-&gt;objectStack.keys[objectStackIndex] = key;
<a name="l01898"></a>01898             <span class="keywordflow">if</span>(JK_EXPECT_T(parseState-&gt;token.value.cacheItem != NULL)) { <span class="keywordflow">if</span>(JK_EXPECT_F(parseState-&gt;token.value.cacheItem-&gt;cfHash == 0UL)) { parseState-&gt;token.value.cacheItem-&gt;cfHash = CFHash(key); } parseState-&gt;objectStack.cfHashes[objectStackIndex] = parseState-&gt;token.value.cacheItem-&gt;cfHash; }
<a name="l01899"></a>01899             <span class="keywordflow">else</span> { parseState-&gt;objectStack.cfHashes[objectStackIndex] = CFHash(key); }
<a name="l01900"></a>01900           }
<a name="l01901"></a>01901           <span class="keywordflow">break</span>;
<a name="l01902"></a>01902 
<a name="l01903"></a>01903         <span class="keywordflow">case</span> JKTokenTypeObjectEnd: <span class="keywordflow">if</span>((JK_EXPECT_T(dictState &amp; JKParseAcceptEnd)))   { NSCParameterAssert(parseState-&gt;objectStack.index &gt;= startingObjectIndex); parsedDictionary = jk_create_dictionary(parseState, startingObjectIndex); } <span class="keywordflow">else</span> { parseState-&gt;errorIsPrev = 1; jk_error(parseState, <span class="stringliteral">@&quot;Unexpected &#39;}&#39;.&quot;</span>); } stopParsing = 1; <span class="keywordflow">break</span>;
<a name="l01904"></a>01904         <span class="keywordflow">case</span> JKTokenTypeComma:     <span class="keywordflow">if</span>((JK_EXPECT_T(dictState &amp; JKParseAcceptComma))) { dictState = JKParseAcceptValue; parseState-&gt;objectStack.index--; <span class="keywordflow">continue</span>; } <span class="keywordflow">else</span> { parseState-&gt;errorIsPrev = 1; jk_error(parseState, <span class="stringliteral">@&quot;Unexpected &#39;,&#39;.&quot;</span>); stopParsing = 1; } <span class="keywordflow">break</span>;
<a name="l01905"></a>01905 
<a name="l01906"></a>01906         <span class="keywordflow">default</span>: parseState-&gt;errorIsPrev = 1; jk_error_parse_accept_or3(parseState, dictState, <span class="stringliteral">@&quot;a \&quot;</span>STRING\<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">@&quot;a comma&quot;</span>, <span class="stringliteral">@&quot;a &#39;}&#39;&quot;</span>); stopParsing = 1; <span class="keywordflow">break</span>;
<a name="l01907"></a>01907       }
<a name="l01908"></a>01908     }
<a name="l01909"></a>01909 
<a name="l01910"></a>01910     <span class="keywordflow">if</span>(JK_EXPECT_T(stopParsing == 0)) {
<a name="l01911"></a>01911       <span class="keywordflow">if</span>(JK_EXPECT_T((stopParsing = jk_parse_next_token(parseState)) == 0)) { <span class="keywordflow">if</span>(JK_EXPECT_F(parseState-&gt;token.type != JKTokenTypeSeparator)) { parseState-&gt;errorIsPrev = 1; jk_error(parseState, <span class="stringliteral">@&quot;Expected &#39;:&#39;.&quot;</span>); stopParsing = 1; } }
<a name="l01912"></a>01912     }
<a name="l01913"></a>01913 
<a name="l01914"></a>01914     <span class="keywordflow">if</span>((JK_EXPECT_T(stopParsing == 0)) &amp;&amp; (JK_EXPECT_T((stopParsing = jk_parse_next_token(parseState)) == 0))) {
<a name="l01915"></a>01915       <span class="keywordflow">switch</span>(parseState-&gt;token.type) {
<a name="l01916"></a>01916         <span class="keywordflow">case</span> JKTokenTypeNumber:
<a name="l01917"></a>01917         <span class="keywordflow">case</span> JKTokenTypeString:
<a name="l01918"></a>01918         <span class="keywordflow">case</span> JKTokenTypeTrue:
<a name="l01919"></a>01919         <span class="keywordflow">case</span> JKTokenTypeFalse:
<a name="l01920"></a>01920         <span class="keywordflow">case</span> JKTokenTypeNull:
<a name="l01921"></a>01921         <span class="keywordflow">case</span> JKTokenTypeArrayBegin:
<a name="l01922"></a>01922         <span class="keywordflow">case</span> JKTokenTypeObjectBegin:
<a name="l01923"></a>01923           <span class="keywordflow">if</span>(JK_EXPECT_F((dictState &amp; JKParseAcceptValue)           == 0))    { parseState-&gt;errorIsPrev = 1; jk_error(parseState, <span class="stringliteral">@&quot;Unexpected value.&quot;</span>);               stopParsing = 1; <span class="keywordflow">break</span>; }
<a name="l01924"></a>01924           <span class="keywordflow">if</span>(JK_EXPECT_F((<span class="keywordtype">object</span> = jk_object_for_token(parseState)) == NULL)) {                              jk_error(parseState, <span class="stringliteral">@&quot;Internal error: Object == NULL.&quot;</span>); stopParsing = 1; <span class="keywordflow">break</span>; } <span class="keywordflow">else</span> { parseState-&gt;objectStack.objects[objectStackIndex] = object; dictState = JKParseAcceptCommaOrEnd; }
<a name="l01925"></a>01925           <span class="keywordflow">break</span>;
<a name="l01926"></a>01926         <span class="keywordflow">default</span>: parseState-&gt;errorIsPrev = 1; jk_error_parse_accept_or3(parseState, dictState, <span class="stringliteral">@&quot;a value&quot;</span>, <span class="stringliteral">@&quot;a comma&quot;</span>, <span class="stringliteral">@&quot;a &#39;}&#39;&quot;</span>); stopParsing = 1; <span class="keywordflow">break</span>;
<a name="l01927"></a>01927       }
<a name="l01928"></a>01928     }
<a name="l01929"></a>01929   }
<a name="l01930"></a>01930 
<a name="l01931"></a>01931   <span class="keywordflow">if</span>(JK_EXPECT_F(parsedDictionary == NULL)) { <span class="keywordtype">size_t</span> idx = 0UL; <span class="keywordflow">for</span>(idx = startingObjectIndex; idx &lt; parseState-&gt;objectStack.index; idx++) { <span class="keywordflow">if</span>(parseState-&gt;objectStack.keys[idx] != NULL) { CFRelease(parseState-&gt;objectStack.keys[idx]); parseState-&gt;objectStack.keys[idx] = NULL; } <span class="keywordflow">if</span>(parseState-&gt;objectStack.objects[idx] != NULL) { CFRelease(parseState-&gt;objectStack.objects[idx]); parseState-&gt;objectStack.objects[idx] = NULL; } } }
<a name="l01932"></a>01932 <span class="preprocessor">#if !defined(NS_BLOCK_ASSERTIONS)</span>
<a name="l01933"></a>01933 <span class="preprocessor"></span>  <span class="keywordflow">else</span> { <span class="keywordtype">size_t</span> idx = 0UL; <span class="keywordflow">for</span>(idx = startingObjectIndex; idx &lt; parseState-&gt;objectStack.index; idx++) { parseState-&gt;objectStack.objects[idx] = NULL; parseState-&gt;objectStack.keys[idx] = NULL; } }
<a name="l01934"></a>01934 <span class="preprocessor">#endif</span>
<a name="l01935"></a>01935 <span class="preprocessor"></span>
<a name="l01936"></a>01936   parseState-&gt;objectStack.index = startingObjectIndex;
<a name="l01937"></a>01937   <span class="keywordflow">return</span>(parsedDictionary);
<a name="l01938"></a>01938 }
<a name="l01939"></a>01939 
<a name="l01940"></a>01940 <span class="keyword">static</span> <span class="keywordtype">id</span> json_parse_it(JKParseState *parseState) {
<a name="l01941"></a>01941   <span class="keywordtype">id</span>  parsedObject = NULL;
<a name="l01942"></a>01942   <span class="keywordtype">int</span> stopParsing  = 0;
<a name="l01943"></a>01943 
<a name="l01944"></a>01944   <span class="keywordflow">while</span>((JK_EXPECT_T(stopParsing == 0)) &amp;&amp; (JK_EXPECT_T(parseState-&gt;atIndex &lt; parseState-&gt;stringBuffer.bytes.length))) {
<a name="l01945"></a>01945     <span class="keywordflow">if</span>((JK_EXPECT_T(stopParsing == 0)) &amp;&amp; (JK_EXPECT_T((stopParsing = jk_parse_next_token(parseState)) == 0))) {
<a name="l01946"></a>01946       <span class="keywordflow">switch</span>(parseState-&gt;token.type) {
<a name="l01947"></a>01947         <span class="keywordflow">case</span> JKTokenTypeArrayBegin:
<a name="l01948"></a>01948         <span class="keywordflow">case</span> JKTokenTypeObjectBegin: parsedObject = [(id)jk_object_for_token(parseState) autorelease]; stopParsing = 1; <span class="keywordflow">break</span>;
<a name="l01949"></a>01949         <span class="keywordflow">default</span>:                     jk_error(parseState, <span class="stringliteral">@&quot;Expected either &#39;[&#39; or &#39;{&#39;.&quot;</span>);             stopParsing = 1; <span class="keywordflow">break</span>;
<a name="l01950"></a>01950       }
<a name="l01951"></a>01951     }
<a name="l01952"></a>01952   }
<a name="l01953"></a>01953 
<a name="l01954"></a>01954   NSCParameterAssert((parseState-&gt;objectStack.index == 0) &amp;&amp; (JK_AT_STRING_PTR(parseState) &lt;= JK_END_STRING_PTR(parseState)));
<a name="l01955"></a>01955 
<a name="l01956"></a>01956   <span class="keywordflow">if</span>((parsedObject == NULL) &amp;&amp; (JK_AT_STRING_PTR(parseState) == JK_END_STRING_PTR(parseState))) { jk_error(parseState, <span class="stringliteral">@&quot;Reached the end of the buffer.&quot;</span>); }
<a name="l01957"></a>01957   <span class="keywordflow">if</span>(parsedObject == NULL) { jk_error(parseState, <span class="stringliteral">@&quot;Unable to parse JSON.&quot;</span>); }
<a name="l01958"></a>01958 
<a name="l01959"></a>01959   <span class="keywordflow">if</span>((parsedObject != NULL) &amp;&amp; (JK_AT_STRING_PTR(parseState) &lt; JK_END_STRING_PTR(parseState))) {
<a name="l01960"></a>01960     jk_parse_skip_whitespace(parseState);
<a name="l01961"></a>01961     <span class="keywordflow">if</span>((parsedObject != NULL) &amp;&amp; ((parseState-&gt;parseOptionFlags &amp; JKParseOptionPermitTextAfterValidJSON) == 0) &amp;&amp; (JK_AT_STRING_PTR(parseState) &lt; JK_END_STRING_PTR(parseState))) {
<a name="l01962"></a>01962       jk_error(parseState, <span class="stringliteral">@&quot;A valid JSON object was parsed but there were additional non-white-space characters remaining.&quot;</span>);
<a name="l01963"></a>01963       parsedObject = NULL;
<a name="l01964"></a>01964     }
<a name="l01965"></a>01965   }
<a name="l01966"></a>01966 
<a name="l01967"></a>01967   <span class="keywordflow">return</span>(parsedObject);
<a name="l01968"></a>01968 }
<a name="l01969"></a>01969 
<a name="l01971"></a>01971 <span class="preprocessor">#pragma mark -</span>
<a name="l01972"></a>01972 <span class="preprocessor"></span><span class="preprocessor">#pragma mark Object cache</span>
<a name="l01973"></a>01973 <span class="preprocessor"></span>
<a name="l01974"></a>01974 <span class="comment">// This uses a Galois Linear Feedback Shift Register (LFSR) PRNG to pick which item in the cache to age. It has a period of (2^32)-1.</span>
<a name="l01975"></a>01975 <span class="comment">// NOTE: A LFSR *MUST* be initialized to a non-zero value and must always have a non-zero value.</span>
<a name="l01976"></a>01976 JK_STATIC_INLINE <span class="keywordtype">void</span> jk_cache_age(JKParseState *parseState) {
<a name="l01977"></a>01977   NSCParameterAssert((parseState != NULL) &amp;&amp; (parseState-&gt;cache.prng_lfsr != 0U));
<a name="l01978"></a>01978   parseState-&gt;cache.prng_lfsr = (parseState-&gt;cache.prng_lfsr &gt;&gt; 1) ^ ((0U - (parseState-&gt;cache.prng_lfsr &amp; 1U)) &amp; 0x80200003U);
<a name="l01979"></a>01979   parseState-&gt;cache.age[parseState-&gt;cache.prng_lfsr &amp; (parseState-&gt;cache.count - 1UL)] &gt;&gt;= 1;
<a name="l01980"></a>01980 }
<a name="l01981"></a>01981 
<a name="l01982"></a>01982 <span class="comment">// The object cache is nothing more than a hash table with open addressing collision resolution that is bounded by JK_CACHE_PROBES attempts.</span>
<a name="l01983"></a>01983 <span class="comment">//</span>
<a name="l01984"></a>01984 <span class="comment">// The hash table is a linear C array of JKTokenCacheItem.  The terms &quot;item&quot; and &quot;bucket&quot; are synonymous with the index in to the cache array, i.e. cache.items[bucket].</span>
<a name="l01985"></a>01985 <span class="comment">//</span>
<a name="l01986"></a>01986 <span class="comment">// Items in the cache have an age associated with them.  The age is the number of rightmost 1 bits, i.e. 0000 = 0, 0001 = 1, 0011 = 2, 0111 = 3, 1111 = 4.</span>
<a name="l01987"></a>01987 <span class="comment">// This allows us to use left and right shifts to add or subtract from an items age.  Add = (age &lt;&lt; 1) | 1.  Subtract = age &gt;&gt; 0.  Subtract is synonymous with &quot;age&quot; (i.e., age an item).</span>
<a name="l01988"></a>01988 <span class="comment">// The reason for this is it allows us to perform saturated adds and subtractions and is branchless.</span>
<a name="l01989"></a>01989 <span class="comment">// The primitive C type MUST be unsigned.  It is currently a &quot;char&quot;, which allows (at a minimum and in practice) 8 bits.</span>
<a name="l01990"></a>01990 <span class="comment">//</span>
<a name="l01991"></a>01991 <span class="comment">// A &quot;useable bucket&quot; is a bucket that is not in use (never populated), or has an age == 0.</span>
<a name="l01992"></a>01992 <span class="comment">//</span>
<a name="l01993"></a>01993 <span class="comment">// When an item is found in the cache, it&#39;s age is incremented.</span>
<a name="l01994"></a>01994 <span class="comment">// If a useable bucket hasn&#39;t been found, the current item (bucket) is aged along with two random items.</span>
<a name="l01995"></a>01995 <span class="comment">//</span>
<a name="l01996"></a>01996 <span class="comment">// If a value is not found in the cache, and no useable bucket has been found, that value is not added to the cache.</span>
<a name="l01997"></a>01997 
<a name="l01998"></a>01998 <span class="keyword">static</span> <span class="keywordtype">void</span> *jk_cachedObjects(JKParseState *parseState) {
<a name="l01999"></a>01999   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  bucket     = parseState-&gt;token.value.hash &amp; (parseState-&gt;cache.count - 1UL), setBucket = 0UL, useableBucket = 0UL, x = 0UL;
<a name="l02000"></a>02000   <span class="keywordtype">void</span>          *parsedAtom = NULL;
<a name="l02001"></a>02001     
<a name="l02002"></a>02002   <span class="keywordflow">if</span>(JK_EXPECT_F(parseState-&gt;token.value.ptrRange.length == 0UL) &amp;&amp; JK_EXPECT_T(parseState-&gt;token.value.type == JKValueTypeString)) { <span class="keywordflow">return</span>(<span class="stringliteral">@&quot;&quot;</span>); }
<a name="l02003"></a>02003   
<a name="l02004"></a>02004   <span class="keywordflow">for</span>(x = 0UL; x &lt; JK_CACHE_PROBES; x++) {
<a name="l02005"></a>02005     <span class="keywordflow">if</span>(JK_EXPECT_F(parseState-&gt;cache.items[bucket].object == NULL)) { setBucket = 1UL; useableBucket = bucket; <span class="keywordflow">break</span>; }
<a name="l02006"></a>02006     
<a name="l02007"></a>02007     <span class="keywordflow">if</span>((JK_EXPECT_T(parseState-&gt;cache.items[bucket].hash == parseState-&gt;token.value.hash)) &amp;&amp; (JK_EXPECT_T(parseState-&gt;cache.items[bucket].size == parseState-&gt;token.value.ptrRange.length)) &amp;&amp; (JK_EXPECT_T(parseState-&gt;cache.items[bucket].type == parseState-&gt;token.value.type)) &amp;&amp; (JK_EXPECT_T(parseState-&gt;cache.items[bucket].bytes != NULL)) &amp;&amp; (JK_EXPECT_T(strncmp((<span class="keyword">const</span> <span class="keywordtype">char</span> *)parseState-&gt;cache.items[bucket].bytes, (<span class="keyword">const</span> <span class="keywordtype">char</span> *)parseState-&gt;token.value.ptrRange.ptr, parseState-&gt;token.value.ptrRange.length) == 0U))) {
<a name="l02008"></a>02008       parseState-&gt;cache.age[bucket]     = (parseState-&gt;cache.age[bucket] &lt;&lt; 1) | 1U;
<a name="l02009"></a>02009       parseState-&gt;token.value.cacheItem = &amp;parseState-&gt;cache.items[bucket];
<a name="l02010"></a>02010       NSCParameterAssert(parseState-&gt;cache.items[bucket].object != NULL);
<a name="l02011"></a>02011       <span class="keywordflow">return</span>((<span class="keywordtype">void</span> *)CFRetain(parseState-&gt;cache.items[bucket].object));
<a name="l02012"></a>02012     } <span class="keywordflow">else</span> {
<a name="l02013"></a>02013       <span class="keywordflow">if</span>(JK_EXPECT_F(setBucket == 0UL) &amp;&amp; JK_EXPECT_F(parseState-&gt;cache.age[bucket] == 0U)) { setBucket = 1UL; useableBucket = bucket; }
<a name="l02014"></a>02014       <span class="keywordflow">if</span>(JK_EXPECT_F(setBucket == 0UL))                                                     { parseState-&gt;cache.age[bucket] &gt;&gt;= 1; jk_cache_age(parseState); jk_cache_age(parseState); }
<a name="l02015"></a>02015       <span class="comment">// This is the open addressing function.  The values length and type are used as a form of &quot;double hashing&quot; to distribute values with the same effective value hash across different object cache buckets.</span>
<a name="l02016"></a>02016       <span class="comment">// The values type is a prime number that is relatively coprime to the other primes in the set of value types and the number of hash table buckets.</span>
<a name="l02017"></a>02017       bucket = (parseState-&gt;token.value.hash + (parseState-&gt;token.value.ptrRange.length * (x + 1UL)) + (parseState-&gt;token.value.type * (x + 1UL)) + (3UL * (x + 1UL))) &amp; (parseState-&gt;cache.count - 1UL);
<a name="l02018"></a>02018     }
<a name="l02019"></a>02019   }
<a name="l02020"></a>02020   
<a name="l02021"></a>02021   <span class="keywordflow">switch</span>(parseState-&gt;token.value.type) {
<a name="l02022"></a>02022     <span class="keywordflow">case</span> JKValueTypeString:           parsedAtom = (<span class="keywordtype">void</span> *)CFStringCreateWithBytes(NULL, parseState-&gt;token.value.ptrRange.ptr, parseState-&gt;token.value.ptrRange.length, kCFStringEncodingUTF8, 0); <span class="keywordflow">break</span>;
<a name="l02023"></a>02023     <span class="keywordflow">case</span> JKValueTypeLongLong:         parsedAtom = (<span class="keywordtype">void</span> *)CFNumberCreate(NULL, kCFNumberLongLongType, &amp;parseState-&gt;token.value.number.longLongValue);                                             <span class="keywordflow">break</span>;
<a name="l02024"></a>02024     <span class="keywordflow">case</span> JKValueTypeUnsignedLongLong:
<a name="l02025"></a>02025       <span class="keywordflow">if</span>(parseState-&gt;token.value.number.unsignedLongLongValue &lt;= LLONG_MAX) { parsedAtom = (<span class="keywordtype">void</span> *)CFNumberCreate(NULL, kCFNumberLongLongType, &amp;parseState-&gt;token.value.number.unsignedLongLongValue); }
<a name="l02026"></a>02026       <span class="keywordflow">else</span> { parsedAtom = (<span class="keywordtype">void</span> *)parseState-&gt;objCImpCache.NSNumberInitWithUnsignedLongLong(parseState-&gt;objCImpCache.NSNumberAlloc(parseState-&gt;objCImpCache.NSNumberClass, <span class="keyword">@selector</span>(alloc)), <span class="keyword">@selector</span>(initWithUnsignedLongLong:), parseState-&gt;token.value.number.unsignedLongLongValue); }
<a name="l02027"></a>02027       <span class="keywordflow">break</span>;
<a name="l02028"></a>02028     <span class="keywordflow">case</span> JKValueTypeDouble:           parsedAtom = (<span class="keywordtype">void</span> *)CFNumberCreate(NULL, kCFNumberDoubleType,   &amp;parseState-&gt;token.value.number.doubleValue);                                               <span class="keywordflow">break</span>;
<a name="l02029"></a>02029     <span class="keywordflow">default</span>: jk_error(parseState, <span class="stringliteral">@&quot;Internal error: Unknown token value type. %@ line #%ld&quot;</span>, [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithUTF8String:__FILE__], (<span class="keywordtype">long</span>)__LINE__); <span class="keywordflow">break</span>;
<a name="l02030"></a>02030   }
<a name="l02031"></a>02031   
<a name="l02032"></a>02032   <span class="keywordflow">if</span>(JK_EXPECT_T(setBucket) &amp;&amp; (JK_EXPECT_T(parsedAtom != NULL))) {
<a name="l02033"></a>02033     bucket = useableBucket;
<a name="l02034"></a>02034     <span class="keywordflow">if</span>(JK_EXPECT_T((parseState-&gt;cache.items[bucket].object != NULL))) { CFRelease(parseState-&gt;cache.items[bucket].object); parseState-&gt;cache.items[bucket].object = NULL; }
<a name="l02035"></a>02035     
<a name="l02036"></a>02036     <span class="keywordflow">if</span>(JK_EXPECT_T((parseState-&gt;cache.items[bucket].bytes = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)reallocf(parseState-&gt;cache.items[bucket].bytes, parseState-&gt;token.value.ptrRange.length)) != NULL)) {
<a name="l02037"></a>02037       memcpy(parseState-&gt;cache.items[bucket].bytes, parseState-&gt;token.value.ptrRange.ptr, parseState-&gt;token.value.ptrRange.length);
<a name="l02038"></a>02038       parseState-&gt;cache.items[bucket].object = (<span class="keywordtype">void</span> *)CFRetain(parsedAtom);
<a name="l02039"></a>02039       parseState-&gt;cache.items[bucket].hash   = parseState-&gt;token.value.hash;
<a name="l02040"></a>02040       parseState-&gt;cache.items[bucket].cfHash = 0UL;
<a name="l02041"></a>02041       parseState-&gt;cache.items[bucket].size   = parseState-&gt;token.value.ptrRange.length;
<a name="l02042"></a>02042       parseState-&gt;cache.items[bucket].type   = parseState-&gt;token.value.type;
<a name="l02043"></a>02043       parseState-&gt;token.value.cacheItem      = &amp;parseState-&gt;cache.items[bucket];
<a name="l02044"></a>02044       parseState-&gt;cache.age[bucket]          = JK_INIT_CACHE_AGE;
<a name="l02045"></a>02045     } <span class="keywordflow">else</span> { <span class="comment">// The realloc failed, so clear the appropriate fields.</span>
<a name="l02046"></a>02046       parseState-&gt;cache.items[bucket].hash   = 0UL;
<a name="l02047"></a>02047       parseState-&gt;cache.items[bucket].cfHash = 0UL;
<a name="l02048"></a>02048       parseState-&gt;cache.items[bucket].size   = 0UL;
<a name="l02049"></a>02049       parseState-&gt;cache.items[bucket].type   = 0UL;
<a name="l02050"></a>02050     }
<a name="l02051"></a>02051   }
<a name="l02052"></a>02052   
<a name="l02053"></a>02053   <span class="keywordflow">return</span>(parsedAtom);
<a name="l02054"></a>02054 }
<a name="l02055"></a>02055 
<a name="l02056"></a>02056 
<a name="l02057"></a>02057 <span class="keyword">static</span> <span class="keywordtype">void</span> *jk_object_for_token(JKParseState *parseState) {
<a name="l02058"></a>02058   <span class="keywordtype">void</span> *parsedAtom = NULL;
<a name="l02059"></a>02059   
<a name="l02060"></a>02060   parseState-&gt;token.value.cacheItem = NULL;
<a name="l02061"></a>02061   <span class="keywordflow">switch</span>(parseState-&gt;token.type) {
<a name="l02062"></a>02062     <span class="keywordflow">case</span> JKTokenTypeString:      parsedAtom = jk_cachedObjects(parseState);    <span class="keywordflow">break</span>;
<a name="l02063"></a>02063     <span class="keywordflow">case</span> JKTokenTypeNumber:      parsedAtom = jk_cachedObjects(parseState);    <span class="keywordflow">break</span>;
<a name="l02064"></a>02064     <span class="keywordflow">case</span> JKTokenTypeObjectBegin: parsedAtom = jk_parse_dictionary(parseState); <span class="keywordflow">break</span>;
<a name="l02065"></a>02065     <span class="keywordflow">case</span> JKTokenTypeArrayBegin:  parsedAtom = jk_parse_array(parseState);      <span class="keywordflow">break</span>;
<a name="l02066"></a>02066     <span class="keywordflow">case</span> JKTokenTypeTrue:        parsedAtom = (<span class="keywordtype">void</span> *)kCFBooleanTrue;          <span class="keywordflow">break</span>;
<a name="l02067"></a>02067     <span class="keywordflow">case</span> JKTokenTypeFalse:       parsedAtom = (<span class="keywordtype">void</span> *)kCFBooleanFalse;         <span class="keywordflow">break</span>;
<a name="l02068"></a>02068     <span class="keywordflow">case</span> JKTokenTypeNull:        parsedAtom = (<span class="keywordtype">void</span> *)kCFNull;                 <span class="keywordflow">break</span>;
<a name="l02069"></a>02069     <span class="keywordflow">default</span>: jk_error(parseState, <span class="stringliteral">@&quot;Internal error: Unknown token type. %@ line #%ld&quot;</span>, [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithUTF8String:__FILE__], (<span class="keywordtype">long</span>)__LINE__); <span class="keywordflow">break</span>;
<a name="l02070"></a>02070   }
<a name="l02071"></a>02071   
<a name="l02072"></a>02072   <span class="keywordflow">return</span>(parsedAtom);
<a name="l02073"></a>02073 }
<a name="l02074"></a>02074 
<a name="l02075"></a>02075 <span class="preprocessor">#pragma mark -</span>
<a name="l02076"></a>02076 <span class="preprocessor"></span><span class="keyword">@implementation </span>JSONDecoder
<a name="l02077"></a>02077 
<a name="l02078"></a>02078 + (id)decoder
<a name="l02079"></a>02079 {
<a name="l02080"></a>02080   <span class="keywordflow">return</span>([<span class="keyword">self</span> decoderWithParseOptions:JKParseOptionStrict]);
<a name="l02081"></a>02081 }
<a name="l02082"></a>02082 
<a name="l02083"></a>02083 + (id)decoderWithParseOptions:(JKParseOptionFlags)parseOptionFlags
<a name="l02084"></a>02084 {
<a name="l02085"></a>02085   <span class="keywordflow">return</span>([[[<span class="keyword">self</span> alloc] initWithParseOptions:parseOptionFlags] autorelease]);
<a name="l02086"></a>02086 }
<a name="l02087"></a>02087 
<a name="l02088"></a>02088 - (id)init
<a name="l02089"></a>02089 {
<a name="l02090"></a>02090   <span class="keywordflow">return</span>([<span class="keyword">self</span> initWithParseOptions:JKParseOptionStrict]);
<a name="l02091"></a>02091 }
<a name="l02092"></a>02092 
<a name="l02093"></a>02093 - (id)initWithParseOptions:(JKParseOptionFlags)parseOptionFlags
<a name="l02094"></a>02094 {
<a name="l02095"></a>02095   <span class="keywordflow">if</span>((<span class="keyword">self</span> = [super init]) == NULL) { <span class="keywordflow">return</span>(NULL); }
<a name="l02096"></a>02096 
<a name="l02097"></a>02097   <span class="keywordflow">if</span>(parseOptionFlags &amp; ~JKParseOptionValidFlags) { [<span class="keyword">self</span> autorelease]; [NSException raise:NSInvalidArgumentException format:@&quot;Invalid parse options.&quot;]; }
<a name="l02098"></a>02098 
<a name="l02099"></a>02099   <span class="keywordflow">if</span>((parseState = (JKParseState *)calloc(1UL, <span class="keyword">sizeof</span>(JKParseState))) == NULL) { <span class="keywordflow">goto</span> errorExit; }
<a name="l02100"></a>02100 
<a name="l02101"></a>02101   parseState-&gt;parseOptionFlags = parseOptionFlags;
<a name="l02102"></a>02102   
<a name="l02103"></a>02103   parseState-&gt;token.tokenBuffer.roundSizeUpToMultipleOf = 4096UL;
<a name="l02104"></a>02104   parseState-&gt;objectStack.roundSizeUpToMultipleOf       = 2048UL;
<a name="l02105"></a>02105 
<a name="l02106"></a>02106   parseState-&gt;objCImpCache.NSNumberClass                    = _jk_NSNumberClass;
<a name="l02107"></a>02107   parseState-&gt;objCImpCache.NSNumberAlloc                    = _jk_NSNumberAllocImp;
<a name="l02108"></a>02108   parseState-&gt;objCImpCache.NSNumberInitWithUnsignedLongLong = _jk_NSNumberInitWithUnsignedLongLongImp;
<a name="l02109"></a>02109   
<a name="l02110"></a>02110   parseState-&gt;cache.prng_lfsr = 1U;
<a name="l02111"></a>02111   parseState-&gt;cache.count     = JK_CACHE_SLOTS;
<a name="l02112"></a>02112   <span class="keywordflow">if</span>((parseState-&gt;cache.items = (JKTokenCacheItem *)calloc(1UL, <span class="keyword">sizeof</span>(JKTokenCacheItem) * parseState-&gt;cache.count)) == NULL) { <span class="keywordflow">goto</span> errorExit; }
<a name="l02113"></a>02113 
<a name="l02114"></a>02114   <span class="keywordflow">return</span>(<span class="keyword">self</span>);
<a name="l02115"></a>02115 
<a name="l02116"></a>02116  errorExit:
<a name="l02117"></a>02117   <span class="keywordflow">if</span>(<span class="keyword">self</span>) { [<span class="keyword">self</span> autorelease]; <span class="keyword">self</span> = NULL; }
<a name="l02118"></a>02118   <span class="keywordflow">return</span>(NULL);
<a name="l02119"></a>02119 }
<a name="l02120"></a>02120 
<a name="l02121"></a>02121 <span class="comment">// This is here primarily to support the NSString and NSData convenience functions so the autoreleased JSONDecoder can release most of its resources before the pool pops.</span>
<a name="l02122"></a>02122 <span class="keyword">static</span> <span class="keywordtype">void</span> _JSONDecoderCleanup(JSONDecoder *decoder) {
<a name="l02123"></a>02123   <span class="keywordflow">if</span>((decoder != NULL) &amp;&amp; (decoder-&gt;parseState != NULL)) {
<a name="l02124"></a>02124     jk_managedBuffer_release(&amp;decoder-&gt;parseState-&gt;token.tokenBuffer);
<a name="l02125"></a>02125     jk_objectStack_release(&amp;decoder-&gt;parseState-&gt;objectStack);
<a name="l02126"></a>02126     
<a name="l02127"></a>02127     [decoder clearCache];
<a name="l02128"></a>02128     <span class="keywordflow">if</span>(decoder-&gt;parseState-&gt;cache.items != NULL) { free(decoder-&gt;parseState-&gt;cache.items); decoder-&gt;parseState-&gt;cache.items = NULL; }
<a name="l02129"></a>02129     
<a name="l02130"></a>02130     free(decoder-&gt;parseState); decoder-&gt;parseState = NULL;
<a name="l02131"></a>02131   }
<a name="l02132"></a>02132 }
<a name="l02133"></a>02133 
<a name="l02134"></a>02134 - (void)dealloc
<a name="l02135"></a>02135 {
<a name="l02136"></a>02136   _JSONDecoderCleanup(<span class="keyword">self</span>);
<a name="l02137"></a>02137   [<span class="keyword">super</span> dealloc];
<a name="l02138"></a>02138 }
<a name="l02139"></a>02139 
<a name="l02140"></a>02140 - (void)clearCache
<a name="l02141"></a>02141 {
<a name="l02142"></a>02142   <span class="keywordflow">if</span>(JK_EXPECT_T(parseState != NULL)) {
<a name="l02143"></a>02143     <span class="keywordflow">if</span>(JK_EXPECT_T(parseState-&gt;cache.items != NULL)) {
<a name="l02144"></a>02144       <span class="keywordtype">size_t</span> idx = 0UL;
<a name="l02145"></a>02145       <span class="keywordflow">for</span>(idx = 0UL; idx &lt; parseState-&gt;cache.count; idx++) {
<a name="l02146"></a>02146         <span class="keywordflow">if</span>(JK_EXPECT_T(parseState-&gt;cache.items[idx].object != NULL)) { CFRelease(parseState-&gt;cache.items[idx].object); parseState-&gt;cache.items[idx].object = NULL; }
<a name="l02147"></a>02147         <span class="keywordflow">if</span>(JK_EXPECT_T(parseState-&gt;cache.items[idx].bytes  != NULL)) { free(parseState-&gt;cache.items[idx].bytes);       parseState-&gt;cache.items[idx].bytes  = NULL; }
<a name="l02148"></a>02148         memset(&amp;parseState-&gt;cache.items[idx], 0, <span class="keyword">sizeof</span>(JKTokenCacheItem));
<a name="l02149"></a>02149         parseState-&gt;cache.age[idx] = 0U;
<a name="l02150"></a>02150       }
<a name="l02151"></a>02151     }
<a name="l02152"></a>02152   }
<a name="l02153"></a>02153 }
<a name="l02154"></a>02154 
<a name="l02155"></a>02155 <span class="comment">// This needs to be completely rewritten.</span>
<a name="l02156"></a>02156 <span class="keyword">static</span> <span class="keywordtype">id</span> _JKParseUTF8String(JKParseState *parseState, BOOL mutableCollections, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>, <span class="keywordtype">size_t</span> length, NSError **error) {
<a name="l02157"></a>02157   NSCParameterAssert((parseState != NULL) &amp;&amp; (<span class="keywordtype">string</span> != NULL) &amp;&amp; (parseState-&gt;cache.prng_lfsr != 0U));
<a name="l02158"></a>02158   parseState-&gt;stringBuffer.bytes.ptr    = string;
<a name="l02159"></a>02159   parseState-&gt;stringBuffer.bytes.length = length;
<a name="l02160"></a>02160   parseState-&gt;atIndex                   = 0UL;
<a name="l02161"></a>02161   parseState-&gt;lineNumber                = 1UL;
<a name="l02162"></a>02162   parseState-&gt;lineStartIndex            = 0UL;
<a name="l02163"></a>02163   parseState-&gt;prev_atIndex              = 0UL;
<a name="l02164"></a>02164   parseState-&gt;prev_lineNumber           = 1UL;
<a name="l02165"></a>02165   parseState-&gt;prev_lineStartIndex       = 0UL;
<a name="l02166"></a>02166   parseState-&gt;error                     = NULL;
<a name="l02167"></a>02167   parseState-&gt;errorIsPrev               = 0;
<a name="l02168"></a>02168   parseState-&gt;mutableCollections        = (mutableCollections == NO) ? NO : YES;
<a name="l02169"></a>02169   
<a name="l02170"></a>02170   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> stackTokenBuffer[JK_TOKENBUFFER_SIZE] JK_ALIGNED(64);
<a name="l02171"></a>02171   jk_managedBuffer_setToStackBuffer(&amp;parseState-&gt;token.tokenBuffer, stackTokenBuffer, <span class="keyword">sizeof</span>(stackTokenBuffer));
<a name="l02172"></a>02172   
<a name="l02173"></a>02173   <span class="keywordtype">void</span>       *stackObjects [JK_STACK_OBJS] JK_ALIGNED(64);
<a name="l02174"></a>02174   <span class="keywordtype">void</span>       *stackKeys    [JK_STACK_OBJS] JK_ALIGNED(64);
<a name="l02175"></a>02175   CFHashCode  stackCFHashes[JK_STACK_OBJS] JK_ALIGNED(64);
<a name="l02176"></a>02176   jk_objectStack_setToStackBuffer(&amp;parseState-&gt;objectStack, stackObjects, stackKeys, stackCFHashes, JK_STACK_OBJS);
<a name="l02177"></a>02177   
<a name="l02178"></a>02178   <span class="keywordtype">id</span> parsedJSON = json_parse_it(parseState);
<a name="l02179"></a>02179   
<a name="l02180"></a>02180   <span class="keywordflow">if</span>((error != NULL) &amp;&amp; (parseState-&gt;error != NULL)) { *error = parseState-&gt;error; }
<a name="l02181"></a>02181   
<a name="l02182"></a>02182   jk_managedBuffer_release(&amp;parseState-&gt;token.tokenBuffer);
<a name="l02183"></a>02183   jk_objectStack_release(&amp;parseState-&gt;objectStack);
<a name="l02184"></a>02184   
<a name="l02185"></a>02185   parseState-&gt;stringBuffer.bytes.ptr    = NULL;
<a name="l02186"></a>02186   parseState-&gt;stringBuffer.bytes.length = 0UL;
<a name="l02187"></a>02187   parseState-&gt;atIndex                   = 0UL;
<a name="l02188"></a>02188   parseState-&gt;lineNumber                = 1UL;
<a name="l02189"></a>02189   parseState-&gt;lineStartIndex            = 0UL;
<a name="l02190"></a>02190   parseState-&gt;prev_atIndex              = 0UL;
<a name="l02191"></a>02191   parseState-&gt;prev_lineNumber           = 1UL;
<a name="l02192"></a>02192   parseState-&gt;prev_lineStartIndex       = 0UL;
<a name="l02193"></a>02193   parseState-&gt;error                     = NULL;
<a name="l02194"></a>02194   parseState-&gt;errorIsPrev               = 0;
<a name="l02195"></a>02195   parseState-&gt;mutableCollections        = NO;
<a name="l02196"></a>02196   
<a name="l02197"></a>02197   <span class="keywordflow">return</span>(parsedJSON);
<a name="l02198"></a>02198 }
<a name="l02199"></a>02199 
<a name="l02201"></a>02201 <span class="preprocessor">#pragma mark Deprecated as of v1.4</span>
<a name="l02202"></a>02202 <span class="preprocessor"></span>
<a name="l02203"></a>02203 
<a name="l02204"></a>02204 <span class="comment">// Deprecated in JSONKit v1.4.  Use objectWithUTF8String:length: instead.</span>
<a name="l02205"></a>02205 - (id)parseUTF8String:(const <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)string length:(<span class="keywordtype">size_t</span>)length
<a name="l02206"></a>02206 {
<a name="l02207"></a>02207   <span class="keywordflow">return</span>([<span class="keyword">self</span> objectWithUTF8String:<span class="keywordtype">string</span> length:length error:NULL]);
<a name="l02208"></a>02208 }
<a name="l02209"></a>02209 
<a name="l02210"></a>02210 <span class="comment">// Deprecated in JSONKit v1.4.  Use objectWithUTF8String:length:error: instead.</span>
<a name="l02211"></a>02211 - (id)parseUTF8String:(const <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)string length:(<span class="keywordtype">size_t</span>)length error:(NSError **)error
<a name="l02212"></a>02212 {
<a name="l02213"></a>02213   <span class="keywordflow">return</span>([<span class="keyword">self</span> objectWithUTF8String:<span class="keywordtype">string</span> length:length error:error]);
<a name="l02214"></a>02214 }
<a name="l02215"></a>02215 
<a name="l02216"></a>02216 <span class="comment">// Deprecated in JSONKit v1.4.  Use objectWithData: instead.</span>
<a name="l02217"></a>02217 - (id)parseJSONData:(<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)jsonData
<a name="l02218"></a>02218 {
<a name="l02219"></a>02219   <span class="keywordflow">return</span>([<span class="keyword">self</span> objectWithData:jsonData error:NULL]);
<a name="l02220"></a>02220 }
<a name="l02221"></a>02221 
<a name="l02222"></a>02222 <span class="comment">// Deprecated in JSONKit v1.4.  Use objectWithData:error: instead.</span>
<a name="l02223"></a>02223 - (id)parseJSONData:(<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)jsonData error:(NSError **)error
<a name="l02224"></a>02224 {
<a name="l02225"></a>02225   <span class="keywordflow">return</span>([<span class="keyword">self</span> objectWithData:jsonData error:error]);
<a name="l02226"></a>02226 }
<a name="l02227"></a>02227 
<a name="l02229"></a>02229 <span class="preprocessor">#pragma mark Methods that return immutable collection objects</span>
<a name="l02230"></a>02230 <span class="preprocessor"></span>
<a name="l02231"></a>02231 
<a name="l02232"></a>02232 - (id)objectWithUTF8String:(const <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)string length:(NSUInteger)length
<a name="l02233"></a>02233 {
<a name="l02234"></a>02234   <span class="keywordflow">return</span>([<span class="keyword">self</span> objectWithUTF8String:<span class="keywordtype">string</span> length:length error:NULL]);
<a name="l02235"></a>02235 }
<a name="l02236"></a>02236 
<a name="l02237"></a>02237 - (id)objectWithUTF8String:(const <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)string length:(NSUInteger)length error:(NSError **)error
<a name="l02238"></a>02238 {
<a name="l02239"></a>02239   <span class="keywordflow">if</span>(parseState == NULL) { [NSException raise:NSInternalInconsistencyException format:@&quot;parseState is NULL.&quot;];          }
<a name="l02240"></a>02240   <span class="keywordflow">if</span>(<span class="keywordtype">string</span>     == NULL) { [NSException raise:NSInvalidArgumentException       format:@&quot;The string argument is NULL.&quot;]; }
<a name="l02241"></a>02241   
<a name="l02242"></a>02242   <span class="keywordflow">return</span>(_JKParseUTF8String(parseState, NO, <span class="keywordtype">string</span>, (<span class="keywordtype">size_t</span>)length, error));
<a name="l02243"></a>02243 }
<a name="l02244"></a>02244 
<a name="l02245"></a>02245 - (id)objectWithData:(<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)jsonData
<a name="l02246"></a>02246 {
<a name="l02247"></a>02247   <span class="keywordflow">return</span>([<span class="keyword">self</span> objectWithData:jsonData error:NULL]);
<a name="l02248"></a>02248 }
<a name="l02249"></a>02249 
<a name="l02250"></a>02250 - (id)objectWithData:(<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)jsonData error:(NSError **)error
<a name="l02251"></a>02251 {
<a name="l02252"></a>02252   <span class="keywordflow">if</span>(jsonData == NULL) { [NSException raise:NSInvalidArgumentException format:@&quot;The jsonData argument is NULL.&quot;]; }
<a name="l02253"></a>02253   <span class="keywordflow">return</span>([<span class="keyword">self</span> objectWithUTF8String:(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)[jsonData bytes] length:[jsonData length] error:error]);
<a name="l02254"></a>02254 }
<a name="l02255"></a>02255 
<a name="l02257"></a>02257 <span class="preprocessor">#pragma mark Methods that return mutable collection objects</span>
<a name="l02258"></a>02258 <span class="preprocessor"></span>
<a name="l02259"></a>02259 
<a name="l02260"></a>02260 - (id)mutableObjectWithUTF8String:(const <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)string length:(NSUInteger)length
<a name="l02261"></a>02261 {
<a name="l02262"></a>02262   <span class="keywordflow">return</span>([<span class="keyword">self</span> mutableObjectWithUTF8String:<span class="keywordtype">string</span> length:length error:NULL]);
<a name="l02263"></a>02263 }
<a name="l02264"></a>02264 
<a name="l02265"></a>02265 - (id)mutableObjectWithUTF8String:(const <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)string length:(NSUInteger)length error:(NSError **)error
<a name="l02266"></a>02266 {
<a name="l02267"></a>02267   <span class="keywordflow">if</span>(parseState == NULL) { [NSException raise:NSInternalInconsistencyException format:@&quot;parseState is NULL.&quot;];          }
<a name="l02268"></a>02268   <span class="keywordflow">if</span>(<span class="keywordtype">string</span>     == NULL) { [NSException raise:NSInvalidArgumentException       format:@&quot;The string argument is NULL.&quot;]; }
<a name="l02269"></a>02269   
<a name="l02270"></a>02270   <span class="keywordflow">return</span>(_JKParseUTF8String(parseState, YES, <span class="keywordtype">string</span>, (<span class="keywordtype">size_t</span>)length, error));
<a name="l02271"></a>02271 }
<a name="l02272"></a>02272 
<a name="l02273"></a>02273 - (id)mutableObjectWithData:(<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)jsonData
<a name="l02274"></a>02274 {
<a name="l02275"></a>02275   <span class="keywordflow">return</span>([<span class="keyword">self</span> mutableObjectWithData:jsonData error:NULL]);
<a name="l02276"></a>02276 }
<a name="l02277"></a>02277 
<a name="l02278"></a>02278 - (id)mutableObjectWithData:(<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)jsonData error:(NSError **)error
<a name="l02279"></a>02279 {
<a name="l02280"></a>02280   <span class="keywordflow">if</span>(jsonData == NULL) { [NSException raise:NSInvalidArgumentException format:@&quot;The jsonData argument is NULL.&quot;]; }
<a name="l02281"></a>02281   <span class="keywordflow">return</span>([<span class="keyword">self</span> mutableObjectWithUTF8String:(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)[jsonData bytes] length:[jsonData length] error:error]);
<a name="l02282"></a>02282 }
<a name="l02283"></a>02283 
<a name="l02284"></a>02284 <span class="keyword">@end</span>
<a name="l02285"></a>02285 
<a name="l02286"></a>02286 <span class="comment">/*</span>
<a name="l02287"></a>02287 <span class="comment"> The NSString and NSData convenience methods need a little bit of explanation.</span>
<a name="l02288"></a>02288 <span class="comment"> </span>
<a name="l02289"></a>02289 <span class="comment"> Prior to JSONKit v1.4, the NSString -objectFromJSONStringWithParseOptions:error: method looked like</span>
<a name="l02290"></a>02290 <span class="comment"> </span>
<a name="l02291"></a>02291 <span class="comment"> const unsigned char *utf8String = (const unsigned char *)[self UTF8String];</span>
<a name="l02292"></a>02292 <span class="comment"> if(utf8String == NULL) { return(NULL); }</span>
<a name="l02293"></a>02293 <span class="comment"> size_t               utf8Length = strlen((const char *)utf8String); </span>
<a name="l02294"></a>02294 <span class="comment"> return([[JSONDecoder decoderWithParseOptions:parseOptionFlags] parseUTF8String:utf8String length:utf8Length error:error]);</span>
<a name="l02295"></a>02295 <span class="comment"> </span>
<a name="l02296"></a>02296 <span class="comment"> This changed with v1.4 to a more complicated method.  The reason for this is to keep the amount of memory that is</span>
<a name="l02297"></a>02297 <span class="comment"> allocated, but not yet freed because it is dependent on the autorelease pool to pop before it can be reclaimed.</span>
<a name="l02298"></a>02298 <span class="comment"> </span>
<a name="l02299"></a>02299 <span class="comment"> In the simpler v1.3 code, this included all the bytes used to store the -UTF8String along with the JSONDecoder and all its overhead.</span>
<a name="l02300"></a>02300 <span class="comment"> </span>
<a name="l02301"></a>02301 <span class="comment"> Now we use an autoreleased CFMutableData that is sized to the UTF8 length of the NSString in question and is used to hold the UTF8</span>
<a name="l02302"></a>02302 <span class="comment"> conversion of said string.</span>
<a name="l02303"></a>02303 <span class="comment"> </span>
<a name="l02304"></a>02304 <span class="comment"> Once parsed, the CFMutableData has its length set to 0.  This should, hopefully, allow the CFMutableData to realloc and/or free</span>
<a name="l02305"></a>02305 <span class="comment"> the buffer.</span>
<a name="l02306"></a>02306 <span class="comment"> </span>
<a name="l02307"></a>02307 <span class="comment"> Another change made was a slight modification to JSONDecoder so that most of the cleanup work that was done in -dealloc was moved</span>
<a name="l02308"></a>02308 <span class="comment"> to a private, internal function.  These convenience routines keep the pointer to the autoreleased JSONDecoder and calls</span>
<a name="l02309"></a>02309 <span class="comment"> _JSONDecoderCleanup() to early release the decoders resources since we already know that particular decoder is not going to be used</span>
<a name="l02310"></a>02310 <span class="comment"> again.  </span>
<a name="l02311"></a>02311 <span class="comment"> </span>
<a name="l02312"></a>02312 <span class="comment"> If everything goes smoothly, this will most likely result in perhaps a few hundred bytes that are allocated but waiting for the</span>
<a name="l02313"></a>02313 <span class="comment"> autorelease pool to pop.  This is compared to the thousands and easily hundreds of thousands of bytes that would have been in</span>
<a name="l02314"></a>02314 <span class="comment"> autorelease limbo.  It&#39;s more complicated for us, but a win for the user.</span>
<a name="l02315"></a>02315 <span class="comment"> </span>
<a name="l02316"></a>02316 <span class="comment"> Autorelease objects are used in case things don&#39;t go smoothly.  By having them autoreleased, we effectively guarantee that our</span>
<a name="l02317"></a>02317 <span class="comment"> requirement to -release the object is always met, not matter what goes wrong.  The downside is having a an object or two in</span>
<a name="l02318"></a>02318 <span class="comment"> autorelease limbo, but we&#39;ve done our best to minimize that impact, so it all balances out.</span>
<a name="l02319"></a>02319 <span class="comment"> */</span>
<a name="l02320"></a>02320 
<a name="l02321"></a>02321 <span class="keyword">@implementation </span><a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> (JSONKitDeserializing)
<a name="l02322"></a>02322 
<a name="l02323"></a>02323 <span class="keyword">static</span> <span class="keywordtype">id</span> _NSStringObjectFromJSONString(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *jsonString, JKParseOptionFlags parseOptionFlags, NSError **error, BOOL mutableCollection) {
<a name="l02324"></a>02324   <span class="keywordtype">id</span>                returnObject = NULL;
<a name="l02325"></a>02325   CFMutableDataRef  mutableData  = NULL;
<a name="l02326"></a>02326   JSONDecoder      *decoder      = NULL;
<a name="l02327"></a>02327   
<a name="l02328"></a>02328   CFIndex    stringLength     = CFStringGetLength((CFStringRef)jsonString);
<a name="l02329"></a>02329   NSUInteger stringUTF8Length = [jsonString lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
<a name="l02330"></a>02330   
<a name="l02331"></a>02331   <span class="keywordflow">if</span>((mutableData = (CFMutableDataRef)[(<span class="keywordtype">id</span>)CFDataCreateMutable(NULL, (NSUInteger)stringUTF8Length) autorelease]) != NULL) {
<a name="l02332"></a>02332     UInt8   *utf8String = CFDataGetMutableBytePtr(mutableData);
<a name="l02333"></a>02333     CFIndex  usedBytes  = 0L, convertedCount = 0L;
<a name="l02334"></a>02334     
<a name="l02335"></a>02335     convertedCount = CFStringGetBytes((CFStringRef)jsonString, CFRangeMake(0L, stringLength), kCFStringEncodingUTF8, <span class="charliteral">&#39;?&#39;</span>, NO, utf8String, (NSUInteger)stringUTF8Length, &amp;usedBytes);
<a name="l02336"></a>02336     <span class="keywordflow">if</span>(JK_EXPECT_F(convertedCount != stringLength) || JK_EXPECT_F(usedBytes &lt; 0L)) { <span class="keywordflow">if</span>(error != NULL) { *error = [NSError errorWithDomain:@&quot;JKErrorDomain&quot; code:-1L userInfo:[NSDictionary dictionaryWithObject:@&quot;An error occurred converting the contents of a NSString to UTF8.&quot; forKey:NSLocalizedDescriptionKey]]; } <span class="keywordflow">goto</span> exitNow; }
<a name="l02337"></a>02337     
<a name="l02338"></a>02338     <span class="keywordflow">if</span>(mutableCollection == NO) { returnObject = [(decoder = [JSONDecoder decoderWithParseOptions:parseOptionFlags])        objectWithUTF8String:(const unsigned char *)utf8String length:(size_t)usedBytes error:error]; }
<a name="l02339"></a>02339     <span class="keywordflow">else</span>                        { returnObject = [(decoder = [JSONDecoder decoderWithParseOptions:parseOptionFlags]) mutableObjectWithUTF8String:(const unsigned char *)utf8String length:(size_t)usedBytes error:error]; }
<a name="l02340"></a>02340   }
<a name="l02341"></a>02341   
<a name="l02342"></a>02342 exitNow:
<a name="l02343"></a>02343   <span class="keywordflow">if</span>(mutableData != NULL) { CFDataSetLength(mutableData, 0L); }
<a name="l02344"></a>02344   <span class="keywordflow">if</span>(decoder     != NULL) { _JSONDecoderCleanup(decoder);     }
<a name="l02345"></a>02345   <span class="keywordflow">return</span>(returnObject);
<a name="l02346"></a>02346 }
<a name="l02347"></a>02347 
<a name="l02348"></a>02348 - (id)objectFromJSONString
<a name="l02349"></a>02349 {
<a name="l02350"></a>02350   <span class="keywordflow">return</span>([<span class="keyword">self</span> objectFromJSONStringWithParseOptions:JKParseOptionStrict error:NULL]);
<a name="l02351"></a>02351 }
<a name="l02352"></a>02352 
<a name="l02353"></a>02353 - (id)objectFromJSONStringWithParseOptions:(JKParseOptionFlags)parseOptionFlags
<a name="l02354"></a>02354 {
<a name="l02355"></a>02355   <span class="keywordflow">return</span>([<span class="keyword">self</span> objectFromJSONStringWithParseOptions:parseOptionFlags error:NULL]);
<a name="l02356"></a>02356 }
<a name="l02357"></a>02357 
<a name="l02358"></a>02358 - (id)objectFromJSONStringWithParseOptions:(JKParseOptionFlags)parseOptionFlags error:(NSError **)error
<a name="l02359"></a>02359 {
<a name="l02360"></a>02360   <span class="keywordflow">return</span>(_NSStringObjectFromJSONString(<span class="keyword">self</span>, parseOptionFlags, error, NO));
<a name="l02361"></a>02361 }
<a name="l02362"></a>02362 
<a name="l02363"></a>02363 
<a name="l02364"></a>02364 - (id)mutableObjectFromJSONString
<a name="l02365"></a>02365 {
<a name="l02366"></a>02366   <span class="keywordflow">return</span>([<span class="keyword">self</span> mutableObjectFromJSONStringWithParseOptions:JKParseOptionStrict error:NULL]);
<a name="l02367"></a>02367 }
<a name="l02368"></a>02368 
<a name="l02369"></a>02369 - (id)mutableObjectFromJSONStringWithParseOptions:(JKParseOptionFlags)parseOptionFlags
<a name="l02370"></a>02370 {
<a name="l02371"></a>02371   <span class="keywordflow">return</span>([<span class="keyword">self</span> mutableObjectFromJSONStringWithParseOptions:parseOptionFlags error:NULL]);
<a name="l02372"></a>02372 }
<a name="l02373"></a>02373 
<a name="l02374"></a>02374 - (id)mutableObjectFromJSONStringWithParseOptions:(JKParseOptionFlags)parseOptionFlags error:(NSError **)error
<a name="l02375"></a>02375 {
<a name="l02376"></a>02376   <span class="keywordflow">return</span>(_NSStringObjectFromJSONString(<span class="keyword">self</span>, parseOptionFlags, error, YES));
<a name="l02377"></a>02377 }
<a name="l02378"></a>02378 
<a name="l02379"></a>02379 <span class="keyword">@end</span>
<a name="l02380"></a>02380 
<a name="l02381"></a>02381 <span class="keyword">@implementation </span><a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> (JSONKitDeserializing)
<a name="l02382"></a>02382 
<a name="l02383"></a>02383 - (id)objectFromJSONData
<a name="l02384"></a>02384 {
<a name="l02385"></a>02385   <span class="keywordflow">return</span>([<span class="keyword">self</span> objectFromJSONDataWithParseOptions:JKParseOptionStrict error:NULL]);
<a name="l02386"></a>02386 }
<a name="l02387"></a>02387 
<a name="l02388"></a>02388 - (id)objectFromJSONDataWithParseOptions:(JKParseOptionFlags)parseOptionFlags
<a name="l02389"></a>02389 {
<a name="l02390"></a>02390   <span class="keywordflow">return</span>([<span class="keyword">self</span> objectFromJSONDataWithParseOptions:parseOptionFlags error:NULL]);
<a name="l02391"></a>02391 }
<a name="l02392"></a>02392 
<a name="l02393"></a>02393 - (id)objectFromJSONDataWithParseOptions:(JKParseOptionFlags)parseOptionFlags error:(NSError **)error
<a name="l02394"></a>02394 {
<a name="l02395"></a>02395   JSONDecoder *decoder = NULL;
<a name="l02396"></a>02396   <span class="keywordtype">id</span> returnObject = [(decoder = [JSONDecoder decoderWithParseOptions:parseOptionFlags]) objectWithData:self error:error];
<a name="l02397"></a>02397   <span class="keywordflow">if</span>(decoder != NULL) { _JSONDecoderCleanup(decoder); }
<a name="l02398"></a>02398   <span class="keywordflow">return</span>(returnObject);
<a name="l02399"></a>02399 }
<a name="l02400"></a>02400 
<a name="l02401"></a>02401 - (id)mutableObjectFromJSONData
<a name="l02402"></a>02402 {
<a name="l02403"></a>02403   <span class="keywordflow">return</span>([<span class="keyword">self</span> mutableObjectFromJSONDataWithParseOptions:JKParseOptionStrict error:NULL]);
<a name="l02404"></a>02404 }
<a name="l02405"></a>02405 
<a name="l02406"></a>02406 - (id)mutableObjectFromJSONDataWithParseOptions:(JKParseOptionFlags)parseOptionFlags
<a name="l02407"></a>02407 {
<a name="l02408"></a>02408   <span class="keywordflow">return</span>([<span class="keyword">self</span> mutableObjectFromJSONDataWithParseOptions:parseOptionFlags error:NULL]);
<a name="l02409"></a>02409 }
<a name="l02410"></a>02410 
<a name="l02411"></a>02411 - (id)mutableObjectFromJSONDataWithParseOptions:(JKParseOptionFlags)parseOptionFlags error:(NSError **)error
<a name="l02412"></a>02412 {
<a name="l02413"></a>02413   JSONDecoder *decoder = NULL;
<a name="l02414"></a>02414   <span class="keywordtype">id</span> returnObject = [(decoder = [JSONDecoder decoderWithParseOptions:parseOptionFlags]) mutableObjectWithData:self error:error];
<a name="l02415"></a>02415   <span class="keywordflow">if</span>(decoder != NULL) { _JSONDecoderCleanup(decoder); }
<a name="l02416"></a>02416   <span class="keywordflow">return</span>(returnObject);
<a name="l02417"></a>02417 }
<a name="l02418"></a>02418 
<a name="l02419"></a>02419 
<a name="l02420"></a>02420 <span class="keyword">@end</span>
<a name="l02421"></a>02421 
<a name="l02423"></a>02423 <span class="preprocessor">#pragma mark -</span>
<a name="l02424"></a>02424 <span class="preprocessor"></span><span class="preprocessor">#pragma mark Encoding / deserializing functions</span>
<a name="l02425"></a>02425 <span class="preprocessor"></span>
<a name="l02426"></a>02426 <span class="keyword">static</span> <span class="keywordtype">void</span> jk_encode_error(JKEncodeState *encodeState, <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *format, ...) {
<a name="l02427"></a>02427   NSCParameterAssert((encodeState != NULL) &amp;&amp; (format != NULL));
<a name="l02428"></a>02428 
<a name="l02429"></a>02429   va_list varArgsList;
<a name="l02430"></a>02430   va_start(varArgsList, format);
<a name="l02431"></a>02431   <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *formatString = [[[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> alloc] initWithFormat:format arguments:varArgsList] autorelease];
<a name="l02432"></a>02432   va_end(varArgsList);
<a name="l02433"></a>02433 
<a name="l02434"></a>02434   <span class="keywordflow">if</span>(encodeState-&gt;error == NULL) {
<a name="l02435"></a>02435     encodeState-&gt;error = [NSError errorWithDomain:@&quot;JKErrorDomain&quot; code:-1L userInfo:
<a name="l02436"></a>02436                                    [NSDictionary dictionaryWithObjectsAndKeys:
<a name="l02437"></a>02437                                                                               formatString, NSLocalizedDescriptionKey,
<a name="l02438"></a>02438                                                                               NULL]];
<a name="l02439"></a>02439   }
<a name="l02440"></a>02440 }
<a name="l02441"></a>02441 
<a name="l02442"></a>02442 JK_STATIC_INLINE <span class="keywordtype">void</span> jk_encode_updateCache(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, <span class="keywordtype">size_t</span> startingAtIndex, <span class="keywordtype">id</span> <span class="keywordtype">object</span>) {
<a name="l02443"></a>02443   NSCParameterAssert(encodeState != NULL);
<a name="l02444"></a>02444   <span class="keywordflow">if</span>(JK_EXPECT_T(cacheSlot != NULL)) {
<a name="l02445"></a>02445     NSCParameterAssert((<span class="keywordtype">object</span> != NULL) &amp;&amp; (startingAtIndex &lt;= encodeState-&gt;atIndex));
<a name="l02446"></a>02446     cacheSlot-&gt;object = object;
<a name="l02447"></a>02447     cacheSlot-&gt;offset = startingAtIndex;
<a name="l02448"></a>02448     cacheSlot-&gt;length = (size_t)(encodeState-&gt;atIndex - startingAtIndex);  
<a name="l02449"></a>02449   }
<a name="l02450"></a>02450 }
<a name="l02451"></a>02451 
<a name="l02452"></a>02452 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_encode_printf(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, <span class="keywordtype">size_t</span> startingAtIndex, <span class="keywordtype">id</span> <span class="keywordtype">object</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...) {
<a name="l02453"></a>02453   va_list varArgsList, varArgsListCopy;
<a name="l02454"></a>02454   va_start(varArgsList, format);
<a name="l02455"></a>02455   va_copy(varArgsListCopy, varArgsList);
<a name="l02456"></a>02456 
<a name="l02457"></a>02457   NSCParameterAssert((encodeState != NULL) &amp;&amp; (encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; (startingAtIndex &lt;= encodeState-&gt;atIndex) &amp;&amp; (format != NULL));
<a name="l02458"></a>02458 
<a name="l02459"></a>02459   ssize_t  formattedStringLength = 0L;
<a name="l02460"></a>02460   <span class="keywordtype">int</span>      returnValue           = 0;
<a name="l02461"></a>02461 
<a name="l02462"></a>02462   <span class="keywordflow">if</span>(JK_EXPECT_T((formattedStringLength = vsnprintf((<span class="keywordtype">char</span> *)&amp;encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex], (encodeState-&gt;stringBuffer.bytes.length - encodeState-&gt;atIndex), format, varArgsList)) &gt;= (ssize_t)(encodeState-&gt;stringBuffer.bytes.length - encodeState-&gt;atIndex))) {
<a name="l02463"></a>02463     NSCParameterAssert(((encodeState-&gt;atIndex + (formattedStringLength * 2UL) + 256UL) &gt; encodeState-&gt;stringBuffer.bytes.length));
<a name="l02464"></a>02464     <span class="keywordflow">if</span>(JK_EXPECT_F(((encodeState-&gt;atIndex + (formattedStringLength * 2UL) + 256UL) &gt; encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp; JK_EXPECT_F((jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + (formattedStringLength * 2UL)+ 4096UL) == NULL))) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to resize temporary buffer.&quot;</span>); returnValue = 1; <span class="keywordflow">goto</span> exitNow; }
<a name="l02465"></a>02465     <span class="keywordflow">if</span>(JK_EXPECT_F((formattedStringLength = vsnprintf((<span class="keywordtype">char</span> *)&amp;encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex], (encodeState-&gt;stringBuffer.bytes.length - encodeState-&gt;atIndex), format, varArgsListCopy)) &gt;= (ssize_t)(encodeState-&gt;stringBuffer.bytes.length - encodeState-&gt;atIndex))) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;vsnprintf failed unexpectedly.&quot;</span>); returnValue = 1; <span class="keywordflow">goto</span> exitNow; }
<a name="l02466"></a>02466   }
<a name="l02467"></a>02467   
<a name="l02468"></a>02468 exitNow:
<a name="l02469"></a>02469   va_end(varArgsList);
<a name="l02470"></a>02470   va_end(varArgsListCopy);
<a name="l02471"></a>02471   <span class="keywordflow">if</span>(JK_EXPECT_T(returnValue == 0)) { encodeState-&gt;atIndex += formattedStringLength; jk_encode_updateCache(encodeState, cacheSlot, startingAtIndex, <span class="keywordtype">object</span>); }
<a name="l02472"></a>02472   <span class="keywordflow">return</span>(returnValue);
<a name="l02473"></a>02473 }
<a name="l02474"></a>02474 
<a name="l02475"></a>02475 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_encode_write(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, <span class="keywordtype">size_t</span> startingAtIndex, <span class="keywordtype">id</span> <span class="keywordtype">object</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *format) {
<a name="l02476"></a>02476   NSCParameterAssert((encodeState != NULL) &amp;&amp; (encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; (startingAtIndex &lt;= encodeState-&gt;atIndex) &amp;&amp; (format != NULL));
<a name="l02477"></a>02477   <span class="keywordflow">if</span>(JK_EXPECT_F(((encodeState-&gt;atIndex + strlen(format) + 256UL) &gt; encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp; JK_EXPECT_F((jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + strlen(format) + 1024UL) == NULL))) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to resize temporary buffer.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02478"></a>02478 
<a name="l02479"></a>02479   <span class="keywordtype">size_t</span> formatIdx = 0UL;
<a name="l02480"></a>02480   <span class="keywordflow">for</span>(formatIdx = 0UL; format[formatIdx] != 0; formatIdx++) { NSCParameterAssert(encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length); encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = format[formatIdx]; }
<a name="l02481"></a>02481   jk_encode_updateCache(encodeState, cacheSlot, startingAtIndex, <span class="keywordtype">object</span>);
<a name="l02482"></a>02482   <span class="keywordflow">return</span>(0);
<a name="l02483"></a>02483 }
<a name="l02484"></a>02484 
<a name="l02485"></a>02485 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_encode_writePrettyPrintWhiteSpace(JKEncodeState *encodeState) {
<a name="l02486"></a>02486   NSCParameterAssert((encodeState != NULL) &amp;&amp; ((encodeState-&gt;serializeOptionFlags &amp; JKSerializeOptionPretty) != 0UL));
<a name="l02487"></a>02487   <span class="keywordflow">if</span>(JK_EXPECT_F((encodeState-&gt;atIndex + ((encodeState-&gt;depth + 1UL) * 2UL) + 16UL) &gt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; JK_EXPECT_T(jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + ((encodeState-&gt;depth + 1UL) * 2UL) + 4096UL) == NULL)) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to resize temporary buffer.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02488"></a>02488   encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\n&#39;</span>;
<a name="l02489"></a>02489   <span class="keywordtype">size_t</span> depthWhiteSpace = 0UL;
<a name="l02490"></a>02490   <span class="keywordflow">for</span>(depthWhiteSpace = 0UL; depthWhiteSpace &lt; (encodeState-&gt;depth * 2UL); depthWhiteSpace++) { NSCParameterAssert(encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length); encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39; &#39;</span>; }
<a name="l02491"></a>02491   <span class="keywordflow">return</span>(0);
<a name="l02492"></a>02492 }  
<a name="l02493"></a>02493 
<a name="l02494"></a>02494 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_encode_write1slow(JKEncodeState *encodeState, ssize_t depthChange, <span class="keyword">const</span> <span class="keywordtype">char</span> *format) {
<a name="l02495"></a>02495   NSCParameterAssert((encodeState != NULL) &amp;&amp; (encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; (format != NULL) &amp;&amp; ((depthChange &gt;= -1L) &amp;&amp; (depthChange &lt;= 1L)) &amp;&amp; ((encodeState-&gt;depth == 0UL) ? (depthChange &gt;= 0L) : 1) &amp;&amp; ((encodeState-&gt;serializeOptionFlags &amp; JKSerializeOptionPretty) != 0UL));
<a name="l02496"></a>02496   <span class="keywordflow">if</span>(JK_EXPECT_F((encodeState-&gt;atIndex + ((encodeState-&gt;depth + 1UL) * 2UL) + 16UL) &gt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; JK_EXPECT_F(jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + ((encodeState-&gt;depth + 1UL) * 2UL) + 4096UL) == NULL)) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to resize temporary buffer.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02497"></a>02497   encodeState-&gt;depth += depthChange;
<a name="l02498"></a>02498   <span class="keywordflow">if</span>(JK_EXPECT_T(format[0] == <span class="charliteral">&#39;:&#39;</span>)) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = format[0]; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39; &#39;</span>; }
<a name="l02499"></a>02499   <span class="keywordflow">else</span> {
<a name="l02500"></a>02500     <span class="keywordflow">if</span>(JK_EXPECT_F(depthChange == -1L)) { <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_writePrettyPrintWhiteSpace(encodeState))) { <span class="keywordflow">return</span>(1); } }
<a name="l02501"></a>02501     encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = format[0];
<a name="l02502"></a>02502     <span class="keywordflow">if</span>(JK_EXPECT_T(depthChange != -1L)) { <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_writePrettyPrintWhiteSpace(encodeState))) { <span class="keywordflow">return</span>(1); } }
<a name="l02503"></a>02503   }
<a name="l02504"></a>02504   NSCParameterAssert(encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length);
<a name="l02505"></a>02505   <span class="keywordflow">return</span>(0);
<a name="l02506"></a>02506 }
<a name="l02507"></a>02507 
<a name="l02508"></a>02508 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_encode_write1fast(JKEncodeState *encodeState, ssize_t depthChange JK_UNUSED_ARG, <span class="keyword">const</span> <span class="keywordtype">char</span> *format) {
<a name="l02509"></a>02509   NSCParameterAssert((encodeState != NULL) &amp;&amp; (encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; ((encodeState-&gt;serializeOptionFlags &amp; JKSerializeOptionPretty) == 0UL));
<a name="l02510"></a>02510   <span class="keywordflow">if</span>(JK_EXPECT_T((encodeState-&gt;atIndex + 4UL) &lt; encodeState-&gt;stringBuffer.bytes.length)) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = format[0]; }
<a name="l02511"></a>02511   <span class="keywordflow">else</span> { <span class="keywordflow">return</span>(jk_encode_write(encodeState, NULL, 0UL, NULL, format)); }
<a name="l02512"></a>02512   <span class="keywordflow">return</span>(0);
<a name="l02513"></a>02513 }
<a name="l02514"></a>02514 
<a name="l02515"></a>02515 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_encode_writen(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, <span class="keywordtype">size_t</span> startingAtIndex, <span class="keywordtype">id</span> <span class="keywordtype">object</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *format, <span class="keywordtype">size_t</span> length) {
<a name="l02516"></a>02516   NSCParameterAssert((encodeState != NULL) &amp;&amp; (encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; (startingAtIndex &lt;= encodeState-&gt;atIndex));
<a name="l02517"></a>02517   <span class="keywordflow">if</span>(JK_EXPECT_F((encodeState-&gt;stringBuffer.bytes.length - encodeState-&gt;atIndex) &lt; (length + 4UL))) { <span class="keywordflow">if</span>(jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + 4096UL + length) == NULL) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to resize temporary buffer.&quot;</span>); <span class="keywordflow">return</span>(1); } }
<a name="l02518"></a>02518   memcpy(encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;atIndex, format, length);
<a name="l02519"></a>02519   encodeState-&gt;atIndex += length;
<a name="l02520"></a>02520   jk_encode_updateCache(encodeState, cacheSlot, startingAtIndex, <span class="keywordtype">object</span>);
<a name="l02521"></a>02521   <span class="keywordflow">return</span>(0);
<a name="l02522"></a>02522 }
<a name="l02523"></a>02523 
<a name="l02524"></a>02524 JK_STATIC_INLINE JKHash jk_encode_object_hash(<span class="keywordtype">void</span> *objectPtr) {
<a name="l02525"></a>02525   <span class="keywordflow">return</span>( ( (((JKHash)objectPtr) &gt;&gt; 21) ^ (((JKHash)objectPtr) &gt;&gt; 9)   ) + (((JKHash)objectPtr) &gt;&gt; 4) );
<a name="l02526"></a>02526 }
<a name="l02527"></a>02527 
<a name="l02528"></a>02528 <span class="keyword">static</span> <span class="keywordtype">int</span> jk_encode_add_atom_to_buffer(JKEncodeState *encodeState, <span class="keywordtype">void</span> *objectPtr) {
<a name="l02529"></a>02529   NSCParameterAssert((encodeState != NULL) &amp;&amp; (encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; (objectPtr != NULL));
<a name="l02530"></a>02530 
<a name="l02531"></a>02531   <span class="keywordtype">id</span>     <span class="keywordtype">object</span>          = (id)objectPtr, encodeCacheObject = <span class="keywordtype">object</span>;
<a name="l02532"></a>02532   <span class="keywordtype">int</span>    isClass         = JKClassUnknown;
<a name="l02533"></a>02533   <span class="keywordtype">size_t</span> startingAtIndex = encodeState-&gt;atIndex;
<a name="l02534"></a>02534 
<a name="l02535"></a>02535   JKHash         objectHash = jk_encode_object_hash(objectPtr);
<a name="l02536"></a>02536   JKEncodeCache *cacheSlot  = &amp;encodeState-&gt;cache[objectHash % JK_ENCODE_CACHE_SLOTS];
<a name="l02537"></a>02537 
<a name="l02538"></a>02538   <span class="keywordflow">if</span>(JK_EXPECT_T(cacheSlot-&gt;object == <span class="keywordtype">object</span>)) {
<a name="l02539"></a>02539     NSCParameterAssert((cacheSlot-&gt;object != NULL) &amp;&amp;
<a name="l02540"></a>02540                        (cacheSlot-&gt;offset &lt; encodeState-&gt;atIndex)                   &amp;&amp; ((cacheSlot-&gt;offset + cacheSlot-&gt;length) &lt; encodeState-&gt;atIndex)                                    &amp;&amp;
<a name="l02541"></a>02541                        (cacheSlot-&gt;offset &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; ((cacheSlot-&gt;offset + cacheSlot-&gt;length) &lt; encodeState-&gt;stringBuffer.bytes.length)                  &amp;&amp;
<a name="l02542"></a>02542                        ((encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;atIndex)                     &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp;
<a name="l02543"></a>02543                        ((encodeState-&gt;stringBuffer.bytes.ptr + cacheSlot-&gt;offset)                        &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp;
<a name="l02544"></a>02544                        ((encodeState-&gt;stringBuffer.bytes.ptr + cacheSlot-&gt;offset + cacheSlot-&gt;length)    &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;stringBuffer.bytes.length)));
<a name="l02545"></a>02545     <span class="keywordflow">if</span>(JK_EXPECT_F(((encodeState-&gt;atIndex + cacheSlot-&gt;length + 256UL) &gt; encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp; JK_EXPECT_F((jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + cacheSlot-&gt;length + 1024UL) == NULL))) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to resize temporary buffer.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02546"></a>02546     NSCParameterAssert(((encodeState-&gt;atIndex + cacheSlot-&gt;length) &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp;
<a name="l02547"></a>02547                        ((encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;atIndex)                     &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp;
<a name="l02548"></a>02548                        ((encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;atIndex + cacheSlot-&gt;length) &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp;
<a name="l02549"></a>02549                        ((encodeState-&gt;stringBuffer.bytes.ptr + cacheSlot-&gt;offset)                        &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp;
<a name="l02550"></a>02550                        ((encodeState-&gt;stringBuffer.bytes.ptr + cacheSlot-&gt;offset + cacheSlot-&gt;length)    &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp;
<a name="l02551"></a>02551                        ((encodeState-&gt;stringBuffer.bytes.ptr + cacheSlot-&gt;offset + cacheSlot-&gt;length)    &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;atIndex)));
<a name="l02552"></a>02552     memcpy(encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;atIndex, encodeState-&gt;stringBuffer.bytes.ptr + cacheSlot-&gt;offset, cacheSlot-&gt;length);
<a name="l02553"></a>02553     encodeState-&gt;atIndex += cacheSlot-&gt;length;
<a name="l02554"></a>02554     <span class="keywordflow">return</span>(0);
<a name="l02555"></a>02555   }
<a name="l02556"></a>02556 
<a name="l02557"></a>02557   <span class="comment">// When we encounter a class that we do not handle, and we have either a delegate or block that the user supplied to format unsupported classes,</span>
<a name="l02558"></a>02558   <span class="comment">// we &quot;re-run&quot; the object check.  However, we re-run the object check exactly ONCE.  If the user supplies an object that isn&#39;t one of the</span>
<a name="l02559"></a>02559   <span class="comment">// supported classes, we fail the second type (i.e., double fault error).</span>
<a name="l02560"></a>02560   BOOL rerunningAfterClassFormatter = NO;
<a name="l02561"></a>02561 rerunAfterClassFormatter:
<a name="l02562"></a>02562        <span class="keywordflow">if</span>(JK_EXPECT_T(object-&gt;isa == encodeState-&gt;fastClassLookup.stringClass))     { isClass = JKClassString;     }
<a name="l02563"></a>02563   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T(object-&gt;isa == encodeState-&gt;fastClassLookup.numberClass))     { isClass = JKClassNumber;     }
<a name="l02564"></a>02564   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T(object-&gt;isa == encodeState-&gt;fastClassLookup.dictionaryClass)) { isClass = JKClassDictionary; }
<a name="l02565"></a>02565   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T(object-&gt;isa == encodeState-&gt;fastClassLookup.arrayClass))      { isClass = JKClassArray;      }
<a name="l02566"></a>02566   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T(object-&gt;isa == encodeState-&gt;fastClassLookup.nullClass))       { isClass = JKClassNull;       }
<a name="l02567"></a>02567   <span class="keywordflow">else</span> {
<a name="l02568"></a>02568          <span class="keywordflow">if</span>(JK_EXPECT_T([<span class="keywordtype">object</span> isKindOfClass:[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a>     <span class="keyword">class</span>]])) { encodeState-&gt;fastClassLookup.stringClass     = <span class="keywordtype">object</span>-&gt;isa; isClass = JKClassString;     }
<a name="l02569"></a>02569     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T([<span class="keywordtype">object</span> isKindOfClass:[NSNumber     <span class="keyword">class</span>]])) { encodeState-&gt;fastClassLookup.numberClass     = <span class="keywordtype">object</span>-&gt;isa; isClass = JKClassNumber;     }
<a name="l02570"></a>02570     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T([<span class="keywordtype">object</span> isKindOfClass:[NSDictionary <span class="keyword">class</span>]])) { encodeState-&gt;fastClassLookup.dictionaryClass = <span class="keywordtype">object</span>-&gt;isa; isClass = JKClassDictionary; }
<a name="l02571"></a>02571     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T([<span class="keywordtype">object</span> isKindOfClass:[NSArray      <span class="keyword">class</span>]])) { encodeState-&gt;fastClassLookup.arrayClass      = <span class="keywordtype">object</span>-&gt;isa; isClass = JKClassArray;      }
<a name="l02572"></a>02572     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(JK_EXPECT_T([<span class="keywordtype">object</span> isKindOfClass:[NSNull       <span class="keyword">class</span>]])) { encodeState-&gt;fastClassLookup.nullClass       = <span class="keywordtype">object</span>-&gt;isa; isClass = JKClassNull;       }
<a name="l02573"></a>02573     <span class="keywordflow">else</span> {
<a name="l02574"></a>02574       <span class="keywordflow">if</span>((rerunningAfterClassFormatter == NO) &amp;&amp; (
<a name="l02575"></a>02575 #ifdef __BLOCKS__
<a name="l02576"></a>02576            ((encodeState-&gt;classFormatterBlock) &amp;&amp; ((<span class="keywordtype">object</span> = encodeState-&gt;classFormatterBlock(<span class="keywordtype">object</span>))                                                                         != NULL)) ||
<a name="l02577"></a>02577 #endif
<a name="l02578"></a>02578            ((encodeState-&gt;classFormatterIMP)   &amp;&amp; ((<span class="keywordtype">object</span> = encodeState-&gt;classFormatterIMP(encodeState-&gt;classFormatterDelegate, encodeState-&gt;classFormatterSelector, <span class="keywordtype">object</span>)) != NULL))    )) { rerunningAfterClassFormatter = YES; <span class="keywordflow">goto</span> rerunAfterClassFormatter; }
<a name="l02579"></a>02579       
<a name="l02580"></a>02580       <span class="keywordflow">if</span>(rerunningAfterClassFormatter == NO) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to serialize object class %@.&quot;</span>, NSStringFromClass([encodeCacheObject <span class="keyword">class</span>])); <span class="keywordflow">return</span>(1); }
<a name="l02581"></a>02581       <span class="keywordflow">else</span> { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to serialize object class %@ that was returned by the unsupported class formatter.  Original object class was %@.&quot;</span>, (<span class="keywordtype">object</span> == NULL) ? <span class="stringliteral">@&quot;NULL&quot;</span> : NSStringFromClass([<span class="keywordtype">object</span> <span class="keyword">class</span>]), NSStringFromClass([encodeCacheObject <span class="keyword">class</span>])); <span class="keywordflow">return</span>(1); }
<a name="l02582"></a>02582     }
<a name="l02583"></a>02583   }
<a name="l02584"></a>02584 
<a name="l02585"></a>02585   <span class="comment">// This is here for the benefit of the optimizer.  It allows the optimizer to do loop invariant code motion for the JKClassArray</span>
<a name="l02586"></a>02586   <span class="comment">// and JKClassDictionary cases when printing simple, single characters via jk_encode_write(), which is actually a macro:</span>
<a name="l02587"></a>02587   <span class="comment">// #define jk_encode_write1(es, dc, f) (_jk_encode_prettyPrint ? jk_encode_write1slow(es, dc, f) : jk_encode_write1fast(es, dc, f))</span>
<a name="l02588"></a>02588   <span class="keywordtype">int</span> _jk_encode_prettyPrint = JK_EXPECT_T((encodeState-&gt;serializeOptionFlags &amp; JKSerializeOptionPretty) == 0) ? 0 : 1;
<a name="l02589"></a>02589   
<a name="l02590"></a>02590   <span class="keywordflow">switch</span>(isClass) {
<a name="l02591"></a>02591     <span class="keywordflow">case</span> JKClassString:
<a name="l02592"></a>02592       {
<a name="l02593"></a>02593         {
<a name="l02594"></a>02594           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *cStringPtr = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)CFStringGetCStringPtr((CFStringRef)object, kCFStringEncodingMacRoman);
<a name="l02595"></a>02595           <span class="keywordflow">if</span>(cStringPtr != NULL) {
<a name="l02596"></a>02596             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *utf8String = cStringPtr;
<a name="l02597"></a>02597             <span class="keywordtype">size_t</span>               utf8Idx    = 0UL;
<a name="l02598"></a>02598 
<a name="l02599"></a>02599             CFIndex stringLength = CFStringGetLength((CFStringRef)<span class="keywordtype">object</span>);
<a name="l02600"></a>02600             <span class="keywordflow">if</span>(JK_EXPECT_F(((encodeState-&gt;atIndex + (stringLength * 2UL) + 256UL) &gt; encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp; JK_EXPECT_F((jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + (stringLength * 2UL) + 1024UL) == NULL))) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to resize temporary buffer.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02601"></a>02601 
<a name="l02602"></a>02602             <span class="keywordflow">if</span>(JK_EXPECT_T((encodeState-&gt;encodeOption &amp; JKEncodeOptionStringObjTrimQuotes) == 0UL)) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\&quot;&#39;</span>; }
<a name="l02603"></a>02603             <span class="keywordflow">for</span>(utf8Idx = 0UL; utf8String[utf8Idx] != 0U; utf8Idx++) {
<a name="l02604"></a>02604               NSCParameterAssert(((&amp;encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex]) - encodeState-&gt;stringBuffer.bytes.ptr) &lt; (ssize_t)encodeState-&gt;stringBuffer.bytes.length);
<a name="l02605"></a>02605               NSCParameterAssert(encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length);
<a name="l02606"></a>02606               <span class="keywordflow">if</span>(JK_EXPECT_F(utf8String[utf8Idx] &gt;= 0x80U)) { encodeState-&gt;atIndex = startingAtIndex; <span class="keywordflow">goto</span> slowUTF8Path; }
<a name="l02607"></a>02607               <span class="keywordflow">if</span>(JK_EXPECT_F(utf8String[utf8Idx] &lt;  0x20U)) {
<a name="l02608"></a>02608                 <span class="keywordflow">switch</span>(utf8String[utf8Idx]) {
<a name="l02609"></a>02609                   <span class="keywordflow">case</span> <span class="charliteral">&#39;\b&#39;</span>: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\\&#39;</span>; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;b&#39;</span>; <span class="keywordflow">break</span>;
<a name="l02610"></a>02610                   <span class="keywordflow">case</span> <span class="charliteral">&#39;\f&#39;</span>: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\\&#39;</span>; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;f&#39;</span>; <span class="keywordflow">break</span>;
<a name="l02611"></a>02611                   <span class="keywordflow">case</span> <span class="charliteral">&#39;\n&#39;</span>: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\\&#39;</span>; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;n&#39;</span>; <span class="keywordflow">break</span>;
<a name="l02612"></a>02612                   <span class="keywordflow">case</span> <span class="charliteral">&#39;\r&#39;</span>: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\\&#39;</span>; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;r&#39;</span>; <span class="keywordflow">break</span>;
<a name="l02613"></a>02613                   <span class="keywordflow">case</span> <span class="charliteral">&#39;\t&#39;</span>: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\\&#39;</span>; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;t&#39;</span>; <span class="keywordflow">break</span>;
<a name="l02614"></a>02614                   <span class="keywordflow">default</span>: <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_printf(encodeState, NULL, 0UL, NULL, <span class="stringliteral">&quot;\\u%4.4x&quot;</span>, utf8String[utf8Idx]))) { <span class="keywordflow">return</span>(1); } <span class="keywordflow">break</span>;
<a name="l02615"></a>02615                 }
<a name="l02616"></a>02616               } <span class="keywordflow">else</span> {
<a name="l02617"></a>02617                 <span class="keywordflow">if</span>(JK_EXPECT_F(utf8String[utf8Idx] == <span class="charliteral">&#39;\&quot;&#39;</span>) || JK_EXPECT_F(utf8String[utf8Idx] == <span class="charliteral">&#39;\\&#39;</span>) || (JK_EXPECT_F(encodeState-&gt;serializeOptionFlags &amp; JKSerializeOptionEscapeForwardSlashes) &amp;&amp; JK_EXPECT_F(utf8String[utf8Idx] == <span class="charliteral">&#39;/&#39;</span>))) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\\&#39;</span>; }
<a name="l02618"></a>02618                 encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = utf8String[utf8Idx];
<a name="l02619"></a>02619               }
<a name="l02620"></a>02620             }
<a name="l02621"></a>02621             NSCParameterAssert((encodeState-&gt;atIndex + 1UL) &lt; encodeState-&gt;stringBuffer.bytes.length);
<a name="l02622"></a>02622             <span class="keywordflow">if</span>(JK_EXPECT_T((encodeState-&gt;encodeOption &amp; JKEncodeOptionStringObjTrimQuotes) == 0UL)) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\&quot;&#39;</span>; }
<a name="l02623"></a>02623             jk_encode_updateCache(encodeState, cacheSlot, startingAtIndex, encodeCacheObject);
<a name="l02624"></a>02624             <span class="keywordflow">return</span>(0);
<a name="l02625"></a>02625           }
<a name="l02626"></a>02626         }
<a name="l02627"></a>02627 
<a name="l02628"></a>02628       slowUTF8Path:
<a name="l02629"></a>02629         {
<a name="l02630"></a>02630           CFIndex stringLength        = CFStringGetLength((CFStringRef)<span class="keywordtype">object</span>);
<a name="l02631"></a>02631           CFIndex maxStringUTF8Length = CFStringGetMaximumSizeForEncoding(stringLength, kCFStringEncodingUTF8) + 32L;
<a name="l02632"></a>02632         
<a name="l02633"></a>02633           <span class="keywordflow">if</span>(JK_EXPECT_F((<span class="keywordtype">size_t</span>)maxStringUTF8Length &gt; encodeState-&gt;utf8ConversionBuffer.bytes.length) &amp;&amp; JK_EXPECT_F(jk_managedBuffer_resize(&amp;encodeState-&gt;utf8ConversionBuffer, maxStringUTF8Length + 1024UL) == NULL)) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to resize temporary buffer.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02634"></a>02634         
<a name="l02635"></a>02635           CFIndex usedBytes = 0L, convertedCount = 0L;
<a name="l02636"></a>02636           convertedCount = CFStringGetBytes((CFStringRef)<span class="keywordtype">object</span>, CFRangeMake(0L, stringLength), kCFStringEncodingUTF8, <span class="charliteral">&#39;?&#39;</span>, NO, encodeState-&gt;utf8ConversionBuffer.bytes.ptr, encodeState-&gt;utf8ConversionBuffer.bytes.length - 16L, &amp;usedBytes);
<a name="l02637"></a>02637           <span class="keywordflow">if</span>(JK_EXPECT_F(convertedCount != stringLength) || JK_EXPECT_F(usedBytes &lt; 0L)) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;An error occurred converting the contents of a NSString to UTF8.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02638"></a>02638         
<a name="l02639"></a>02639           <span class="keywordflow">if</span>(JK_EXPECT_F((encodeState-&gt;atIndex + (maxStringUTF8Length * 2UL) + 256UL) &gt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; JK_EXPECT_F(jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + (maxStringUTF8Length * 2UL) + 1024UL) == NULL)) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to resize temporary buffer.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02640"></a>02640         
<a name="l02641"></a>02641           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *utf8String = encodeState-&gt;utf8ConversionBuffer.bytes.ptr;
<a name="l02642"></a>02642         
<a name="l02643"></a>02643           <span class="keywordtype">size_t</span> utf8Idx = 0UL;
<a name="l02644"></a>02644           <span class="keywordflow">if</span>(JK_EXPECT_T((encodeState-&gt;encodeOption &amp; JKEncodeOptionStringObjTrimQuotes) == 0UL)) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\&quot;&#39;</span>; }
<a name="l02645"></a>02645           <span class="keywordflow">for</span>(utf8Idx = 0UL; utf8Idx &lt; (size_t)usedBytes; utf8Idx++) {
<a name="l02646"></a>02646             NSCParameterAssert(((&amp;encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex]) - encodeState-&gt;stringBuffer.bytes.ptr) &lt; (ssize_t)encodeState-&gt;stringBuffer.bytes.length);
<a name="l02647"></a>02647             NSCParameterAssert(encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length);
<a name="l02648"></a>02648             NSCParameterAssert((CFIndex)utf8Idx &lt; usedBytes);
<a name="l02649"></a>02649             <span class="keywordflow">if</span>(JK_EXPECT_F(utf8String[utf8Idx] &lt; 0x20U)) {
<a name="l02650"></a>02650               <span class="keywordflow">switch</span>(utf8String[utf8Idx]) {
<a name="l02651"></a>02651                 <span class="keywordflow">case</span> <span class="charliteral">&#39;\b&#39;</span>: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\\&#39;</span>; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;b&#39;</span>; <span class="keywordflow">break</span>;
<a name="l02652"></a>02652                 <span class="keywordflow">case</span> <span class="charliteral">&#39;\f&#39;</span>: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\\&#39;</span>; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;f&#39;</span>; <span class="keywordflow">break</span>;
<a name="l02653"></a>02653                 <span class="keywordflow">case</span> <span class="charliteral">&#39;\n&#39;</span>: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\\&#39;</span>; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;n&#39;</span>; <span class="keywordflow">break</span>;
<a name="l02654"></a>02654                 <span class="keywordflow">case</span> <span class="charliteral">&#39;\r&#39;</span>: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\\&#39;</span>; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;r&#39;</span>; <span class="keywordflow">break</span>;
<a name="l02655"></a>02655                 <span class="keywordflow">case</span> <span class="charliteral">&#39;\t&#39;</span>: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\\&#39;</span>; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;t&#39;</span>; <span class="keywordflow">break</span>;
<a name="l02656"></a>02656                 <span class="keywordflow">default</span>: <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_printf(encodeState, NULL, 0UL, NULL, <span class="stringliteral">&quot;\\u%4.4x&quot;</span>, utf8String[utf8Idx]))) { <span class="keywordflow">return</span>(1); } <span class="keywordflow">break</span>;
<a name="l02657"></a>02657               }
<a name="l02658"></a>02658             } <span class="keywordflow">else</span> {
<a name="l02659"></a>02659               <span class="keywordflow">if</span>(JK_EXPECT_F(utf8String[utf8Idx] &gt;= 0x80U) &amp;&amp; (encodeState-&gt;serializeOptionFlags &amp; JKSerializeOptionEscapeUnicode)) {
<a name="l02660"></a>02660                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *nextValidCharacter = NULL;
<a name="l02661"></a>02661                 UTF32                u32ch              = 0U;
<a name="l02662"></a>02662                 ConversionResult     result;
<a name="l02663"></a>02663 
<a name="l02664"></a>02664                 <span class="keywordflow">if</span>(JK_EXPECT_F((result = ConvertSingleCodePointInUTF8(&amp;utf8String[utf8Idx], &amp;utf8String[usedBytes], (UTF8 <span class="keyword">const</span> **)&amp;nextValidCharacter, &amp;u32ch)) != conversionOK)) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Error converting UTF8.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02665"></a>02665                 <span class="keywordflow">else</span> {
<a name="l02666"></a>02666                   utf8Idx = (nextValidCharacter - utf8String) - 1UL;
<a name="l02667"></a>02667                   <span class="keywordflow">if</span>(JK_EXPECT_T(u32ch &lt;= 0xffffU)) { <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_printf(encodeState, NULL, 0UL, NULL, <span class="stringliteral">&quot;\\u%4.4x&quot;</span>, u32ch)))                                                           { <span class="keywordflow">return</span>(1); } }
<a name="l02668"></a>02668                   <span class="keywordflow">else</span>                              { <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_printf(encodeState, NULL, 0UL, NULL, <span class="stringliteral">&quot;\\u%4.4x\\u%4.4x&quot;</span>, (0xd7c0U + (u32ch &gt;&gt; 10)), (0xdc00U + (u32ch &amp; 0x3ffU))))) { <span class="keywordflow">return</span>(1); } }
<a name="l02669"></a>02669                 }
<a name="l02670"></a>02670               } <span class="keywordflow">else</span> {
<a name="l02671"></a>02671                 <span class="keywordflow">if</span>(JK_EXPECT_F(utf8String[utf8Idx] == <span class="charliteral">&#39;\&quot;&#39;</span>) || JK_EXPECT_F(utf8String[utf8Idx] == <span class="charliteral">&#39;\\&#39;</span>) || (JK_EXPECT_F(encodeState-&gt;serializeOptionFlags &amp; JKSerializeOptionEscapeForwardSlashes) &amp;&amp; JK_EXPECT_F(utf8String[utf8Idx] == <span class="charliteral">&#39;/&#39;</span>))) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\\&#39;</span>; }
<a name="l02672"></a>02672                 encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = utf8String[utf8Idx];
<a name="l02673"></a>02673               }
<a name="l02674"></a>02674             }
<a name="l02675"></a>02675           }
<a name="l02676"></a>02676           NSCParameterAssert((encodeState-&gt;atIndex + 1UL) &lt; encodeState-&gt;stringBuffer.bytes.length);
<a name="l02677"></a>02677           <span class="keywordflow">if</span>(JK_EXPECT_T((encodeState-&gt;encodeOption &amp; JKEncodeOptionStringObjTrimQuotes) == 0UL)) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = <span class="charliteral">&#39;\&quot;&#39;</span>; }
<a name="l02678"></a>02678           jk_encode_updateCache(encodeState, cacheSlot, startingAtIndex, encodeCacheObject);
<a name="l02679"></a>02679           <span class="keywordflow">return</span>(0);
<a name="l02680"></a>02680         }
<a name="l02681"></a>02681       }
<a name="l02682"></a>02682       <span class="keywordflow">break</span>;
<a name="l02683"></a>02683 
<a name="l02684"></a>02684     <span class="keywordflow">case</span> JKClassNumber:
<a name="l02685"></a>02685       {
<a name="l02686"></a>02686              <span class="keywordflow">if</span>(<span class="keywordtype">object</span> == (<span class="keywordtype">id</span>)kCFBooleanTrue)  { <span class="keywordflow">return</span>(jk_encode_writen(encodeState, cacheSlot, startingAtIndex, encodeCacheObject, <span class="stringliteral">&quot;true&quot;</span>,  4UL)); }
<a name="l02687"></a>02687         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<span class="keywordtype">object</span> == (<span class="keywordtype">id</span>)kCFBooleanFalse) { <span class="keywordflow">return</span>(jk_encode_writen(encodeState, cacheSlot, startingAtIndex, encodeCacheObject, <span class="stringliteral">&quot;false&quot;</span>, 5UL)); }
<a name="l02688"></a>02688         
<a name="l02689"></a>02689         <span class="keyword">const</span> <span class="keywordtype">char</span>         *objCType = [object objCType];
<a name="l02690"></a>02690         <span class="keywordtype">char</span>                anum[256], *aptr = &amp;anum[255];
<a name="l02691"></a>02691         <span class="keywordtype">int</span>                 isNegative = 0;
<a name="l02692"></a>02692         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>  ullv;
<a name="l02693"></a>02693         <span class="keywordtype">long</span> <span class="keywordtype">long</span>           llv;
<a name="l02694"></a>02694         
<a name="l02695"></a>02695         <span class="keywordflow">if</span>(JK_EXPECT_F(objCType == NULL) || JK_EXPECT_F(objCType[0] == 0) || JK_EXPECT_F(objCType[1] != 0)) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;NSNumber conversion error, unknown type.  Type: &#39;%s&#39;&quot;</span>, (objCType == NULL) ? <span class="stringliteral">&quot;&lt;NULL&gt;&quot;</span> : objCType); <span class="keywordflow">return</span>(1); }
<a name="l02696"></a>02696         
<a name="l02697"></a>02697         <span class="keywordflow">switch</span>(objCType[0]) {
<a name="l02698"></a>02698           <span class="keywordflow">case</span> <span class="charliteral">&#39;c&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;i&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;s&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;l&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;q&#39;</span>:
<a name="l02699"></a>02699             <span class="keywordflow">if</span>(JK_EXPECT_T(CFNumberGetValue((CFNumberRef)<span class="keywordtype">object</span>, kCFNumberLongLongType, &amp;llv)))  {
<a name="l02700"></a>02700               <span class="keywordflow">if</span>(llv &lt; 0LL)  { ullv = -llv; isNegative = 1; } <span class="keywordflow">else</span> { ullv = llv; isNegative = 0; }
<a name="l02701"></a>02701               <span class="keywordflow">goto</span> convertNumber;
<a name="l02702"></a>02702             } <span class="keywordflow">else</span> { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to get scalar value from number object.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02703"></a>02703             <span class="keywordflow">break</span>;
<a name="l02704"></a>02704           <span class="keywordflow">case</span> <span class="charliteral">&#39;C&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;I&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;S&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;L&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;Q&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;B&#39;</span>:
<a name="l02705"></a>02705             <span class="keywordflow">if</span>(JK_EXPECT_T(CFNumberGetValue((CFNumberRef)<span class="keywordtype">object</span>, kCFNumberLongLongType, &amp;ullv))) {
<a name="l02706"></a>02706             convertNumber:
<a name="l02707"></a>02707               <span class="keywordflow">if</span>(JK_EXPECT_F(ullv &lt; 10ULL)) { *--aptr = ullv + &#39;0&#39;; } <span class="keywordflow">else</span> { <span class="keywordflow">while</span>(JK_EXPECT_T(ullv &gt; 0ULL)) { *--aptr = (ullv % 10ULL) + &#39;0&#39;; ullv /= 10ULL; NSCParameterAssert(aptr &gt; anum); } }
<a name="l02708"></a>02708               <span class="keywordflow">if</span>(isNegative) { *--aptr = &#39;-&#39;; }
<a name="l02709"></a>02709               NSCParameterAssert(aptr &gt; anum);
<a name="l02710"></a>02710               <span class="keywordflow">return</span>(jk_encode_writen(encodeState, cacheSlot, startingAtIndex, encodeCacheObject, aptr, &amp;anum[255] - aptr));
<a name="l02711"></a>02711             } <span class="keywordflow">else</span> { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to get scalar value from number object.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02712"></a>02712             <span class="keywordflow">break</span>;
<a name="l02713"></a>02713           <span class="keywordflow">case</span> <span class="charliteral">&#39;f&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;d&#39;</span>:
<a name="l02714"></a>02714             {
<a name="l02715"></a>02715               <span class="keywordtype">double</span> dv;
<a name="l02716"></a>02716               <span class="keywordflow">if</span>(JK_EXPECT_T(CFNumberGetValue((CFNumberRef)<span class="keywordtype">object</span>, kCFNumberDoubleType, &amp;dv))) {
<a name="l02717"></a>02717                 <span class="keywordflow">if</span>(JK_EXPECT_F(!isfinite(dv))) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Floating point values must be finite.  JSON does not support NaN or Infinity.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02718"></a>02718                 <span class="keywordflow">return</span>(jk_encode_printf(encodeState, cacheSlot, startingAtIndex, encodeCacheObject, <span class="stringliteral">&quot;%.17g&quot;</span>, dv));
<a name="l02719"></a>02719               } <span class="keywordflow">else</span> { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to get floating point value from number object.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02720"></a>02720             }
<a name="l02721"></a>02721             <span class="keywordflow">break</span>;
<a name="l02722"></a>02722           <span class="keywordflow">default</span>: jk_encode_error(encodeState, <span class="stringliteral">@&quot;NSNumber conversion error, unknown type.  Type: &#39;%c&#39; / 0x%2.2x&quot;</span>, objCType[0], objCType[0]); <span class="keywordflow">return</span>(1); <span class="keywordflow">break</span>;
<a name="l02723"></a>02723         }
<a name="l02724"></a>02724       }
<a name="l02725"></a>02725       <span class="keywordflow">break</span>;
<a name="l02726"></a>02726     
<a name="l02727"></a>02727     <span class="keywordflow">case</span> JKClassArray:
<a name="l02728"></a>02728       {
<a name="l02729"></a>02729         <span class="keywordtype">int</span>     printComma = 0;
<a name="l02730"></a>02730         CFIndex arrayCount = CFArrayGetCount((CFArrayRef)<span class="keywordtype">object</span>), idx = 0L;
<a name="l02731"></a>02731         <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_write1(encodeState, 1L, <span class="stringliteral">&quot;[&quot;</span>))) { <span class="keywordflow">return</span>(1); }
<a name="l02732"></a>02732         <span class="keywordflow">if</span>(JK_EXPECT_F(arrayCount &gt; 1020L)) {
<a name="l02733"></a>02733           <span class="keywordflow">for</span>(<span class="keywordtype">id</span> arrayObject in <span class="keywordtype">object</span>)          { <span class="keywordflow">if</span>(JK_EXPECT_T(printComma)) { <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, <span class="stringliteral">&quot;,&quot;</span>))) { <span class="keywordflow">return</span>(1); } } printComma = 1; <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, arrayObject)))  { <span class="keywordflow">return</span>(1); } }
<a name="l02734"></a>02734         } <span class="keywordflow">else</span> {
<a name="l02735"></a>02735           <span class="keywordtype">void</span> *objects[1024];
<a name="l02736"></a>02736           CFArrayGetValues((CFArrayRef)<span class="keywordtype">object</span>, CFRangeMake(0L, arrayCount), (<span class="keyword">const</span> <span class="keywordtype">void</span> **)objects);
<a name="l02737"></a>02737           <span class="keywordflow">for</span>(idx = 0L; idx &lt; arrayCount; idx++) { <span class="keywordflow">if</span>(JK_EXPECT_T(printComma)) { <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, <span class="stringliteral">&quot;,&quot;</span>))) { <span class="keywordflow">return</span>(1); } } printComma = 1; <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, objects[idx]))) { <span class="keywordflow">return</span>(1); } }
<a name="l02738"></a>02738         }
<a name="l02739"></a>02739         <span class="keywordflow">return</span>(jk_encode_write1(encodeState, -1L, <span class="stringliteral">&quot;]&quot;</span>));
<a name="l02740"></a>02740       }
<a name="l02741"></a>02741       <span class="keywordflow">break</span>;
<a name="l02742"></a>02742 
<a name="l02743"></a>02743     <span class="keywordflow">case</span> JKClassDictionary:
<a name="l02744"></a>02744       {
<a name="l02745"></a>02745         <span class="keywordtype">int</span>     printComma      = 0;
<a name="l02746"></a>02746         CFIndex dictionaryCount = CFDictionaryGetCount((CFDictionaryRef)<span class="keywordtype">object</span>), idx = 0L;
<a name="l02747"></a>02747         <span class="keywordtype">id</span>      enumerateObject = JK_EXPECT_F(_jk_encode_prettyPrint) ? [[object allKeys] sortedArrayUsingSelector:@selector(compare:)] : object;
<a name="l02748"></a>02748 
<a name="l02749"></a>02749         <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_write1(encodeState, 1L, <span class="stringliteral">&quot;{&quot;</span>))) { <span class="keywordflow">return</span>(1); }
<a name="l02750"></a>02750         <span class="keywordflow">if</span>(JK_EXPECT_F(_jk_encode_prettyPrint) || JK_EXPECT_F(dictionaryCount &gt; 1020L)) {
<a name="l02751"></a>02751           <span class="keywordflow">for</span>(<span class="keywordtype">id</span> keyObject in enumerateObject) {
<a name="l02752"></a>02752             <span class="keywordflow">if</span>(JK_EXPECT_T(printComma)) { <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, <span class="stringliteral">&quot;,&quot;</span>))) { <span class="keywordflow">return</span>(1); } }
<a name="l02753"></a>02753             printComma = 1;
<a name="l02754"></a>02754             <span class="keywordflow">if</span>(JK_EXPECT_F((keyObject-&gt;isa      != encodeState-&gt;fastClassLookup.stringClass)) &amp;&amp; JK_EXPECT_F(([keyObject   isKindOfClass:[NSString <span class="keyword">class</span>]] == NO))) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Key must be a string object.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02755"></a>02755             <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, keyObject)))                                                        { <span class="keywordflow">return</span>(1); }
<a name="l02756"></a>02756             <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, <span class="stringliteral">&quot;:&quot;</span>)))                                                                      { <span class="keywordflow">return</span>(1); }
<a name="l02757"></a>02757             <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, (<span class="keywordtype">void</span> *)CFDictionaryGetValue((CFDictionaryRef)<span class="keywordtype">object</span>, keyObject)))) { <span class="keywordflow">return</span>(1); }
<a name="l02758"></a>02758           }
<a name="l02759"></a>02759         } <span class="keywordflow">else</span> {
<a name="l02760"></a>02760           <span class="keywordtype">void</span> *keys[1024], *objects[1024];
<a name="l02761"></a>02761           CFDictionaryGetKeysAndValues((CFDictionaryRef)<span class="keywordtype">object</span>, (<span class="keyword">const</span> <span class="keywordtype">void</span> **)keys, (<span class="keyword">const</span> <span class="keywordtype">void</span> **)objects);
<a name="l02762"></a>02762           <span class="keywordflow">for</span>(idx = 0L; idx &lt; dictionaryCount; idx++) {
<a name="l02763"></a>02763             <span class="keywordflow">if</span>(JK_EXPECT_T(printComma)) { <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, <span class="stringliteral">&quot;,&quot;</span>))) { <span class="keywordflow">return</span>(1); } }
<a name="l02764"></a>02764             printComma = 1;
<a name="l02765"></a>02765             <span class="keywordflow">if</span>(JK_EXPECT_F(((<span class="keywordtype">id</span>)keys[idx])-&gt;isa != encodeState-&gt;fastClassLookup.stringClass) &amp;&amp; JK_EXPECT_F([(<span class="keywordtype">id</span>)keys[idx] isKindOfClass:[NSString <span class="keyword">class</span>]] == NO)) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Key must be a string object.&quot;</span>); <span class="keywordflow">return</span>(1); }
<a name="l02766"></a>02766             <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, keys[idx])))    { <span class="keywordflow">return</span>(1); }
<a name="l02767"></a>02767             <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, <span class="stringliteral">&quot;:&quot;</span>)))                  { <span class="keywordflow">return</span>(1); }
<a name="l02768"></a>02768             <span class="keywordflow">if</span>(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, objects[idx]))) { <span class="keywordflow">return</span>(1); }
<a name="l02769"></a>02769           }
<a name="l02770"></a>02770         }
<a name="l02771"></a>02771         <span class="keywordflow">return</span>(jk_encode_write1(encodeState, -1L, <span class="stringliteral">&quot;}&quot;</span>));
<a name="l02772"></a>02772       }
<a name="l02773"></a>02773       <span class="keywordflow">break</span>;
<a name="l02774"></a>02774 
<a name="l02775"></a>02775     <span class="keywordflow">case</span> JKClassNull: <span class="keywordflow">return</span>(jk_encode_writen(encodeState, cacheSlot, startingAtIndex, encodeCacheObject, <span class="stringliteral">&quot;null&quot;</span>, 4UL)); <span class="keywordflow">break</span>;
<a name="l02776"></a>02776 
<a name="l02777"></a>02777     <span class="keywordflow">default</span>: jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to serialize object class %@.&quot;</span>, NSStringFromClass([<span class="keywordtype">object</span> <span class="keyword">class</span>])); <span class="keywordflow">return</span>(1); <span class="keywordflow">break</span>;
<a name="l02778"></a>02778   }
<a name="l02779"></a>02779 
<a name="l02780"></a>02780   <span class="keywordflow">return</span>(0);
<a name="l02781"></a>02781 }
<a name="l02782"></a>02782 
<a name="l02783"></a>02783 
<a name="l02784"></a>02784 <span class="keyword">@implementation </span>JKSerializer
<a name="l02785"></a>02785 
<a name="l02786"></a>02786 + (id)serializeObject:(<span class="keywordtype">id</span>)object options:(JKSerializeOptionFlags)optionFlags encodeOption:(JKEncodeOptionType)encodeOption block:(JKSERIALIZER_BLOCKS_PROTO)block delegate:(<span class="keywordtype">id</span>)delegate selector:(<span class="keywordtype">SEL</span>)selector error:(NSError **)error
<a name="l02787"></a>02787 {
<a name="l02788"></a>02788   <span class="keywordflow">return</span>([[[[<span class="keyword">self</span> alloc] init] autorelease] serializeObject:<span class="keywordtype">object</span> options:optionFlags encodeOption:encodeOption block:block delegate:delegate selector:selector error:error]);
<a name="l02789"></a>02789 }
<a name="l02790"></a>02790 
<a name="l02791"></a>02791 - (id)serializeObject:(<span class="keywordtype">id</span>)object options:(JKSerializeOptionFlags)optionFlags encodeOption:(JKEncodeOptionType)encodeOption block:(JKSERIALIZER_BLOCKS_PROTO)block delegate:(<span class="keywordtype">id</span>)delegate selector:(<span class="keywordtype">SEL</span>)selector error:(NSError **)error
<a name="l02792"></a>02792 {
<a name="l02793"></a>02793 <span class="preprocessor">#ifndef __BLOCKS__</span>
<a name="l02794"></a>02794 <span class="preprocessor"></span><span class="preprocessor">#pragma unused(block)</span>
<a name="l02795"></a>02795 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02796"></a>02796 <span class="preprocessor"></span>  NSParameterAssert((<span class="keywordtype">object</span> != NULL) &amp;&amp; (encodeState == NULL) &amp;&amp; ((delegate != NULL) ? (block == NULL) : 1) &amp;&amp; ((block != NULL) ? (delegate == NULL) : 1) &amp;&amp;
<a name="l02797"></a>02797                     (((encodeOption &amp; JKEncodeOptionCollectionObj) != 0UL) ? (((encodeOption &amp; JKEncodeOptionStringObj)     == 0UL) &amp;&amp; ((encodeOption &amp; JKEncodeOptionStringObjTrimQuotes) == 0UL)) : 1) &amp;&amp;
<a name="l02798"></a>02798                     (((encodeOption &amp; JKEncodeOptionStringObj)     != 0UL) ?  ((encodeOption &amp; JKEncodeOptionCollectionObj) == 0UL)                                                                 : 1));
<a name="l02799"></a>02799 
<a name="l02800"></a>02800   <span class="keywordtype">id</span> returnObject = NULL;
<a name="l02801"></a>02801 
<a name="l02802"></a>02802   <span class="keywordflow">if</span>(encodeState != NULL) { [<span class="keyword">self</span> releaseState]; }
<a name="l02803"></a>02803   <span class="keywordflow">if</span>((encodeState = (<span class="keyword">struct</span> JKEncodeState *)calloc(1UL, <span class="keyword">sizeof</span>(JKEncodeState))) == NULL) { [NSException raise:NSMallocException format:@&quot;Unable to allocate state structure.&quot;]; <span class="keywordflow">return</span>(NULL); }
<a name="l02804"></a>02804 
<a name="l02805"></a>02805   <span class="keywordflow">if</span>((error != NULL) &amp;&amp; (*error != NULL)) { *error = NULL; }
<a name="l02806"></a>02806 
<a name="l02807"></a>02807   <span class="keywordflow">if</span>(delegate != NULL) {
<a name="l02808"></a>02808     <span class="keywordflow">if</span>(selector                               == NULL) { [NSException raise:NSInvalidArgumentException format:@&quot;The delegate argument is not NULL, but the selector argument is NULL.&quot;]; }
<a name="l02809"></a>02809     <span class="keywordflow">if</span>([delegate respondsToSelector:selector] == NO)   { [NSException raise:NSInvalidArgumentException format:@&quot;The serializeUnsupportedClassesUsingDelegate: delegate does not respond to the selector argument.&quot;]; }
<a name="l02810"></a>02810     encodeState-&gt;classFormatterDelegate = delegate;
<a name="l02811"></a>02811     encodeState-&gt;classFormatterSelector = selector;
<a name="l02812"></a>02812     encodeState-&gt;classFormatterIMP      = (JKClassFormatterIMP)[delegate methodForSelector:selector];
<a name="l02813"></a>02813     NSCParameterAssert(encodeState-&gt;classFormatterIMP != NULL);
<a name="l02814"></a>02814   }
<a name="l02815"></a>02815 
<a name="l02816"></a>02816 <span class="preprocessor">#ifdef __BLOCKS__</span>
<a name="l02817"></a>02817 <span class="preprocessor"></span>  encodeState-&gt;classFormatterBlock                          = block;
<a name="l02818"></a>02818 <span class="preprocessor">#endif</span>
<a name="l02819"></a>02819 <span class="preprocessor"></span>  encodeState-&gt;serializeOptionFlags                         = optionFlags;
<a name="l02820"></a>02820   encodeState-&gt;encodeOption                                 = encodeOption;
<a name="l02821"></a>02821   encodeState-&gt;stringBuffer.roundSizeUpToMultipleOf         = (1024UL * 32UL);
<a name="l02822"></a>02822   encodeState-&gt;utf8ConversionBuffer.roundSizeUpToMultipleOf = 4096UL;
<a name="l02823"></a>02823     
<a name="l02824"></a>02824   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> stackJSONBuffer[JK_JSONBUFFER_SIZE] JK_ALIGNED(64);
<a name="l02825"></a>02825   jk_managedBuffer_setToStackBuffer(&amp;encodeState-&gt;stringBuffer,         stackJSONBuffer, <span class="keyword">sizeof</span>(stackJSONBuffer));
<a name="l02826"></a>02826 
<a name="l02827"></a>02827   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> stackUTF8Buffer[JK_UTF8BUFFER_SIZE] JK_ALIGNED(64);
<a name="l02828"></a>02828   jk_managedBuffer_setToStackBuffer(&amp;encodeState-&gt;utf8ConversionBuffer, stackUTF8Buffer, <span class="keyword">sizeof</span>(stackUTF8Buffer));
<a name="l02829"></a>02829 
<a name="l02830"></a>02830   <span class="keywordflow">if</span>(((encodeOption &amp; JKEncodeOptionCollectionObj) != 0UL) &amp;&amp; (([<span class="keywordtype">object</span> isKindOfClass:[NSArray  <span class="keyword">class</span>]] == NO) &amp;&amp; ([<span class="keywordtype">object</span> isKindOfClass:[NSDictionary <span class="keyword">class</span>]] == NO))) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to serialize object class %@, expected a NSArray or NSDictionary.&quot;</span>, NSStringFromClass([<span class="keywordtype">object</span> <span class="keyword">class</span>])); <span class="keywordflow">goto</span> errorExit; }
<a name="l02831"></a>02831   <span class="keywordflow">if</span>(((encodeOption &amp; JKEncodeOptionStringObj)     != 0UL) &amp;&amp;  ([<span class="keywordtype">object</span> isKindOfClass:[NSString <span class="keyword">class</span>]] == NO))                                                         { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to serialize object class %@, expected a NSString.&quot;</span>, NSStringFromClass([<span class="keywordtype">object</span> <span class="keyword">class</span>])); <span class="keywordflow">goto</span> errorExit; }
<a name="l02832"></a>02832 
<a name="l02833"></a>02833   <span class="keywordflow">if</span>(jk_encode_add_atom_to_buffer(encodeState, <span class="keywordtype">object</span>) == 0) {
<a name="l02834"></a>02834     BOOL stackBuffer = ((encodeState-&gt;stringBuffer.flags &amp; JKManagedBufferMustFree) == 0UL) ? YES : NO;
<a name="l02835"></a>02835     
<a name="l02836"></a>02836     <span class="keywordflow">if</span>((encodeState-&gt;atIndex &lt; 2UL))
<a name="l02837"></a>02837     <span class="keywordflow">if</span>((stackBuffer == NO) &amp;&amp; ((encodeState-&gt;stringBuffer.bytes.ptr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)reallocf(encodeState-&gt;stringBuffer.bytes.ptr, encodeState-&gt;atIndex + 16UL)) == NULL)) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to realloc buffer&quot;</span>); <span class="keywordflow">goto</span> errorExit; }
<a name="l02838"></a>02838 
<a name="l02839"></a>02839     <span class="keywordflow">switch</span>((encodeOption &amp; JKEncodeOptionAsTypeMask)) {
<a name="l02840"></a>02840       <span class="keywordflow">case</span> JKEncodeOptionAsData:
<a name="l02841"></a>02841         <span class="keywordflow">if</span>(stackBuffer == YES) { <span class="keywordflow">if</span>((returnObject = [(<span class="keywordtype">id</span>)CFDataCreate(                 NULL,                encodeState-&gt;stringBuffer.bytes.ptr, (CFIndex)encodeState-&gt;atIndex)                                  autorelease]) == NULL) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to create NSData object&quot;</span>); } }
<a name="l02842"></a>02842         <span class="keywordflow">else</span>                   { <span class="keywordflow">if</span>((returnObject = [(<span class="keywordtype">id</span>)CFDataCreateWithBytesNoCopy(  NULL,                encodeState-&gt;stringBuffer.bytes.ptr, (CFIndex)encodeState-&gt;atIndex, NULL)                            autorelease]) == NULL) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to create NSData object&quot;</span>); } }
<a name="l02843"></a>02843         <span class="keywordflow">break</span>;
<a name="l02844"></a>02844 
<a name="l02845"></a>02845       <span class="keywordflow">case</span> JKEncodeOptionAsString:
<a name="l02846"></a>02846         <span class="keywordflow">if</span>(stackBuffer == YES) { <span class="keywordflow">if</span>((returnObject = [(<span class="keywordtype">id</span>)CFStringCreateWithBytes(      NULL, (<span class="keyword">const</span> UInt8 *)encodeState-&gt;stringBuffer.bytes.ptr, (CFIndex)encodeState-&gt;atIndex, kCFStringEncodingUTF8, NO)       autorelease]) == NULL) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to create NSString object&quot;</span>); } }
<a name="l02847"></a>02847         <span class="keywordflow">else</span>                   { <span class="keywordflow">if</span>((returnObject = [(<span class="keywordtype">id</span>)CFStringCreateWithBytesNoCopy(NULL, (<span class="keyword">const</span> UInt8 *)encodeState-&gt;stringBuffer.bytes.ptr, (CFIndex)encodeState-&gt;atIndex, kCFStringEncodingUTF8, NO, NULL) autorelease]) == NULL) { jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unable to create NSString object&quot;</span>); } }
<a name="l02848"></a>02848         <span class="keywordflow">break</span>;
<a name="l02849"></a>02849 
<a name="l02850"></a>02850       <span class="keywordflow">default</span>: jk_encode_error(encodeState, <span class="stringliteral">@&quot;Unknown encode as type.&quot;</span>); <span class="keywordflow">break</span>;
<a name="l02851"></a>02851     }
<a name="l02852"></a>02852 
<a name="l02853"></a>02853     <span class="keywordflow">if</span>((returnObject != NULL) &amp;&amp; (stackBuffer == NO)) { encodeState-&gt;stringBuffer.flags &amp;= ~JKManagedBufferMustFree; encodeState-&gt;stringBuffer.bytes.ptr = NULL; encodeState-&gt;stringBuffer.bytes.length = 0UL; }
<a name="l02854"></a>02854   }
<a name="l02855"></a>02855 
<a name="l02856"></a>02856 errorExit:
<a name="l02857"></a>02857   <span class="keywordflow">if</span>((encodeState != NULL) &amp;&amp; (error != NULL) &amp;&amp; (encodeState-&gt;error != NULL)) { *error = encodeState-&gt;error; encodeState-&gt;error = NULL; }
<a name="l02858"></a>02858   [<span class="keyword">self</span> releaseState];
<a name="l02859"></a>02859 
<a name="l02860"></a>02860   <span class="keywordflow">return</span>(returnObject);
<a name="l02861"></a>02861 }
<a name="l02862"></a>02862 
<a name="l02863"></a>02863 - (void)releaseState
<a name="l02864"></a>02864 {
<a name="l02865"></a>02865   <span class="keywordflow">if</span>(encodeState != NULL) {
<a name="l02866"></a>02866     jk_managedBuffer_release(&amp;encodeState-&gt;stringBuffer);
<a name="l02867"></a>02867     jk_managedBuffer_release(&amp;encodeState-&gt;utf8ConversionBuffer);
<a name="l02868"></a>02868     free(encodeState); encodeState = NULL;
<a name="l02869"></a>02869   }  
<a name="l02870"></a>02870 }
<a name="l02871"></a>02871 
<a name="l02872"></a>02872 - (void)dealloc
<a name="l02873"></a>02873 {
<a name="l02874"></a>02874   [<span class="keyword">self</span> releaseState];
<a name="l02875"></a>02875   [<span class="keyword">super</span> dealloc];
<a name="l02876"></a>02876 }
<a name="l02877"></a>02877 
<a name="l02878"></a>02878 <span class="keyword">@end</span>
<a name="l02879"></a>02879 
<a name="l02880"></a>02880 <span class="keyword">@implementation </span>NSString (JSONKitSerializing)
<a name="l02881"></a>02881 
<a name="l02883"></a>02883 <span class="preprocessor">#pragma mark Methods for serializing a single NSString.</span>
<a name="l02884"></a>02884 <span class="preprocessor"></span>
<a name="l02885"></a>02885 
<a name="l02886"></a>02886 <span class="comment">// Useful for those who need to serialize just a NSString.  Otherwise you would have to do something like [NSArray arrayWithObject:stringToBeJSONSerialized], serializing the array, and then chopping of the extra ^\[.*\]$ square brackets.</span>
<a name="l02887"></a>02887 
<a name="l02888"></a>02888 <span class="comment">// NSData returning methods...</span>
<a name="l02889"></a>02889 
<a name="l02890"></a>02890 - (<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)JSONData
<a name="l02891"></a>02891 {
<a name="l02892"></a>02892   <span class="keywordflow">return</span>([<span class="keyword">self</span> JSONDataWithOptions:JKSerializeOptionNone includeQuotes:YES error:NULL]);
<a name="l02893"></a>02893 }
<a name="l02894"></a>02894 
<a name="l02895"></a>02895 - (<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions includeQuotes:(BOOL)includeQuotes error:(NSError **)error
<a name="l02896"></a>02896 {
<a name="l02897"></a>02897   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:serializeOptions encodeOption:(JKEncodeOptionAsData | ((includeQuotes == NO) ? JKEncodeOptionStringObjTrimQuotes : 0UL) | JKEncodeOptionStringObj) block:NULL delegate:NULL selector:NULL error:error]);
<a name="l02898"></a>02898 }
<a name="l02899"></a>02899 
<a name="l02900"></a>02900 <span class="comment">// NSString returning methods...</span>
<a name="l02901"></a>02901 
<a name="l02902"></a>02902 - (NSString *)JSONString
<a name="l02903"></a>02903 {
<a name="l02904"></a>02904   <span class="keywordflow">return</span>([<span class="keyword">self</span> JSONStringWithOptions:JKSerializeOptionNone includeQuotes:YES error:NULL]);
<a name="l02905"></a>02905 }
<a name="l02906"></a>02906 
<a name="l02907"></a>02907 - (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions includeQuotes:(BOOL)includeQuotes error:(NSError **)error
<a name="l02908"></a>02908 {
<a name="l02909"></a>02909   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:serializeOptions encodeOption:(JKEncodeOptionAsString | ((includeQuotes == NO) ? JKEncodeOptionStringObjTrimQuotes : 0UL) | JKEncodeOptionStringObj) block:NULL delegate:NULL selector:NULL error:error]);
<a name="l02910"></a>02910 }
<a name="l02911"></a>02911 
<a name="l02912"></a>02912 <span class="keyword">@end</span>
<a name="l02913"></a>02913 
<a name="l02914"></a>02914 <span class="keyword">@implementation </span>NSArray (JSONKitSerializing)
<a name="l02915"></a>02915 
<a name="l02916"></a>02916 <span class="comment">// NSData returning methods...</span>
<a name="l02917"></a>02917 
<a name="l02918"></a>02918 - (<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)JSONData
<a name="l02919"></a>02919 {
<a name="l02920"></a>02920   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:JKSerializeOptionNone encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:NULL]);
<a name="l02921"></a>02921 }
<a name="l02922"></a>02922 
<a name="l02923"></a>02923 - (<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions error:(NSError **)error
<a name="l02924"></a>02924 {
<a name="l02925"></a>02925   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:error]);
<a name="l02926"></a>02926 }
<a name="l02927"></a>02927 
<a name="l02928"></a>02928 - (<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingDelegate:(<span class="keywordtype">id</span>)delegate selector:(<span class="keywordtype">SEL</span>)selector error:(NSError **)error
<a name="l02929"></a>02929 {
<a name="l02930"></a>02930   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:delegate selector:selector error:error]);
<a name="l02931"></a>02931 }
<a name="l02932"></a>02932 
<a name="l02933"></a>02933 <span class="comment">// NSString returning methods...</span>
<a name="l02934"></a>02934 
<a name="l02935"></a>02935 - (NSString *)JSONString
<a name="l02936"></a>02936 {
<a name="l02937"></a>02937   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:JKSerializeOptionNone encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:NULL]);
<a name="l02938"></a>02938 }
<a name="l02939"></a>02939 
<a name="l02940"></a>02940 - (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions error:(NSError **)error
<a name="l02941"></a>02941 {
<a name="l02942"></a>02942   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:error]);
<a name="l02943"></a>02943 }
<a name="l02944"></a>02944 
<a name="l02945"></a>02945 - (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingDelegate:(<span class="keywordtype">id</span>)delegate selector:(<span class="keywordtype">SEL</span>)selector error:(NSError **)error
<a name="l02946"></a>02946 {
<a name="l02947"></a>02947   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:delegate selector:selector error:error]);
<a name="l02948"></a>02948 }
<a name="l02949"></a>02949 
<a name="l02950"></a>02950 <span class="keyword">@end</span>
<a name="l02951"></a>02951 
<a name="l02952"></a>02952 <span class="keyword">@implementation </span>NSDictionary (JSONKitSerializing)
<a name="l02953"></a>02953 
<a name="l02954"></a>02954 <span class="comment">// NSData returning methods...</span>
<a name="l02955"></a>02955 
<a name="l02956"></a>02956 - (<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)JSONData
<a name="l02957"></a>02957 {
<a name="l02958"></a>02958   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:JKSerializeOptionNone encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:NULL]);
<a name="l02959"></a>02959 }
<a name="l02960"></a>02960 
<a name="l02961"></a>02961 - (<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions error:(NSError **)error
<a name="l02962"></a>02962 {
<a name="l02963"></a>02963   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:error]);
<a name="l02964"></a>02964 }
<a name="l02965"></a>02965 
<a name="l02966"></a>02966 - (<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingDelegate:(<span class="keywordtype">id</span>)delegate selector:(<span class="keywordtype">SEL</span>)selector error:(NSError **)error
<a name="l02967"></a>02967 {
<a name="l02968"></a>02968   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:delegate selector:selector error:error]);
<a name="l02969"></a>02969 }
<a name="l02970"></a>02970 
<a name="l02971"></a>02971 <span class="comment">// NSString returning methods...</span>
<a name="l02972"></a>02972 
<a name="l02973"></a>02973 - (NSString *)JSONString
<a name="l02974"></a>02974 {
<a name="l02975"></a>02975   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:JKSerializeOptionNone encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:NULL]);
<a name="l02976"></a>02976 }
<a name="l02977"></a>02977 
<a name="l02978"></a>02978 - (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions error:(NSError **)error
<a name="l02979"></a>02979 {
<a name="l02980"></a>02980   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:error]);
<a name="l02981"></a>02981 }
<a name="l02982"></a>02982 
<a name="l02983"></a>02983 - (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingDelegate:(<span class="keywordtype">id</span>)delegate selector:(<span class="keywordtype">SEL</span>)selector error:(NSError **)error
<a name="l02984"></a>02984 {
<a name="l02985"></a>02985   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:delegate selector:selector error:error]);
<a name="l02986"></a>02986 }
<a name="l02987"></a>02987 
<a name="l02988"></a>02988 <span class="keyword">@end</span>
<a name="l02989"></a>02989 
<a name="l02990"></a>02990 
<a name="l02991"></a>02991 <span class="preprocessor">#ifdef __BLOCKS__</span>
<a name="l02992"></a>02992 <span class="preprocessor"></span>
<a name="l02993"></a>02993 <span class="keyword">@implementation </span>NSArray (JSONKitSerializingBlockAdditions)
<a name="l02994"></a>02994 
<a name="l02995"></a>02995 - (<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingBlock:(<span class="keywordtype">id</span>(^)(<span class="keywordtype">id</span> <span class="keywordtype">object</span>))block error:(NSError **)error
<a name="l02996"></a>02996 {
<a name="l02997"></a>02997   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:block delegate:NULL selector:NULL error:error]);
<a name="l02998"></a>02998 }
<a name="l02999"></a>02999 
<a name="l03000"></a>03000 - (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingBlock:(<span class="keywordtype">id</span>(^)(<span class="keywordtype">id</span> <span class="keywordtype">object</span>))block error:(NSError **)error
<a name="l03001"></a>03001 {
<a name="l03002"></a>03002   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:block delegate:NULL selector:NULL error:error]);
<a name="l03003"></a>03003 }
<a name="l03004"></a>03004 
<a name="l03005"></a>03005 <span class="keyword">@end</span>
<a name="l03006"></a>03006 
<a name="l03007"></a>03007 <span class="keyword">@implementation </span>NSDictionary (JSONKitSerializingBlockAdditions)
<a name="l03008"></a>03008 
<a name="l03009"></a>03009 - (<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingBlock:(<span class="keywordtype">id</span>(^)(<span class="keywordtype">id</span> <span class="keywordtype">object</span>))block error:(NSError **)error
<a name="l03010"></a>03010 {
<a name="l03011"></a>03011   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:block delegate:NULL selector:NULL error:error]);
<a name="l03012"></a>03012 }
<a name="l03013"></a>03013 
<a name="l03014"></a>03014 - (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingBlock:(<span class="keywordtype">id</span>(^)(<span class="keywordtype">id</span> <span class="keywordtype">object</span>))block error:(NSError **)error
<a name="l03015"></a>03015 {
<a name="l03016"></a>03016   <span class="keywordflow">return</span>([JKSerializer serializeObject:<span class="keyword">self</span> options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:block delegate:NULL selector:NULL error:error]);
<a name="l03017"></a>03017 }
<a name="l03018"></a>03018 
<a name="l03019"></a>03019 <span class="keyword">@end</span>
<a name="l03020"></a>03020 
<a name="l03021"></a>03021 <span class="preprocessor">#endif // __BLOCKS__</span>
<a name="l03022"></a>03022 <span class="preprocessor"></span>
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>JSONKit.m</b>      </li>
</div><!-- .fixedwidth -->


    <span class="footer">Generated for Nimbus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4-20110629 </span>
   </ul>
 </div>


</div> <!-- page -->
</body>
</html>
